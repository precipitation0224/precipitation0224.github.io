<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yummy home</title>
  
  <subtitle>欢迎你来看看我呀</subtitle>
  <link href="http://precipitation0224.github.io/atom.xml" rel="self"/>
  
  <link href="http://precipitation0224.github.io/"/>
  <updated>2023-03-15T12:07:06.448Z</updated>
  <id>http://precipitation0224.github.io/</id>
  
  <author>
    <name>Yummy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚函数动态绑定</title>
    <link href="http://precipitation0224.github.io/2023/03/16/virtualpointer/"/>
    <id>http://precipitation0224.github.io/2023/03/16/virtualpointer/</id>
    <published>2023-03-15T20:01:55.000Z</published>
    <updated>2023-03-15T12:07:06.448Z</updated>
    
    <content type="html"><![CDATA[<p>14、虚函数如何实现动态转发，每个类都有虚函数表吗</p><p>虚函数是在某基类中声明为<em><strong>virtual</strong></em>并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。</p><p>函数是通过<strong>虚函数表</strong>来实现的。每一个含有虚函数的类，都会有一个虚函数表用来存放虚函数的地址，同时类会有一个<strong>虚表指针</strong>去指向虚函数表的首地址,<strong>对象的首地址就存放着虚表指针</strong>。</p><p><strong>虚函数表：</strong>要讲清楚动态绑定的流程，首先需要了解清楚类里面虚函数表的定义，虚函数表是记录虚函数入口地址的一串数组（实际是一个函数指针数组），它只存在于定义了虚函数的类里面，这里给出一个例子来展示类中虚函数表的存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//空类的大小为1</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//大小为4，成员变量会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为4，非虚函数不会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为16，定义虚函数会增加类的大小，但是这个增加不是虚函数带来了的，而是指向虚函数表的指针所占的空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//大小为16，从这儿可以看到，类里面的多个虚函数都维护在一个虚函数表里面，只有一个指向虚函数表的指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(C)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(D)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(E)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//实际上，虚函数不占用类对象的存储空间，</span><br><span class="hljs-comment">//所以含有一个以上的虚函数的类对象大小与仅含一个虚函数大小相同</span><br><span class="hljs-comment">//同时，针对每个类，只维护一个【虚函数表（函数指针数组数组）】</span><br><span class="hljs-comment">//用于存放该类中虚函数的地址，每个【含一个及以上虚函数的对象都会含有一个指向该类虚函数表的指针】。</span><br></code></pre></td></tr></table></figure><p><strong>动态绑定虚函数工作原理：</strong> 前面提到，每一个类会为所有虚函数数维护一个虚函数表，并且有一个指针指向这个表的首地址，这个虚函数表记录着所有的虚函数的入口地址。那么在动态绑定时，编译器是如何给基类指针返回一个正确的函数入口地址，这里给出一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> a1;<br>        <span class="hljs-type">int</span> a2;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::display()&quot;</span>&lt;&lt;endl;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::clone()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::init()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> B&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::execute()&quot;</span>&lt;&lt;endl;&#125; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;C::init()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-keyword">override</span><br></code></pre></td></tr></table></figure><p>这里给出A,B,C三个类的内存情况，如下图。可以得出这么几个结论：</p><ol><li>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的</li><li>同名虚函数在基类和派生类中的虚函数表中，索引是一致的，如下图，A,B,C的display的索引都是0</li><li>派生类中，一旦对基类中的虚函数进行了覆盖，那么派生类的虚函数表中响应函数的入口地址会被替换成覆盖后的函数的地址。</li><li>一旦有新的虚函数定义，会加入到当前虚函数表的末端。</li></ol><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><em><strong>reference link</strong></em>: <a href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;14、虚函数如何实现动态转发，每个类都有虚函数表吗&lt;/p&gt;
&lt;p&gt;虚函数是在某基类中声明为&lt;em&gt;&lt;strong&gt;virtual&lt;/strong&gt;&lt;/em&gt;并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。&lt;/p&gt;
&lt;p&gt;函数是通过&lt;strong&gt;虚函数</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>http缺陷，tls和QUIC</title>
    <link href="http://precipitation0224.github.io/2023/03/16/tls/"/>
    <id>http://precipitation0224.github.io/2023/03/16/tls/</id>
    <published>2023-03-15T19:53:04.000Z</published>
    <updated>2023-03-15T11:53:49.191Z</updated>
    
    <content type="html"><![CDATA[<p>10、http安全保证，tls，如何握手</p><p>HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：</p><ol><li>通信使用明文，内容可能被窃听。</li><li>不验证通信方的身份，因此有可能遭到伪装。</li><li>无法验证报文的完整性，所以有可能被篡改。</li><li>传统的HTTP请求过程都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求和响应被黑客拦截，并且里面含有密码等敏感数据的话，会非常危险。</li></ol><p><em><strong>QUIC</strong></em> 协议 (RFC 9000) 旨在提高 Web 性能并减少访问延迟，同时保持通信机密。 一种基本方法是通过将 QUIC 握手与 TLS 1.3 握手集成并将多个 QUIC 数据包合并到一个 UDP 数据报中来减少初始往返时间 (RTT)。</p><p>总的来说，QUIC 相比于 HTTP&#x2F;2.0 来说，具有下面这些优势：</p><ul><li>使用 UDP 协议，不需要三次连接进行握手，而且也会缩短 TLS 建立连接的时间。</li><li>解决了队头阻塞问题</li><li>实现动态可插拔，在应用层实现了拥塞控制算法，可以随时切换。</li><li>报文头和报文体分别进行认证和加密处理，保障安全性。</li><li>连接能够平滑迁移</li></ul><p>连接平滑迁移指的是，你的手机或者移动设备在 4G 信号下和 WiFi 等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;10、http安全保证，tls，如何握手&lt;/p&gt;
&lt;p&gt;HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通信使用明文，内容可能被窃听。&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>cookie总结</title>
    <link href="http://precipitation0224.github.io/2023/03/16/cookie%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/16/cookie%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-15T18:59:45.000Z</published>
    <updated>2023-03-15T11:00:16.115Z</updated>
    
    <content type="html"><![CDATA[<p>8、cookie</p><p><strong>cookie</strong>是当前识别用户，实现持久化会话的最好方式。简单点说就是服务器知道正在和哪个客户端通信，以及保持与已识别出的客户端通信。Cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它。同时可以对连接另一端的用户有更多的了解，并且能在用户浏览页面时对其进行跟踪。</p><p><strong>cookie</strong>可以分为以下两类：</p><p>（1）会话cookie。临时cookie，记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除了。</p><p>（2）持久cookie。持久cookie的生存时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。</p><p>唯一区别就是它们的过期时间。如果设置了Discard参数或没有设置Expires或没有设置Max-Age参数则说明这个cookie就是一个会话cookie。</p><p><strong>存储</strong>——浏览器负责存储cookie信息。不同的浏览器会以不同的方式来存储cookie。有的浏览器用cookis.txt存储。有的浏览器存储在高速缓存目录下独立的文本文件中。</p><p><strong>cookie</strong>存在安全隐患。第三方Web站点使用持久cookie来跟踪用户就是对cookie一种最大的滥用。将这种做法与IP地址和Referer首部信息结合在一起，这些营销公司就可以构建起相当精确的用户档案和浏览模式信息。</p><p><strong>cookie工作原理</strong></p><p>（1）用户首次访问Web站点时，Web服务器对用户一无所知。</p><p>（2）Web服务器通过Set-Cookie首部将cookie存放到浏览器中的cookie数据库中。cookie中包含了N个键值对，例如Cookie: id&#x3D;“1234”。cookie中可以包含任意信息，但它们通常都只包含一个服务器为了进行跟踪而产生的独特的识别码。</p><p>（3）将来用户再次访问同一站点时，浏览器会从cookie数据库中挑中那个服务器设置的cookie，并在cookie请求首部中（Cookie: id&#x3D;“1234”）将其传回给服务器。</p><p>（4）服务器可以通过id&#x3D;”1234”这个键值对来查找服务器为其访问积累的信息（购物历史、地址信息等）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;8、cookie&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie&lt;/strong&gt;是当前识别用户，实现持久化会话的最好方式。简单点说就是服务器知道正在和哪个客户端通信，以及保持与已识别出的客户端通信。Cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>C++中的unicode</title>
    <link href="http://precipitation0224.github.io/2023/03/16/C-%E4%B8%AD%E7%9A%84unicode/"/>
    <id>http://precipitation0224.github.io/2023/03/16/C-%E4%B8%AD%E7%9A%84unicode/</id>
    <published>2023-03-15T18:50:57.000Z</published>
    <updated>2023-03-15T10:51:38.295Z</updated>
    
    <content type="html"><![CDATA[<p>7、utf8，utf16区别，c++用哪个</p><p><strong>UTF-8(8-bit Unicode Transformation Format)</strong></p><p>UTF-8是一种变长编码，对于一个Unicode的字符被编码成1至4个字节</p><p>优点:<br>1.向后兼容ASCII编码；<br>2.没有字节序(大小端)的问题适合网络传输；<br>3.存储英文和拉丁文等字符非常节省存储空间。<br>缺点:<br>1.变长编码不利于文本处理；<br>2.对于CJK等文字比较浪费存储空间。</p><p><strong>UTF-16(16-bit Unicode Transformation Format)</strong></p><p>UTF-16也是一种变长编码，对于一个Unicode字符被编码成1至2个码元，每个码元为16位</p><p>优点:<br>1.绝大部分的文字都可以用两个字节编码，对于CJK文字是比较节省空间的；<br>2.文本处理比UTF-8方便得多。<br>缺点:<br>1.存储和传输需要考虑字节序的问题；<br>2.不兼容ASCII。</p><p><strong>USL（Unicode String Literals）</strong>是C++11对Unicode提供的语言级别的支持。在C++11之前C++中有个<strong>wchar_t</strong>的类型用于存储宽字符（Wide-Character）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UTFCONVERT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UTFCONVERT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br> <br><span class="hljs-comment">// 从UTF16编码字符串构建，需要带BOM标记</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 从UTF16 LE编码的字符串创建</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16le_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 从UTF16BE编码字符串创建</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16be_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 获取转换为UTF-16 LE编码的字符串</span><br><span class="hljs-function">std::u16string <span class="hljs-title">utf8_to_utf16le</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; u8str, <span class="hljs-type">bool</span> addbom = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span>* ok = <span class="hljs-literal">NULL</span>)</span></span>;<br> <br><span class="hljs-comment">// 获取转换为UTF-16 BE的字符串</span><br><span class="hljs-function">std::u16string <span class="hljs-title">utf8_to_utf16be</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; u8str, <span class="hljs-type">bool</span> addbom = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span>* ok = <span class="hljs-literal">NULL</span>)</span></span>;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//! __UTFCONVERT_H__</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;7、utf8，utf16区别，c++用哪个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8(8-bit Unicode Transformation Format)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTF-8是一种变长编码，对于一个Unicode的字符被编码成1至4个字节&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>http 1.0/2/3优化</title>
    <link href="http://precipitation0224.github.io/2023/03/16/1-0-2-3%E4%BC%98%E5%8C%96/"/>
    <id>http://precipitation0224.github.io/2023/03/16/1-0-2-3%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-15T18:43:59.000Z</published>
    <updated>2023-03-15T10:52:41.760Z</updated>
    
    <content type="html"><![CDATA[<p>6、http1.0&#x2F;1 2 3优化</p><p><em><strong>HTTP1.0</strong></em></p><p>1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。</p><p>浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪也每个客户单，也不记录过去的请求（无状态）。</p><p>这种无状态性可以借助<strong>cookie&#x2F;session</strong>机制来做身份认证和状态记录。</p><p>无法复用连接</p><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p><p>队头阻塞（head of line blocking）</p><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p><p><em><strong>HTTP 1.1</strong></em></p><ul><li>长连接，流水线，使用connection:keep-alive使用长连接</li><li>请求管道化</li><li>增加缓存处理（新的字段如cache-control）</li><li>增加Host字段，支持断点传输等</li><li>由于长连接会给服务器造成压力</li></ul><p><em><strong>HTTP 2.0</strong></em></p><ul><li>二进制分帧</li><li>头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小</li><li>多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求</li><li>服务器推送（Sever push）</li></ul><p><em><strong>HTTP 3.0</strong></em></p><ul><li>基于google的QUIC协议，而quic协议是使用udp实现的</li><li>减少了tcp三次握手时间，以及tls握手时间</li><li>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题</li><li>优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗</li><li>连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接</li><li>更合适的流量控制</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;6、http1.0&amp;#x2F;1 2 3优化&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;HTTP1.0&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。&lt;/p&gt;
&lt;p&gt;浏览器每次</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>浮点数和MD5,Base64</title>
    <link href="http://precipitation0224.github.io/2023/03/16/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/"/>
    <id>http://precipitation0224.github.io/2023/03/16/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/</id>
    <published>2023-03-15T18:32:32.000Z</published>
    <updated>2023-03-15T10:34:22.935Z</updated>
    
    <content type="html"><![CDATA[<p>4、浮点数的存储方式</p><ol><li><p>符号位：‘+’存储为0，‘-’存储为1</p></li><li><p>将数字转化成二进制数</p></li><li><p>将二进制数规范化为 1.xxxxxxxx*2^n</p></li><li><p>将n转化为指数（+127） 尾数xxxx后面补零</p></li></ol><p>5、介绍MD5、Base64</p><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。md5运算结果是一个固定长度为128位的二进制数，经过一系列的运算得到32个16进制数。</p><p>Base64是一种使用64基的位置计数法。它使用2的最大次方来代表仅可打印的ASCII字符。这使它可用来作为电子邮件的传输编码。在Base64中的变量使用字符A-Z、a-z和0-9，这样共有62个字符，用来作为开始的64个数字，最后两个用来作为数字的符号在不同的系统中而不同。一些如unencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。</p><p>MD5加密算法是不可逆的，base64加密算法是可逆的；MD5加密算法是不可逆的，base64加密算法是可逆的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;4、浮点数的存储方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;符号位：‘+’存储为0，‘-’存储为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将数字转化成二进制数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将二进制数规范化为 1.xxxxxxxx*2^n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将n转</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>string的缺陷和指针选择</title>
    <link href="http://precipitation0224.github.io/2023/03/15/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/"/>
    <id>http://precipitation0224.github.io/2023/03/15/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/</id>
    <published>2023-03-15T13:07:29.000Z</published>
    <updated>2023-03-15T05:08:01.595Z</updated>
    
    <content type="html"><![CDATA[<p>2、std::string的缺陷</p><p>最大的缺点是 std::string 是「字节串」而非「字符串」</p><ol><li>它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；</li><li>不能很好的处理宽字节的字符；</li><li>没有足够多的好用的函数，没有format格式输出，要借助要用stdio.h头文件里的 sprintf 函数。</li></ol><p>3、智能指针和原生指针的开销</p><p><strong>泛型指针：</strong></p><p>泛型指针有多种含义。1) 指void*指针，可以指向任意数据类型，因此具有“泛型”含义。2) 指具有指针特性的泛型数据结构，包含泛型的迭代器、智能指针等。 广义的迭代器是一种不透明指针，能够实现遍历访问操作。通常所说的迭代器是指狭义的迭代器，即基于C++的STL中基于泛型的iterator_traits实现的类的实例。总体来说，泛型指针和迭代器是两个不同的概念，其中的交集则是通常提到的迭代器类。</p><p><strong>原生指针：</strong></p><p>原生指针就是普通指针， 定义类似：类型 <em>变量名（int <em>p）;相反的若是一个类重载了‘</em>’和‘-&gt;’的运算符，能够像指针同样用‘</em>’和‘-&gt;’操做，就不是原生的，如iterator等。说“原生”是指“最简朴最基本的那一种”。因为现在很多东西都抽象化理论化了，所以“以前的那种最简朴最基本的指针”只是一个抽象概念（比如iterator）的表现形式之一。</p><p>c++的原生指针又可以分为普通指针，成员指针，函数指针。</p><p><strong>智能指针：</strong></p><p>智能指针是c++2.0的新特性之一，其最大的特点在于其结合了指针和对象构造析构的优点RAII，使得其在其生存期结束时可以及时释放其所管理的资源（动态内存分配得到的资源）。由于 C++ 语言没有自动内存回收机制，程序员每次得自己处理内存相关问题，但用智能指针便可以有效缓解这类问题。 一般是把指针封装到一个称之为智能指针类中，这个类中另外还封装了一个使用计数器，对指针的复制等操作将导致该计数器的值加1，对指针的delete操作则会减1，值为0时，指针为NULL。下面是智能指针的选择。</p><p>（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括三种：</p><ol><li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li><li>两个对象包含都指向第三个对象的指针；</li><li>STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</li></ol><p>（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2、std::string的缺陷&lt;/p&gt;
&lt;p&gt;最大的缺点是 std::string 是「字节串」而非「字符串」&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>两道基础算法</title>
    <link href="http://precipitation0224.github.io/2023/03/15/%E4%B8%A4%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <id>http://precipitation0224.github.io/2023/03/15/%E4%B8%A4%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-15T10:59:52.000Z</published>
    <updated>2023-03-15T03:02:22.158Z</updated>
    
    <content type="html"><![CDATA[<p>16、Q1：整数与ip地址的转换；Q2：小q第一天挖11币，第二天比前一天少一个币，以此类推，但休息一天又可以挖到11币,问第n天能挖多少币</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* ip转无符号数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">ipToInt</span><span class="hljs-params">(string ip)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = ip.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; ipList;<br>    <span class="hljs-comment">//split</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; l &amp;&amp; ip[j] != <span class="hljs-string">&#x27;.&#x27;</span>) j++;<br>        ipList.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(ip.<span class="hljs-built_in">substr</span>(i, j - i)));<br>        i = j;<br>    &#125;<br>    <span class="hljs-type">int</span> n = ipList.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">unsigned</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res = res &lt;&lt; <span class="hljs-number">8</span> | ipList[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 无符号数转ip</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">intToIp</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> num)</span> </span>&#123;<br>    vector&lt;string&gt; ipList;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>        string seg = <span class="hljs-built_in">to_string</span>(num &amp; <span class="hljs-number">255</span>);<br>        ipList.<span class="hljs-built_in">push_back</span>(seg);<br>        num = num &gt;&gt; <span class="hljs-number">8</span>;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ipList.<span class="hljs-built_in">begin</span>(), ipList.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>) res += ipList[i];<br>        <span class="hljs-keyword">else</span> res += ipList[i] + <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 递减累和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addArr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        res += n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*小q挖币</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qCoin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">1</span>);<br>    dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">2</span>);<br>    dp[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">3</span>);<br>    dp[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">4</span>);<br>    dp[<span class="hljs-number">6</span>] = <span class="hljs-number">6</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> dp[n];<br>    <span class="hljs-comment">// 周期循环的思想</span><br>    <span class="hljs-type">int</span> times = n / <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> tail = n % <span class="hljs-number">6</span>;<br>dp[times*<span class="hljs-number">6</span>] = times*dp[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">if</span>(tail==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[times*<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tail;++i) &#123;<br>        dp[times*<span class="hljs-number">6</span>+i] = dp[times*<span class="hljs-number">6</span>] + dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;16、Q1：整数与ip地址的转换；Q2：小q第一天挖11币，第二天比前一天少一个币，以此类推，但休息一天又可以挖到11币,问第n天能挖多少币&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>C++11知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/15/cpp11%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/15/cpp11%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-15T10:29:13.000Z</published>
    <updated>2023-03-15T10:54:38.534Z</updated>
    
    <content type="html"><![CDATA[<p>1、c++11的一些特性</p><p><em><strong>类型推导</strong></em>——C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p><p>其中有两个关键字：</p><ul><li><strong>auto</strong>：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">auto a = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> boost::typeindex::type_id_with_cur&lt;decltype(a)&gt;().pretty_name() = int<br></code></pre></td></tr></table></figure><ul><li><strong>decltype</strong>：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;i = <span class="hljs-number">1</span>;<span class="hljs-keyword">decltype</span>(i) b = <span class="hljs-number">2</span>; <span class="hljs-comment">// boost::typeindex::type_id_with_cur&lt;decltype(b)&gt;().pretty_name() = const int&amp;</span><br></code></pre></td></tr></table></figure><p><em><strong>左值右值</strong></em>——复制构造和移动构造，空间占用堆内存是否拷贝，如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。</p><p>std::move函数可以将左值转换为右值引用，减少了不必要的拷贝操作。</p><p><code>std::string str = &quot;Hello&quot;;std::vector&lt;string&gt; vec;vec.push_back(std::move(str)); // str==&quot;&quot;;</code><br>尽可能地<em><strong>列表初始化</strong></em></p><p><em><strong>std::function和lambda表达式</strong></em></p><p>可调用对象满足一点即可：</p><ul><li><p>是一个函数指针</p></li><li><p>是一个具有operator()成员函数的类对象(传说中的仿函数)，lambda表达式</p></li><li><p>是一个可被转换为函数指针的类对象</p></li><li><p>是一个类成员(函数)指针</p></li><li><p>bind表达式或其它函数对象</p></li></ul><p>function是上面这种可调用对象的封装器，可以把std::function看做一个函数对象，用于表示函数这个抽象概念。std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空，调用空的std::function的目标会抛出std::bad_function_call异常。</p><p>lambda表达式可以说是c++11引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> f1 = [=]()&#123; <span class="hljs-keyword">return</span> a; &#125;; <span class="hljs-comment">// 值捕获a</span><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">auto</span> f2 = [=]() &#123; <span class="hljs-keyword">return</span> a++; &#125;; <span class="hljs-comment">// 修改按值捕获的外部变量，error</span><br><span class="hljs-keyword">auto</span> f3 = [=]() <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> a++; &#125;;<br></code></pre></td></tr></table></figure><p><em><strong>default</strong></em>默认构造函数，这就不会让编译器隐式生成默认构造函数</p><p><em><strong>nullptr</strong></em>是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。</p><p><em><strong>final和override</strong></em>，其中final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><p><em><strong>enum class</strong></em>带作用域的枚举代码，使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AColor</span> &#123;<br>    kRed,<br>    kGreen,<br>    kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BColor</span> &#123;<br>    kWhite,<br>    kBlack,<br>    kYellow<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">AColorc</span> &#123;<br>    kRed,<br>    kGreen,<br>    kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">BColorc</span> &#123;<br>    kWhite,<br>    kBlack,<br>    kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (kRed == kWhite) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (AColorc::kRed == BColorc::kWhite) &#123; <span class="hljs-comment">// 编译失败</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>constexpr</strong></em>用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：</p><p>两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、c++11的一些特性&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;类型推导&lt;/strong&gt;&lt;/em&gt;——C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。&lt;/p&gt;
&lt;p&gt;其中有两个关键字：&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>thoughts</title>
    <link href="http://precipitation0224.github.io/2023/03/15/thoughts/"/>
    <id>http://precipitation0224.github.io/2023/03/15/thoughts/</id>
    <published>2023-03-14T20:20:44.000Z</published>
    <updated>2023-03-14T12:21:18.949Z</updated>
    
    <content type="html"><![CDATA[<p>修bug真的是好烦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修bug真的是好烦！&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="my os" scheme="http://precipitation0224.github.io/tags/my-os/"/>
    
  </entry>
  
  <entry>
    <title>Tcpip卷一协议知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:07:10.000Z</published>
    <updated>2023-03-14T08:03:56.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一章：概述</strong></p><p>1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层</p><p>2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，port用于tcp和udp的逻辑号码</p><p><strong>第二章：数据链路层</strong></p><p>1、ARP：ip地址转mac地址，以太网（网卡）协议，最大传输单元MTU，IP数据报过大则分片，环回接口（loopback）即本地</p><p><strong>第三章：IP协议、ARP协议</strong></p><p>1、IP协议作为核心，但其不可靠，可靠交托于上层协议，IP协议头包含，版本、首部长度、服务类型、字节数、标识、标志、片偏移、生存时间（tracerounter工作原理）、协议、首部校验和、源IP地址、目的IP地址、其他选项</p><p>2、子网寻址，IP地址等价于网络号+（子网号+）主机号，通过高速缓存表自查再广播，有则响应</p><p><strong>第四章：ICMP协议、ping和Traceroute</strong></p><p>1、IP不保证可靠，ICMP保证送达；some errors：主机不可达，路由不可达，给主机一个改错的机会，ICMP数据包由8bit错误类型，8bit代码和16bit校验和组成</p><p>2、ping声纳定位，类型码为0发出请求，收到请求的主机用类型码8回复，traceroute，解决ping的ip头限制问题，问udp是否到达主机，目的主机说端口不可达（port num&gt;30000）</p><p><strong>第五章：IP选路、动态选路</strong></p><p>1、5种flags，路由可用U，路由到网关G，路由到主机H，创建重定向报文D，路由被重定向报文修改M</p><p>2、动态选路协议，核心路由表（合适的网络），选择路由的协议，内部网关协议（IGP），OSPF取代RIP，两者都为代表</p><p>3、unix系统上通常有路由守护程序routed，另一个叫gate，RIP定义域RFC1058中，作为UDP的上层协议，以hop为计数器，即走过多少路由</p><p>4、对已知路由器发送rip请求报文，其他路由完整表；收到请求交表；接受回应并更新自己的路由表，使用小hop数；30s更新路由表，其弊端是无子网的概念，环路危险，hop限制网络大小</p><p><strong>第六章：UDP协议</strong></p><p>1、UDP协议头，包含了端口号、检验和、UDP长度</p><p>2、UDP和TCP设计伪首部来计算检验和，两次检查是否到达目的地，IP分片是根据MTU来，UDP发送前先要发送ARP以获得目的主机的MAC地址，UDP第一个分片发出ARP，分片等待</p><p>3、接受主机会给授予主机发ICMP处理不下报文，服务器泛化广播能力，服务器根据客户IP地址和端口号判断数据包合法不，并且服务器应该限制本地IP地址，依次绑定自己到网络接口的某一个端口上</p><p><strong>第七章：广播和多播、IGMP协议</strong></p><p>1、数据链路层数据头里具体的目的地址，以太网是MAC地址，路由即可定向单播，多播组是D类</p><p>2、广播和多播性质类似，路由器将数据放到局域网里，网卡对这些数据进行过滤，主机运行IP进程时，给网卡绑定虚拟多播IP地址，网卡让其进来从而实现通信，主机内核轻松，网卡忙点</p><p>3、IGMP让其他需要知道自己处于哪个多播组的主机和路由器知道自己的状态，多播组主机，多播组路由器，接受主机通过网卡过滤，路由器决定几个多播组</p><p><strong>第八章：DNS域名系统</strong></p><p>1、一个独立管理的DNS子树叫做zone，如二级域名，本身作为一个分布式数据库，转发至根服务器，自上而下转发查询，自带高速缓存，方便下次查询</p><p>2、DNS采取域名对应表查询，in-addr.arpa，大多数查询时UDP查询，TCP查询仅当查询数据产生了数据阶段，运用TCP的分片能力进行数据传输，辅服务器要拿主服务器的zone信息的时候</p><p><strong>第九章：TCP协议概述</strong></p><p>1、TCP面向连接，有ICMP差错检测报文，应用数据被分割成TCP满意的块，数据报长度保持不变，TCP发出段，启动一个定时器，超时重传</p><p>2、TCP保持首部和数据的校验和，记端到端的校验和，检测数据在传输过程的变化，IP数据报，TCP数据报都可能失序，TCP需要重排后交付应用层</p><p>3、TCP流量控制，防止接收端缓冲区溢出，可靠不得到不停止发送，TCP首部含更多信息</p><p><strong>第十章：TCP连接的建立与中止</strong></p><p>1、客户端向服务器申请开启某一端口，用于SYN段等于1的TCP报文，服务器端发回一个ACK报文，TCP全双工可以同时发送和接收，三次握手四次挥手的解释</p><p>2、建立连接确认对方的最大报文长度（MSS）以便于通信，SYN的长度是MTU减去固定IP首部和TCP首部的长度</p><p>3、客户端状态流程：CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</p><p>4、服务器状态流程：CLOSED-&gt;LISTEN-&gt;SYN-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED</p><p>5、MSL平静时间概念，应用程序无法使用插口，半关闭状态，应用程序有接受数据的能力，但无法发送数据，等应用层来决定关闭这个状态</p><p>6、UDP仅需输入队列，TCP对于每一个连接都要建立独立的进程，以保证对话的独立性，呼入连接请求队列，解释了各种TCP服务器都有一个最大连接数的原因，根据主机IP和端口号进行区分</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676452143517-845e2589-f3cb-427f-93d4-c36417850a25.png" alt="img"><a href="http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png">http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png</a></p><p><strong>第十一章：TCP交互数据流、成块数据流</strong></p><p>1、以TCP协议为基础，建立在之上的协议有telnet、ssh、ftp、http等，根据数据的吞吐量又分为两大类：第一是交互数据类型，如telnet、ssh，做小流量的交换，敲击键盘回显文字，第二是数据成块类型，如ttp，要求TCP尽量运输数据，把数据吞吐量做大，提高效率</p><p>2、TCP交互数据流，就要想办法去降低网络负担，lo接口进行telnet通信，如按键过程，发送按键数据-服务器发送按键数据的ack-服务器端发送回显数据-客户端发送回显数据的ack，流量是40bit+41bit+41bit+40bit</p><p>3、两种策略，捎带ACK的发送方式，数据报不立刻处理，等待主机还有发送给远程主机的TCP数据报，时间一般设为200ms，另一种策略是Nagle算法，如BBS论坛帖子，数据稍等片刻一下就传过来了，TCP缓冲区只有一个TCP数据报，不断收集后来的数据，整合成一个大的数据报，等待响应主机的ACK报文，TCP_NODELAY来关闭此算法</p><p>4、TCP成块数据流，ftp接受延迟，因为其数据多，TCP协议中有16bit表示窗口的大小。发送端连续发送数据尽可能地填满接收端的缓冲区，接收端只需要发送一个ACK就好了，累积特性，减少了发送端和接受端的负担</p><p>5、滑动窗口本质是描述接收端TCP数据报缓冲区大小的数据，发送端以此发送数据，滑动窗口协议的三个术语，窗口合拢，窗口张开，窗口收缩，发送窗口范围里面的数据，窗口的大小通过socket来制定，4096非理想，16384可以使得吞吐量大大增加</p><p>6、数据拥塞，前面的策略用于局域网中，但在广域网中有问题，产生在slip低速链路的数据拥塞问题，TCP的解决方案是发送方确认连接双方的线路的数据最大吞吐量是多少，即拥塞窗口，其原理是TCP发送方发送一个数据报，等待对方的回应，得到回应后将窗口大小加倍，连续发送两个数据报，等到对方回应，再加倍，发送更多的数据报，知道超时报错，发送端就能知道通信双方线路的承载能力，即拥塞窗口的大小，传数据速度慢慢起来的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一章：概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层&lt;/p&gt;
&lt;p&gt;2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>STL设计知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/STL%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/STL%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:06:54.000Z</published>
    <updated>2023-03-14T07:10:20.006Z</updated>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/103223914">https://blog.csdn.net/fengbingchun/article/details/103223914</a></p><ol><li>慎重选择容器类型，序列容器，关联容器，非STL容器，对STL进行分类，连续内存容器(vector、string、deque)和基于节点的容器(list、forward_list)，容器内部的引用计数技术，rope基于引用计数，本身是用可持久化平衡树实现的重型string<img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1677981449440-89bff10a-e505-4057-bc6d-49ae3aad5afa.png" alt="img"></li><li>STL本身是泛化，不写独立于容器类型的代码，数组泛化为以其包含对象类型为参数的容器，函数泛化为以其使用的迭代器类型为参数的算法，将容器隐藏到一个类中，以减少通过类接口与容器相关的信息</li><li>确保容器中的对象拷贝正确高效，对象是其拷贝在容器中，取出对象也是对象的拷贝，存在继承关系时，拷贝会导致剥离，防止子对象特有信息丢失就是使容器包含指针</li><li>调用empty检测size()是否为0</li><li>区间成员函数优先于与之对应的单元素成员函数，用两个迭代器确定成员操作所执行的区间，推荐assign和insert，清楚表达意图，表现更高效率</li><li>视情况使用命名迭代器对象</li><li>容器中包含new指针，在析构前delete掉指针，为避免资源泄漏，必须用引用计数计数形式的智能指针对象代替指针</li><li>切勿创建包含auto_ptr的容器对象，创建后即转移对象的所有权，包含智能指针没问题</li><li>慎用选择删除元素的方法，对于vector、string或deque这样的容器，erase-remove是删除特定值元素的最好办法，list对应list::remove，关联map这样的容器使用erase，判别式加if，遍历容器元素，返回值更新迭代器，关联容器则后缀递增</li><li>分配子的约定和限制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reference link: &lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/103223914&quot;&gt;https://blog.csdn.net/fengbingchun/article/details</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>more-effective-c++知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:06:32.000Z</published>
    <updated>2023-03-14T07:09:55.322Z</updated>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/102990753">https://blog.csdn.net/fengbingchun/article/details/102990753</a></p><ol><li>指针和引用的区别，任何情况下都不能使用指向空值的引用，引用必须初始化</li><li>尽量使用C++风格的类型转换，static_cast、const_cast、dynamic_cast、reinterpret_cast，注意的是dynamic_cast是继承关系向下的类型转换</li><li>不要对数组使用多态，只要不从一个具体类派生出另一个具体类就好</li><li>避免无用的构造缺省函数，数组的raw memory分配可以避免内存的浪费，构造函数初始化对象，行为特性或数字相仿的对象被初始化为空值或不确定的值也是合理的，也有空容器，需要空间来容纳指针，实例化模板，模板的类型参数应该提供一个缺省构造函数</li><li>谨慎定义类型转换函数，有两种函数允许编译器进行隐式类型的转换，单参数构造函数和隐式类型转换运算符，构造函数使用explicit声明，编译器会拒绝为了隐式类型转换而调用构造函数</li><li>自增自减的前缀和后缀形式，处理用户定义的类型时，尽可能地使用前缀increment，只因效率高</li><li>不要重载&amp;&amp;，||和，操作符，解释是C++使用布尔表达式短路求值法，前部分判定后半部分不判了，分为全局重载和类内重载，函数参数地计算顺序不能被控制</li><li>理解不同含义的new和delete，即new operator和operator new的区别，作为内置的操作符，含义不能改变，功能分两部分，第一是分配足够的内存以容纳所需类型的对象，第二是调用构造函数初始化内存中的对象，operator new函数的返回值是void*，返回一个未初始化的指针，未初始化的内存，new用于堆上建立一个对象，分配内存然后定制operator new，再获得指针的内存里建立一个对象使用的是placement new，避免在内存中使用delete操作符</li><li>使用析构函数防止资源泄漏，不只是用于指针上，还可以用在其他资源的分配和释放上，资源应该被封装在一个对象里，智能指针就是基于此</li><li>在构造函数中防止资源泄漏，只有一个对象的构造函数完全运行完毕，对象才会被构造，构造函数try catch捕获所有的异常，用unique_ptr对象替代指针成员变量，就可以防止构造函数在异常时发生资源泄漏</li><li>禁止异常信息传递到析构函数外，第一是在异常传递的堆栈stack-unwinding过程，被terminate调用，第二是确保析构函数能完成任务</li><li>理解一个抛出一个异常与传递一个参数或调用一个虚函数之间的差异，程序的控制权最终还会返回到函数的调用处，异常的抛出不会返回到出现异常的地方，抛出的对象应该被复制，catch进行异常匹配有两种类型转换，第一是继承类和基类之间的转换，第二是允许类型指针转变成无类型指针，const void*捕获任意指针异常</li><li>通过引用捕获异常，有四个标准的额异常都不是指向对象的指针，bad_alloc，bad_cast，bad_typeid和bad_exception，分别对应的是不可分配，不可引用，不可操作空指针，unexception异常</li><li>审慎使用异常规格，函数抛出不在异常考虑的范围这样的异常，std::unexcepted调用std::terminate，然后再调用abort，从而避免了std::terminate</li><li>了解异常处理的系统开销，避免使用无用的try块</li><li>牢记80-20准则，即2成代码使用了8成的程序资源，2成代码耗用了8成的运行时间，2成代码使用了8成的内存，2成代码执行8成的磁盘访问，8成维护投入到2成代码上</li><li>考虑使用过lazy evaluation</li><li>分期摊还期望的计算，设计一个数据结构解决频繁运行的计算块，前面的lazy evaluation就是以此提高程序效率</li><li>理解临时对象的来源，未命名的临时对象在两种条件下产生，进行隐式类型转换和函数返回对象时使得函数调用成功</li><li>协助完成返回值优化，有些函数必须返回对象，这是它们的运行方法，C++允许编译器优化不出现的临时对象</li><li>通过重载避免隐式类型转换，重载运算符必须带有一个用户定义类型的参数，没有必要大量重载，除非效率上有相应的提升</li><li>考虑用运算符的赋值形式op&#x3D;来代替其单独形式op，确保operator的赋值形式与一个operator的单独形式存在正常的关系，后者+根据前者+&#x3D;来实现</li><li>考虑变更程序库，不同程序库在效率、可扩展性、移植性、类型安全和其它一些领域上蕴含着不同的设计理念</li><li>理解虚函数、多继承、虚基类和RTTI所需的代码，虚拟函数必须与调用函数的对象的动态类型一致，编译器使用vtbl和vptr，必须为包含虚函数的类留出vtbl空间，看不见的数据称为vptr，被编译器加在对象里，只有编译器知道，虚函数不能内联，内联的含义是指在编译期间用被调用的函数体来代替函数调用的指令，虚函数的虚体现在在运行时才知道调用的是哪一个函数，RTTI(运行时类型识别)能够帮助找到对象和类的有关信息，存储在type_info这个对象里，通过typeid操作符访问一个类的type_info对象</li><li>将构造函数和非成员函数虚拟化，虚拟构造函数返回一个指针，指向调用函数的对象的新拷贝，被派生类重定义的虚拟函数不用必须与基类的虚函数具有一样的返回类型</li><li>限制某个类所能产生的对象数量，阻止建立某个类的对象，方法是将该类的构造函数声明在类的private域中</li><li>要求或禁止在堆中产生对象，禁止用于调用new，利用new操作符总是调用operator new函数这点来达到目的，可声明为private</li><li>灵巧smart指针，使用到模板，应用领域有资源管理和重复代码任务的自动化，auto_ptr已在C++11抛弃，改用unique_ptr替代</li><li>引用计数，即允许多个有相同值的对象共享这个值的实现，两个动机，第一是简化跟踪堆中的对象的过程，一旦对象被new，就要记录对象的拥有者，所有者负责对对象进行delete，通过传递指针型参数将一个对象的所有权传递到另一个对象中，引用计数免除跟踪对象的所有权，第二是基于对象有相同的值，存储多次是无聊的，所以考虑让所有对象共享这个值的实现，节省内存</li><li>代理类，可以通过代理类实现二维数组，区分operator[]进行的操作是读还是写，proxy类可以完成三个行为，第一是多维数组，第二是左值右值的区分，第三是隐式类型转换的限制，缺点是proxy本身作为一个临时对象，必须被构造和析构</li><li>让函数根据一个以上的对象来决定怎么虚拟</li><li>在未来时态下开发程序，需要考虑到代码的可复用性、可维护性、健壮性以及环境移植性</li><li>将非尾端类设计为抽象类</li><li>如何在同一程序中混合使用C++和C，函数重载是C++的特性，extern C看作是声明这个函数是C写的一样进行调用，静态初始化，静态类对象和定义在全局的、命名空间中的文件体中的类对象构造函数通常在main被执行前被调用，动态内存分配建立在堆上，在同一程序下混合两者，有以下的指导原则：一是确保C++和C编译器产生兼容的obj文件，二是函数声明为extern C，三是只要可能就C++写main，四是勇敢delete释放new分配的内存，用free释放malloc分配的内存，五是将语言传递的东西限制在C编译的数据结构范围内</li><li>让自己习惯使用标准C++语言</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reference link: &lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/102990753&quot;&gt;https://blog.csdn.net/fengbingchun/article/details</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>effective-c++知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:04:52.000Z</published>
    <updated>2023-03-14T07:09:02.426Z</updated>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/qq_43763344/article/details/95447843">https://blog.csdn.net/qq_43763344/article/details/95447843</a></p><p><a href="https://blog.csdn.net/qq_43763344/article/details/107182731?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_43763344/article/details/107182731?spm=1001.2014.3001.5502</a></p><ol><li>将C++视为包含四个部分的语言联邦，第一是C，即区块、语句、预处理器、内置数据类型、数组和指针都来自于C，第二是Object-Oriented C++，即包含类、封装、继承、多态和动态绑定等，第三是Template C++，即C++泛型编程的部分，第四是STL，即包含容器、迭代器、算法和函数对象等</li><li>尽量以const, enum, inline替换#define，即以编译器替代预处理器（宏），define无作用域，inline函数代替define定义的函数式的宏，const成员声明为static成员，以保证const成员只有一份实体，对于形式函数的宏定义，使用inline函数替换#define</li><li>const可以被施加于任何作用域内的对象、函数对象、函数返回类型、成员函数本体，non-const版本调用const版本可以避免代码重复</li><li>对象在被使用前已被初始化，初始化列表，且成员变量的顺序应和类内声明顺序一致，用local static对象替换non-local static对象以避免跨编译单元初始化次序带来的问题</li><li>编译器默认为类创建default ctor，copy ctor，copy assignment、dtor</li><li>为了避免编译器自动生成函数，可以将相应的成员函数声明为private并且不予实现，表示拒绝</li><li>具有多态性的基类应该声明一个virtual dtor，如若类的设计目的不是作为基类使用，也不是多态，则不声明为virtual dtor</li><li>析构函数不可抛出异常，只能catch异常，以此结束程序，如若客户端对抛出的异常做出反应，这个类应该提供一个普通函数执行操作，而非系统狗函数中</li><li>绝不再ctor和dtor中调用virtual函数，子类先构造基类的ctor，此时类型式基类，当基类构造完成时，构造子类时，对象的类型才会变成子类，析构先子类后基类，类似栈模型，因此再构造和析构期间不调用virtual函数，因为这类调用的虚函数不会下降到派生类中的版本，永远是基类版本</li><li>用operator&#x3D;返回一个*this的引用，重载赋值运算符应该返回一个指向自身所属类的引用</li><li>重载赋值运算符保证对象自我赋值时operator&#x3D;有良好行为，确定任何函数操作以上一个对象，多个对象是同一对象时，也是正确的</li><li>copying函数确保复制对象内的所有成员变量和所有的基类成分，不要用copying函数实现另一个copying函数，应该放在第三个函数中，由两个copying函数共同调用，资源一旦用完就要归还</li><li>为防止资源泄漏，用RAII对象，在构造函数中获得资源，析构函数中释放资源，shared_ptr和auto_ptr作为两个常被使用的RAII智能指针</li><li>复制对象，复制资源，复制RAII对象必须一并复制它管理的资源，资源的copying行为决定RAII对象的copying行为，普遍常见的RAII类的copying行为是，阻止拷贝、使用引用计数法</li><li>API往往访问原始资源，每个RAII类都应该提供一个取得资源管理的方法，对原始资源的访问可能通过显示转换或隐式转换，显示转换比较安全，隐式转换对客户比较方便</li><li>new中使用到[]，相应的delete也应使用到[]，若没有使用，则相应也不使用</li><li>以独立的语句将newd对象置入智能指针，原始指针送进shared_ptr，也可能产生内存泄漏的问题，参数压栈的顺序不一样</li><li>接口正确使用，不被误用，factory函数可以返回一个指针指向Investment继承体系动态分配的对象，即Investment *createInvestment()，强迫客户返回值存在shared_ptr上，这样就不会释放资源</li><li>设计class考虑的问题，新type创建也要想如何销毁，初始化和赋值，值传递和引用传递，如何继承，隐式显示的转换，操作符以及member函数，type的未声明接口，对效率，异常安全，资源的影响</li><li>构造拷贝的时候，参数用const类型的引用，避免构造带来的开销，对象切割问题存在于基类对象或引用中</li><li>虽然引用效率高，但不要传递一些指向其实并不存在的对象，引用必须知道它引用的是谁，对象被释放，实体失效，栈中创建，函数结束即销毁失效，堆中创建，之心delete后失效，就算用static绑定对象也不行，无锁保护，两次函数改变的是调用值，返回的是reference，调用端看到的永远是现值</li><li>成员变量封装为private</li><li>非成员函数替代成员函数，提高封装性，跨文件扩展，如STL组件</li><li>成员函数第一个指针都是this指针，无法进行类型转换，非成员函数就不存在这个问题，传递参数发现类型不同，则隐式转换</li><li>不抛出异常的swap函数，使用指向对象的指针，通过交换指针来实现数据的交换，即不使用拷贝</li><li>尽可能延后变量定义的时间，如变量带构造函数和析构函数，本身受构造函数和析构函数的成本</li><li>尽量少做转型动作，常量性移除const_cast，向下安全转型dynamic_cast，低级转型reinterpret_cast，隐式转换static_cast，存在非对象调用类函数，而是对象基类的副本去调用</li><li>类返回对象成员的引用，客户端可以随意修改，这个问题的解决办法是在成员函数前面加const限制修改就行，但依然返回的是内部对象，即空悬、虚吊的情况</li><li>异常安全是一个函数内抛出异常，要做到不泄露资源、不破坏数据，对于互斥器使用对象去管理资源，对象释放的时候自动调用析构函数，可以使用智能指针去管理资源，就不用手动delete</li><li>内联函数可以避免函数调用的开销，在函数编译期间对函数调用进行替换为函数本体，以空间换取时间的策略，提供一种策略给编译器，看代码的复杂程度和编译器环境等，指针调用要知道函数地址，虚函数和构造函数不可设置为内联</li><li>文件间编译依赖关系降到最低，即声明和定义分开实现，尽可能让头文件自己满足，实在不行就与其他文件相关联</li><li>使用public继承出is-a的关系，继承者功能的丢失，需要单独写一个类</li><li>派生类的函数与基类同名会被覆盖，域名作用符来界定</li><li>区分接口继承和实现继承，非虚函数本质是不想在子类实现不同行为，状态保持不变</li><li>策略模式值得是定义一系列的算法，在运行的时候，根据对象不同，互相替换调用，这样的变化依赖稳定，稳定依赖于抽象，对扩展开放，对修改封闭</li><li>non-virtual都是静态绑定，函数编译时就应知道调用哪个函数了，根据指针类型来决定，而不是对象化类型决定调用哪个函数</li><li>不重新定义继承而来的缺省参数值，继承参数需要给出指指定</li><li>通过复合模型构造出has -a，复合有很多含义，如内嵌、分层、聚合，即运用于泛型编程中</li><li>private继承关系表明基类和子类没有任何观念上的表示，子类只想用基类良好的特性，private在软件层面上没有实际意义</li><li>多继承关系复杂，菱形继承的歧义性和数据冗余性，指定类来调用哪个函数，数据冗余用虚继承的方法，让子类继承它的虚方法，但会增加大小，速度初始化以及复杂度的成本</li><li>显示接口，实例和所属type，隐式接口用于泛型编程，在编译期间进行推导，接口本身具有多态性，代码复用性高，class和template都支持接口和多态，class接口是显示的，多态是通过虚函数发生在运行期，template接口是隐式的，多态是通过template具现化和函数重载解析发生在编译期</li><li>class和typename本质没区别，但typename定义一个类型的别名，标识嵌套从属类型，避免编译器识别为静态变量，但typename不可以出现在基类列或者成员初值列中内作为基类修饰符</li><li>模板特化，指定typename的类型，编译器可以识别，如果是全特化，那么无参数变化，即typename所有参数都被指定，模板中定义的函数，在模板派生类中是访问不到的，需要加this-&gt;指向基类成员</li><li>避免template的膨胀，建立一个带数值参数的函数，基类只对矩阵元素类型参数化，不对矩阵尺寸参数化，通过定义一个指针指向内存地址来解决基类查看派生类数据的问题</li><li>用成员函数模板接受所有兼容类型，指针继承关系下的隐式转换，引进模板就带来新的问题，类内部声明一个泛化的拷贝构造或者赋值操作符，同时声明正常的拷贝构造和赋值操作符，即内部有个返回智能指针对象原始指针的副本</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1677154916388-a84a97b9-25c5-43d8-8cbb-ac3a2ebf9c7e.png" alt="img"></p><ol><li>做类型转换时，为模板定义非成员函数，编译器要对T做类型推导，对基类构造函数做友元解释，对象被声明则具现化，作为过程一部分，下一步就是有元的声明</li><li>模板萃取技术，对不同的类型有不同的操作，针对一部分类型进行特化，特化的类型和没有特化的类型执行不同的逻辑程序、</li><li>元编程可以将工作由运行期迁移到编译期，以此更早侦测错误和获得更高的执行效率</li><li>new-handler一种程序，即当new出的内存不够需求或无法分配足够内存时，一个错误处理的程序，默认的处理方式是抛出异常</li><li>替换编译器默认的new operator和delete operator，差别对待不同需求，在分配内存之前搞懂软件如何使用内存</li><li>new-handler同样也应能处理0byte的申请</li><li>构造器要由指针指向之前申请的资源，避免内存泄漏</li><li>把warning当作error处理 </li><li>C++标准库，STL、lostreams、locales组成，TRI中添加了智能指针，hash-based容器，正则表达式</li><li>Boost社群，同时提供了TRI组件实现</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reference link: &lt;a href=&quot;https://blog.csdn.net/qq_43763344/article/details/95447843&quot;&gt;https://blog.csdn.net/qq_43763344/article/details/95</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/CSAPP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/CSAPP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:04:29.000Z</published>
    <updated>2023-03-14T07:09:35.281Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一章：计算机系统漫游</strong></p><p>1、从源程序到目标程序的四个阶段：预处理器，编译器，汇编器，链接器，系统硬件组成的四个部分：处理器，主存，I&#x2F;O，总线，逻辑主存即线性数组，物理主存即动态随机存储内存（DRAM），处理器核心是程序计数器，本身是一个字，来存储下一条指令的地址，指令操作围绕主存、寄存器和ALU进行，CPU执行一个目标文件的流程，首先把文件从磁盘读取到寄存器，再放到主存中，然后从主存读取指令开始执行，对数字来说，把数字读到寄存器中，再输出到显示器</p><p>2、L1cache位于CPU上，有几十Mb，比L2快5倍，L2比主存快5<del>10倍，存储器层次结构有7层（寄存器、L1SRAM、L2SRAM、L3SRAM、DRAM、本地磁盘、分布式服务器），把上一层作为下一层的高速缓存，操作系统的三个基本抽象概念，进程、虚拟内存和文件，进程是系统正在执行的程序，某一时刻只执行一个进程，操作系统内核是操作系统常驻主存的部分，负责管理进程的切换，方式是上下文切换，虚拟地址空间从低到高依次是，程序代码和数据、运行时堆、共享库、用户栈、内核虚拟内存，并发交错，并行同时，超线程一个核两个线程，等待执行另一个线程，硬件的交错执行，一个指令需要20多个时钟周期，并行后一秒可以执行2</del>4个指令</p><p>3、ASICⅡ标准表示文本字符，用一个字节的整数值来表示一种字符，所有信息都是由一串比特位表示的，源程序到目标程序的四个步骤，源程序被预处理器处理得到修改了的源程序、再由编译器处理得到汇编程序、汇编程序由汇编器处理得到可重定位的目标程序、最后由链接器链接得到可执行目标程序</p><p>4、编译系统作用，优化程序性能、理解链接时出现的错误、避免安全漏洞，64位系统即总线一次可以传输64位，I&#x2F;O通过一个控制器或适配器与I&#x2F;O总线相连，处理器解释存储在主存中指令的引擎，核心是程序计数器，存储CPU即将执行的下一条指令的地址，也是不断执行PC指向的指令，更新又执行，简单指令操作，加载、存储、操作、跳转</p><p>5、操作系统根据上下文切换来实现并发运行，上下文是跟踪进程运行所需的所有状态信息，存在于PC、寄存器文件、主存等地方，内核不是一个独立的进程，是一系列代码和数据的集合，应用程序如遇操作系统的操作时，将控制权交给内核，用完返回</p><p>6、虚拟内存，机器级别程序将内存视为数组，内存的每个字节由地址来标识，集合作为虚拟地址空间，由程序代码和数据、运行时堆、共享库、用户栈和内核虚拟内存组成，地址由低到高，文件是字节序列</p><p>7、每条指令从开始到结束需要20多个时钟周期，通过指令级别并行，实现每个周期2~4条指令的执行效率，指令集架构是对CPU硬件的抽象，CPU看似一次只执行机器代码程序的一条指令，实则底层硬件并行地执行多条指令</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676597496015-1620e055-baad-4b4e-9ad6-e8bf30da256c.png" alt="img"></p><p><strong>第二章：信息的表示和处理</strong></p><p>1、有确定字长的整数，定义在头文件&lt;stdint.h&gt;中，字长决定了虚拟空间的大小，小端低位低字节、大端高位低字节，浮点运算不可结合，字节作为最小的可寻址的内存单位，数据类型不在机器级程序中，指针的值是某个存储块的第一个字节的虚拟地址，每个程序对象可以视为一个字节块</p><p>2、虚拟地址用一个字来编码，字长决定了虚拟地址空间的大小，32位对应4GB虚拟地址空间，64位对应16EB虚拟地址空间，对于跨越多字节的对象，它的地址是它所用字节中的最小地址，Unicode即UTF-8使用的是4字节表示字符，二进制代码不兼容，一般不移植，程序就是一个字节序列，逻辑右移左端补0，算术右移左端补有效值</p><p>3、IEEE浮点表示，分为三部分，符号S，阶码E，尾数M，根据范围精度做摄入，类型转换可能发生的舍入或溢出</p><p><strong>第三章：程序的机器级表示</strong></p><p>1、编译器基于编程语言的规则、操作系统的惯例、目标机器的指令集生成机器代码，汇编代码是机器代码的文本表示，高级代码的可移植性好，机器级程序的两种抽象，指令集架构、虚拟地址，汇编代码不区分有符号数和无符号数，不区分指针的不同类型，不区分指针和整数</p><p>2、链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置，16个低寄存器的低位部分都可以作为字节、字、双字、四字来单独访问，即al、ax、eax、rax，指令的三种操作数，立即数、寄存器、内存引用，算数和逻辑操作共有四组，加载有效地址、一元操作、二元操作、移位，</p><p>3、根据条件语句、循环语句、分支语句控制执行，测试数据值，使用jump指令跳转，条件码描述了最近的算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，跳转分PC相对跳转、绝对地址编码</p><p><strong>第四章：处理器体系架构</strong></p><p>1、程序中每条指令都会读取或修改处理器状态的某些部分，即程序员可见状态，RF、CC、Stat、DMEM、PC，每条指令需要1~10个字节不等，每条指令的第一个字节表明指示的类型，高4位是code部分，低4位是function部分，指令长度和指令功能相关，有些需要操作数的指令编码就更长一点，SEQ分为取指阶段、译码和写回阶段、执行阶段、访存阶段和更新PC阶段</p><p>2、流水线引入反馈系统，指令间可能产生的问题，数据相关和控制相关，也叫控制冒险和数据冒险，避免冒险的方式有暂停和转发，暂停技术阻塞一组指令在它们所处的阶段，而允许其他指令继续通过流水线，具体来说在译码阶段阻塞，以插入气泡的方式，类似nop指令，即状态不可修改，转发技术是将结果值直接从一个流水阶段传到较早阶段的技术，也叫旁路，总之要尽可能避免流水线冒险</p><p><strong>第五章：优化程序性能</strong></p><p>1、选择适当的算法和数据结构，理解优化编译器的能力和局限性，编写容易优化的代码，任务并行化，多核并行计算，消除不必要的内存引用</p><p>2、循环展开，增加每次迭代计算的元素数量，减少循环的迭代次数，将一组合并运算拆分成两个或更多的部分，最后结合提高性能</p><p><strong>第六章：存储器层次结构</strong></p><p>1、程序本身具有良好的局部性，程序倾向于引用临近于其他最近引用过的数据项对的数据项，分为时间局部性和空间局部性，时间体现在连贯还会出现在未来，空间体现在内存位置上</p><p>2、高速缓存存储器，有SRAM组成，直接制作在CPU芯片内，速度如CPU，程序运行时，CPU部分数据指令会预先成批拷贝在Cache中，当CPU从内存读写数据或指令时，先检查Cache</p><p>3、每个组只有一行的高速缓存称为直接映射高速缓存，包括了组选择、行匹配、字选择、行替换，时间小，但缺失率高，全相联高速缓存是由一个包含所有高速缓存行的组组成的，只适合做小的高速缓存，如虚拟内存系统中的翻译备用缓冲器，该部件用于缓存页表项，组相联高速缓存是上述两种高速缓存的结合体，当数据不命中时，替换组的某一行有以下方法，随机替换算法、先进先出算法、最近最少用LRU、最不经常用LFU，合理运用了栈的结构</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676611912029-19b33bc5-0b2b-495a-b655-c97877ba1b67.png" alt="img"></p><p><strong>第七章：链接</strong></p><p>1、存在于编译、加载和运行三个阶段，链接是由链接器自动执行的，静态链接，重定位目标文件组合形成一个可执行目标文件和命令行参数作为输入，生成完全链接的、可以加载运行的可执行目标文件作为输出，链接器的两个任务，符号解析和重定位</p><p>2、三种目标文件的形式，可重定位目标文件、可执行目标文件、共享目标文件（动态链接库），静态库需要定期维护和更新，调用的静态库中的函数在运行时会被复制到每个运行进程的文本段中，.so文件中包含所有引用该库的可执行目标文件共享里面的代码和数据</p><p>3、链接器可以解析引用，维护可重定位目标文件的集合E，未解析的符号集合U，已定义的符号集合D，库一般放在命令行的结尾，如果双向引用，可以在命令行上重复库</p><p>4、动态链接的应用，分发软件，构建高性能web服务器，linux中dlopen函数允许应用程序在运行时加载和链接共享库，disym函数用来调用共享库的函数</p><p><strong>第八章：异常控制流</strong></p><p>1、通过控制流发生突变来应对各种系统状态，各个上下文切换，发送与程序通过使用陷阱trap或系统调用的ECF形式，向操作系统请求服务，CPU检测事件发生时，通过一张异常表的跳转表，跳至处理特定异常的异常处理程序进行处理</p><p>2、异常处理完成后，会发生以下三种情况中的一种，控制流返回当前指令，控制流返回下一条指令，中止当前被中断的程序，进程上下文由程序运行所需状态组成，包括内存中的代码与数据、栈、寄存器内容、环境变量、文件描述符等</p><p>3、一个逻辑流的执行时间在时间上与另一个流重叠，称为并发流，进程总是出于运行、停止、终止这三种状态，运行在内核模式对的进程可以执行指令集中的任何指令，并且可以访问内存中的任何位置，linux信号提供一种机制，以此通知用户进程发生了这些异常</p><p>4、内核通过更新目的进程上下文的某个状态，发送一个信号给目标进程，进程可以忽略信号，终止或者通过执行信号处理程序来捕获这个信号，每个信号类型都有一个预定义的默认行为，信号不排队，存在条件竞争</p><p><strong>第九章：虚拟内存</strong></p><p>1、虚拟内存的三大能力，第一是将内存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，第二是每个进程提供了一致的地址空间，简化了内存管理，第三是保护进程的地址空间不被其他进程破坏，虚拟内存遍及计算机系统的所有层面，同时虚拟内存赋予程序创建和销毁内存片的能力，内存片映射到磁盘文件的某个部分，应用程序引用指针或动态分配时，都会虚拟内存交互</p><p>2、现代CPU使用虚拟寻址，CPU通过虚拟地址访问主存，实质还是要翻译成物理地址，这个翻译是建立在CPU硬件和操作系统之上的，主存中的每个字节都有一个虚拟地址和一个物理地址</p><p>3、DRAM缓存的组织结构与高速缓存有很大不同，DRAM缓存全相联，任何虚拟页都可以放在任何的物理页中，延时写，页表存放在DRAM中，将虚拟页映射到物理页，翻译时读页表，操作系统负责维护页表的内容</p><p>4、虚拟内存同样也用到了局部性，要比较工作集的大小和DRAM的大小，产生抖动的情况，页面会不断换进换出，不同进程的虚拟页面可能映射到同一个物理页面上，PTE上增加的额外许可位来控制虚拟页面内容的访问，如SUB、READ、WRITE，页表基址指向当前页表，内存管理单元MMU利用虚拟页号来选择适当的PTE，将PTE中的物理页号和虚拟地址中的虚拟页偏移量串连起来得到了对应的物理地址</p><p>5、利用翻译后备缓冲器TLB加速地址翻译，TLB采用了具有较高相联度的组相联方式，多级页表从两个方面降低了内存需求，一级存在PTE才看二级，最常用才在主存中</p><p>6、linux将虚拟内存组织成段的集合，一个区域是已分配的虚拟内存的连续片，不同区域有间隙，linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，初始化这个虚拟内存区域的内容，即内存映射，有两种类型的对象，linux文件系统中的普通文件和匿名文件，交换空间的大小限制了当前运行着的进程了唔够分配的虚拟页面的总数</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676648301084-7eac08a5-2fbf-4e5a-9fa1-6a0a242adca0.png" alt="img"></p><p><strong>第十章：系统级IO</strong></p><p>1、输入&#x2F;输出是在主存和外部设备之间复制数据的过程，作为处理文件的接口，步骤有打开文件，即标准输入，标准输出，标准错误、关闭文件、读文件、写文件和改变当前的文件位置</p><p>2、设计缓冲区避免字节陷入内核，使用rio家族函数，描述符缓冲区的联系，文件元数据的读入，是通过stat和fstat函数完成，通过readdir系列函数读取目录的内容，流是对有序列表的抽象，内核使用三个相关的数据结构来表示打开的文件，第一是描述符表，第二是文件表，第三是v-node表，文件中的不同表项可能表示同一文件，多个描述符家具有相同的文件位置意味着它们读取文件的进度会相互影响</p><p>3、linux shell有I&#x2F;O重定向操作符，允许用户将磁盘文件和标准输入联系起来，套接字由文件描述符引用，进程他用过读写套接字描述符来与其他计算机进程通信</p><p>4、输入函数要在fflush清空缓冲区之后再及逆行输出函数，同样输出函数要到了文件描述符之后才能接输入函数</p><p><strong>第十一章：网络编程</strong></p><p>1、网络本身由各种局域网和广域网组成，主机跨过不兼容网络向另一主机发送数据，主机和路由器上的协议，这样的协议就必须有两种基本能力，命名机制和传送机制，封装是互联网思想精髓，客户端服务端基本操作是事务</p><p>2、一个套接字连接一个端点，每个套接字有响应的套接字地址，客户端套接字端口由内核分配，记为临时端口，服务端记为知名端口，套接字对，使用这样的元组(cliaddr:cliport, servaddr:servport)来表示，socket interface本身作为一组函数，与Unix I&#x2F;O结合，以创建网络应用，socket函数创建的描述符对应于主动套接字，listen将sockfd从一个主动套接字转化为一个监听套接字，accept返回一个已连接的描述符，监听描述符作为客户端连接请求的一个端点，被创建一次，并存在于服务器的整个生命周期，已连接描述符是客户端和服务器端之间已经建立起连接的一个端点，存在于服务器为一个客户端服务的过程</p><p>3、阻塞可以发生在accept，等待监听描述符listenfd上的连接请求，同样阻塞也可发生在客户端调用和connect，数据在主机上通过系统调用在进程的虚拟地址空间与内核间传送，数据在网络间传送</p><p><strong>第十二章：并发编程</strong></p><p>1、OS提供了三种基本的构造并发程序的方法，第一是进程，每个逻辑控制流都是一个进程，由内核调度并维护，控制流使用显示的进程间通信机制来实现与其他流的通信，第二是I&#x2F;O多路复用，应用程序在一个进程的上下文显示地调用自己的逻辑流，这种逻辑流会转换为状态机，数据到达文件描述符后，主程序状态转换，第三是线程，是运行在单一进程上下文中的逻辑流，由内核调度</p><p>2、基于进程的并发编程，使用到fork、exec、waitpid等函数，服务器监听监听描述符的连接请求，接受请求后返回给客户端一个已连接的描述符，子进程可获得服务器的描述表的副本，父进程可以关闭已连接的副本，文件描述符指向同一个文件表表项，父进程必须关闭，否则会内存泄漏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一章：计算机系统漫游&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、从源程序到目标程序的四个阶段：预处理器，编译器，汇编器，链接器，系统硬件组成的四个部分：处理器，主存，I&amp;#x2F;O，总线，逻辑主存即线性数组，物理主存即动态随机存储内存（DRAM），处理器核心是</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
</feed>
