<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yummy home</title>
  
  <subtitle>欢迎你来看看我呀</subtitle>
  <link href="http://precipitation0224.github.io/atom.xml" rel="self"/>
  
  <link href="http://precipitation0224.github.io/"/>
  <updated>2023-03-24T05:26:32.119Z</updated>
  <id>http://precipitation0224.github.io/</id>
  
  <author>
    <name>Yummy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LFU</title>
    <link href="http://precipitation0224.github.io/2023/03/14/LFU/"/>
    <id>http://precipitation0224.github.io/2023/03/14/LFU/</id>
    <published>2023-03-13T22:48:08.000Z</published>
    <updated>2023-03-24T05:26:32.119Z</updated>
    
    <content type="html"><![CDATA[<p>LFU缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity), <span class="hljs-built_in">min_freq</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; &#125;<br>        <span class="hljs-keyword">auto</span> it = key_st[key];<br>        <span class="hljs-type">int</span> freq = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it);<br><br>        <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[freq];<br>        <span class="hljs-keyword">auto</span> &amp;&amp;other = freq_st[freq + <span class="hljs-number">1</span>];<br>        other.<span class="hljs-built_in">splice</span>(other.<span class="hljs-built_in">begin</span>(), lst, it);<br><br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it)++; <span class="hljs-comment">// 更新键值的使用频率</span><br>        <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>            freq_st.<span class="hljs-built_in">erase</span>(freq);<br>            <span class="hljs-keyword">if</span> (min_freq == freq) &#123;<br>                min_freq++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*it);<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 测试用例含 capacity == 0</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果键 key 已存在，则变更其值，并更新该 key 对应的 freq</span><br>            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*key_st[key]) = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果键不存在，请插入键值对</span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            <span class="hljs-comment">// 当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项</span><br>            <span class="hljs-comment">// 当两个或更多个键具有相同使用频率时，应该去除 最近最久未使用 的键。</span><br>            <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[min_freq];<br>            key_st.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(lst.<span class="hljs-built_in">back</span>()));<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>                freq_st.<span class="hljs-built_in">erase</span>(min_freq);<br>            &#125;<br>        &#125;<br>        min_freq = <span class="hljs-number">1</span>; <span class="hljs-comment">// 这是可以肯定的</span><br>        freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(key, value, <span class="hljs-number">1</span>);<br>        key_st[key] = freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> min_freq; <span class="hljs-comment">// 用于跟踪使用最少的频率</span><br>    <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Tuple; <span class="hljs-comment">// &lt;key, value, freq&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;&gt; freq_st; <span class="hljs-comment">// 相同使用频率的键值对放入在同一个链表中</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;::iterator&gt; key_st;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LFU缓存&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="http://precipitation0224.github.io/2023/03/14/LRU/"/>
    <id>http://precipitation0224.github.io/2023/03/14/LRU/</id>
    <published>2023-03-13T22:48:03.000Z</published>
    <updated>2023-03-24T05:22:03.118Z</updated>
    
    <content type="html"><![CDATA[<p>LRU缓存机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 快速查询和删除（哈希表）、快速查询最久未使用、删除元素、移动元素（链表）</span><br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> it = st[key];<br><br>        <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>        lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it);<br>        <span class="hljs-keyword">return</span> it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 已经存在，则变更其数据值 value</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">find</span>(key); it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            it-&gt;second-&gt;second = value;<br>            <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>            lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it-&gt;second);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果插入操作会导致关键字数量超过 capacity，则应该先 逐出 最久未使用的关键字。</span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            st.<span class="hljs-built_in">erase</span>(lst.<span class="hljs-built_in">rbegin</span>()-&gt;first);<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不存在，则向缓存中插入该组 key-value</span><br>        lst.<span class="hljs-built_in">emplace_front</span>(key, value);<br>        st[key] = lst.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Pair;<br>    <span class="hljs-type">int</span> capacity;<br>    list&lt;Pair&gt; lst; <span class="hljs-comment">// &lt;key, value&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Pair&gt;::iterator&gt; st; <span class="hljs-comment">// &lt;key, key_value_pair_iterator&gt;</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LRU缓存机制&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浮点数和MD5,Base64</title>
    <link href="http://precipitation0224.github.io/2023/03/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/"/>
    <id>http://precipitation0224.github.io/2023/03/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/</id>
    <published>2023-03-10T18:32:32.000Z</published>
    <updated>2023-03-23T12:11:09.639Z</updated>
    
    <content type="html"><![CDATA[<p>4、浮点数的存储方式</p><ol><li><p>符号位：‘+’存储为0，‘-’存储为1</p></li><li><p>将数字转化成二进制数</p></li><li><p>将二进制数规范化为 1.xxxxxxxx*2^n</p></li><li><p>将n转化为指数（+127） 尾数xxxx后面补零</p></li></ol><p>5、介绍MD5、Base64</p><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。md5运算结果是一个固定长度为128位的二进制数，经过一系列的运算得到32个16进制数。</p><p>Base64是一种使用64基的位置计数法。它使用2的最大次方来代表仅可打印的ASCII字符。这使它可用来作为电子邮件的传输编码。在Base64中的变量使用字符A-Z、a-z和0-9，这样共有62个字符，用来作为开始的64个数字，最后两个用来作为数字的符号在不同的系统中而不同。一些如unencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。</p><p>MD5加密算法是不可逆的，base64加密算法是可逆的；MD5加密算法是不可逆的，base64加密算法是可逆的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;4、浮点数的存储方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;符号位：‘+’存储为0，‘-’存储为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将数字转化成二进制数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将二进制数规范化为 1.xxxxxxxx*2^n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将n转</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>虚函数动态绑定</title>
    <link href="http://precipitation0224.github.io/2023/03/08/virtualpointer/"/>
    <id>http://precipitation0224.github.io/2023/03/08/virtualpointer/</id>
    <published>2023-03-07T20:01:55.000Z</published>
    <updated>2023-03-23T12:10:10.008Z</updated>
    
    <content type="html"><![CDATA[<p>14、虚函数如何实现动态转发，每个类都有虚函数表吗</p><p>虚函数是在某基类中声明为<em><strong>virtual</strong></em>并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。</p><p>函数是通过<strong>虚函数表</strong>来实现的。每一个含有虚函数的类，都会有一个虚函数表用来存放虚函数的地址，同时类会有一个<strong>虚表指针</strong>去指向虚函数表的首地址,<strong>对象的首地址就存放着虚表指针</strong>。</p><p><strong>虚函数表：</strong>要讲清楚动态绑定的流程，首先需要了解清楚类里面虚函数表的定义，虚函数表是记录虚函数入口地址的一串数组（实际是一个函数指针数组），它只存在于定义了虚函数的类里面，这里给出一个例子来展示类中虚函数表的存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//空类的大小为1</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//大小为4，成员变量会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为4，非虚函数不会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为16，定义虚函数会增加类的大小，但是这个增加不是虚函数带来了的，而是指向虚函数表的指针所占的空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//大小为16，从这儿可以看到，类里面的多个虚函数都维护在一个虚函数表里面，只有一个指向虚函数表的指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(C)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(D)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(E)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//实际上，虚函数不占用类对象的存储空间，</span><br><span class="hljs-comment">//所以含有一个以上的虚函数的类对象大小与仅含一个虚函数大小相同</span><br><span class="hljs-comment">//同时，针对每个类，只维护一个【虚函数表（函数指针数组数组）】</span><br><span class="hljs-comment">//用于存放该类中虚函数的地址，每个【含一个及以上虚函数的对象都会含有一个指向该类虚函数表的指针】。</span><br></code></pre></td></tr></table></figure><p><strong>动态绑定虚函数工作原理：</strong> 前面提到，每一个类会为所有虚函数数维护一个虚函数表，并且有一个指针指向这个表的首地址，这个虚函数表记录着所有的虚函数的入口地址。那么在动态绑定时，编译器是如何给基类指针返回一个正确的函数入口地址，这里给出一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> a1;<br>        <span class="hljs-type">int</span> a2;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::display()&quot;</span>&lt;&lt;endl;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::clone()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::init()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> B&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::execute()&quot;</span>&lt;&lt;endl;&#125; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;C::init()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-keyword">override</span><br></code></pre></td></tr></table></figure><p>这里给出A,B,C三个类的内存情况，如下图。可以得出这么几个结论：</p><ol><li>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的</li><li>同名虚函数在基类和派生类中的虚函数表中，索引是一致的，如下图，A,B,C的display的索引都是0</li><li>派生类中，一旦对基类中的虚函数进行了覆盖，那么派生类的虚函数表中响应函数的入口地址会被替换成覆盖后的函数的地址。</li><li>一旦有新的虚函数定义，会加入到当前虚函数表的末端。</li></ol><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><em><strong>reference link</strong></em>: <a href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;14、虚函数如何实现动态转发，每个类都有虚函数表吗&lt;/p&gt;
&lt;p&gt;虚函数是在某基类中声明为&lt;em&gt;&lt;strong&gt;virtual&lt;/strong&gt;&lt;/em&gt;并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。&lt;/p&gt;
&lt;p&gt;函数是通过&lt;strong&gt;虚函数</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>http缺陷，tls和QUIC</title>
    <link href="http://precipitation0224.github.io/2023/03/07/tls/"/>
    <id>http://precipitation0224.github.io/2023/03/07/tls/</id>
    <published>2023-03-06T19:53:04.000Z</published>
    <updated>2023-03-23T12:09:46.219Z</updated>
    
    <content type="html"><![CDATA[<p>10、http安全保证，tls，如何握手</p><p>HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：</p><ol><li>通信使用明文，内容可能被窃听。</li><li>不验证通信方的身份，因此有可能遭到伪装。</li><li>无法验证报文的完整性，所以有可能被篡改。</li><li>传统的HTTP请求过程都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求和响应被黑客拦截，并且里面含有密码等敏感数据的话，会非常危险。</li></ol><p><em><strong>QUIC</strong></em> 协议 (RFC 9000) 旨在提高 Web 性能并减少访问延迟，同时保持通信机密。 一种基本方法是通过将 QUIC 握手与 TLS 1.3 握手集成并将多个 QUIC 数据包合并到一个 UDP 数据报中来减少初始往返时间 (RTT)。</p><p>总的来说，QUIC 相比于 HTTP&#x2F;2.0 来说，具有下面这些优势：</p><ul><li>使用 UDP 协议，不需要三次连接进行握手，而且也会缩短 TLS 建立连接的时间。</li><li>解决了队头阻塞问题</li><li>实现动态可插拔，在应用层实现了拥塞控制算法，可以随时切换。</li><li>报文头和报文体分别进行认证和加密处理，保障安全性。</li><li>连接能够平滑迁移</li></ul><p>连接平滑迁移指的是，你的手机或者移动设备在 4G 信号下和 WiFi 等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;10、http安全保证，tls，如何握手&lt;/p&gt;
&lt;p&gt;HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通信使用明文，内容可能被窃听。&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>string的缺陷和指针选择</title>
    <link href="http://precipitation0224.github.io/2023/03/05/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/"/>
    <id>http://precipitation0224.github.io/2023/03/05/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/</id>
    <published>2023-03-05T13:07:29.000Z</published>
    <updated>2023-03-23T12:08:53.215Z</updated>
    
    <content type="html"><![CDATA[<p>2、std::string的缺陷</p><p>最大的缺点是 std::string 是「字节串」而非「字符串」</p><ol><li>它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；</li><li>不能很好的处理宽字节的字符；</li><li>没有足够多的好用的函数，没有format格式输出，要借助要用stdio.h头文件里的 sprintf 函数。</li></ol><p>3、智能指针和原生指针的开销</p><p><strong>泛型指针：</strong></p><p>泛型指针有多种含义。1) 指void*指针，可以指向任意数据类型，因此具有“泛型”含义。2) 指具有指针特性的泛型数据结构，包含泛型的迭代器、智能指针等。 广义的迭代器是一种不透明指针，能够实现遍历访问操作。通常所说的迭代器是指狭义的迭代器，即基于C++的STL中基于泛型的iterator_traits实现的类的实例。总体来说，泛型指针和迭代器是两个不同的概念，其中的交集则是通常提到的迭代器类。</p><p><strong>原生指针：</strong></p><p>原生指针就是普通指针， 定义类似：类型 <em>变量名（int <em>p）;相反的若是一个类重载了‘</em>’和‘-&gt;’的运算符，能够像指针同样用‘</em>’和‘-&gt;’操做，就不是原生的，如iterator等。说“原生”是指“最简朴最基本的那一种”。因为现在很多东西都抽象化理论化了，所以“以前的那种最简朴最基本的指针”只是一个抽象概念（比如iterator）的表现形式之一。</p><p>c++的原生指针又可以分为普通指针，成员指针，函数指针。</p><p><strong>智能指针：</strong></p><p>智能指针是c++2.0的新特性之一，其最大的特点在于其结合了指针和对象构造析构的优点RAII，使得其在其生存期结束时可以及时释放其所管理的资源（动态内存分配得到的资源）。由于 C++ 语言没有自动内存回收机制，程序员每次得自己处理内存相关问题，但用智能指针便可以有效缓解这类问题。 一般是把指针封装到一个称之为智能指针类中，这个类中另外还封装了一个使用计数器，对指针的复制等操作将导致该计数器的值加1，对指针的delete操作则会减1，值为0时，指针为NULL。下面是智能指针的选择。</p><p>（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括三种：</p><ol><li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li><li>两个对象包含都指向第三个对象的指针；</li><li>STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</li></ol><p>（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2、std::string的缺陷&lt;/p&gt;
&lt;p&gt;最大的缺点是 std::string 是「字节串」而非「字符串」&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>静态库和动态库</title>
    <link href="http://precipitation0224.github.io/2023/03/04/staticlib/"/>
    <id>http://precipitation0224.github.io/2023/03/04/staticlib/</id>
    <published>2023-03-03T20:08:03.000Z</published>
    <updated>2023-03-23T12:08:19.694Z</updated>
    
    <content type="html"><![CDATA[<p>静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；</p><p>linux是.a文件，windows是.lib文件</p><p>制作流程，先通过gcc生成.o文件，再通过ar(<strong>参数选项rcs</strong>)将.o文件打包生成.a文件。</p><p>动态库在运行程序之前还需要配置动态库的加载路径</p><p>linux是.so文件，windows是.dll文件</p><p>通过gcc生成.o文件(<strong>参数选项fpic</strong>)，再通过gcc生成.so文件(<strong>参数选项shared</strong>)。</p><p>静态库和动态库的区别，静态库链接时，静态库中的代码会打包到可执行程序中，编译时加载，发布程序无需提供静态库，移植方便，消耗内存，更新部署复杂；动态库链接时，动态库代码不会打包到可执行程序中，运行时加载，发布程序时要提供动态库，内存占用小，更新部署发布简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；&lt;/p&gt;
&lt;p&gt;linux是.a文件，windows是.lib文件&lt;/p&gt;
&lt;p&gt;制作流程，先通过gcc生成.o文件，再通过ar(&lt;strong&gt;参数选项rcs&lt;/strong&gt;)将.o文件打包生成</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>预防sql注入</title>
    <link href="http://precipitation0224.github.io/2023/03/02/sql/"/>
    <id>http://precipitation0224.github.io/2023/03/02/sql/</id>
    <published>2023-03-02T10:35:06.000Z</published>
    <updated>2023-03-23T12:08:06.804Z</updated>
    
    <content type="html"><![CDATA[<p>11、避免sql注入</p><p><em><strong>SQL 注入（SQL Injection）</strong></em>，是 Web 开发中最常见的一种安全漏洞。</p><p>可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p><ol><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li><li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li><li>对进入数据库的特殊字符进行转义处理，或编码转换</li><li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li><li>发布前，利用工具进行 SQL 注入检测</li><li>报错信息不要包含 SQL 信息输出到 Web 页面</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11、避免sql注入&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;SQL 注入（SQL Injection）&lt;/strong&gt;&lt;/em&gt;，是 Web 开发中最常见的一种安全漏洞。&lt;/p&gt;
&lt;p&gt;可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>select原理和缺点</title>
    <link href="http://precipitation0224.github.io/2023/03/02/slio/"/>
    <id>http://precipitation0224.github.io/2023/03/02/slio/</id>
    <published>2023-03-01T20:19:33.000Z</published>
    <updated>2023-03-23T12:07:55.479Z</updated>
    
    <content type="html"><![CDATA[<p>select是一种IO多路复用计数，思想如下：</p><ol><li>要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；</li><li>系统调用select()，监听列表中的文件描述符的事件，函数本身是阻塞的，直到文件描述符的一个或多个进行IO时，函数才返回，修改文件描述符的值，0为未检测到事件，1为检测到事件；</li><li>select()返回时，会告诉进程有多少描述符要进行IO操作，遍历列表IO。</li></ol><p>select同时也有缺点</p><ol><li>调用select就要要fd集合从用户态拷贝到内核态，开销很大；</li><li>内核要遍历所有fd；</li><li>支持的文件描述符数量太小，1024bits；</li><li>文件描述符集合不能重用，内核检测到事件就要修改，每次都要重置；</li><li>select只知道有几个fd发生事件，具体哪几个还要遍历集合才知道。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;select是一种IO多路复用计数，思想如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；&lt;/l</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>联邦学习下的多视图聚类</title>
    <link href="http://precipitation0224.github.io/2023/02/27/fedmvc/"/>
    <id>http://precipitation0224.github.io/2023/02/27/fedmvc/</id>
    <published>2023-02-26T19:54:02.000Z</published>
    <updated>2023-03-23T12:05:41.284Z</updated>
    
    <content type="html"><![CDATA[<p>多视图聚类是指利用多个视图或特征描述同一组样本，在不同视图或特征空间中聚类样本。联邦学习是一种分布式机器学习框架，可以实现在数据分散的情况下进行模型训练。</p><p>在联邦学习中，多个设备或数据源共同训练模型，每个设备或数据源负责一部分数据，并通过模型的迭代来学习全局模型，从而避免了数据集中的隐私泄露问题。</p><p>在以联邦学习为背景的多视图聚类中，可以采用以下几种思路：</p><ol><li>基于<strong>模型</strong>的方法：在联邦学习框架下，利用各设备或数据源训练出的模型，对不同视图的数据进行预测，将预测结果作为新的特征，然后进行聚类。这种方法需要每个设备或数据源都具有相同的模型架构和参数设置。</li><li>基于<strong>特征</strong>的方法：在联邦学习框架下，将各设备或数据源的特征向量作为不同视图，在不同视图之间进行特征选择和特征融合，得到新的特征向量，然后进行聚类。</li><li>基于<strong>信息传递</strong>的方法：在联邦学习框架下，将各设备或数据源的聚类结果进行信息传递，利用传递的聚类结果得到新的特征向量，然后进行聚类。这种方法可以利用不同设备或数据源之间的信息交流和知识共享，提高聚类效果。</li><li>基于<strong>深度学习</strong>的方法：在联邦学习框架下，利用深度学习模型对不同视图的数据进行特征提取和特征融合，得到新的特征向量，然后进行聚类。这种方法需要在联邦学习框架下训练深度学习模型，并利用模型进行特征提取和融合。</li></ol><p>总之，基于联邦学习的多视图聚类需要充分利用各设备或数据源之间的信息交流和知识共享，结合不同视图之间的特征和模型，实现更精确和高效的聚类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多视图聚类是指利用多个视图或特征描述同一组样本，在不同视图或特征空间中聚类样本。联邦学习是一种分布式机器学习框架，可以实现在数据分散的情况下进行模型训练。&lt;/p&gt;
&lt;p&gt;在联邦学习中，多个设备或数据源共同训练模型，每个设备或数据源负责一部分数据，并通过模型的迭代来学习全局模</summary>
      
    
    
    
    
    <category term="科研" scheme="http://precipitation0224.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库三个关键性能指标</title>
    <link href="http://precipitation0224.github.io/2023/02/23/mysqleff/"/>
    <id>http://precipitation0224.github.io/2023/02/23/mysqleff/</id>
    <published>2023-02-23T11:00:41.000Z</published>
    <updated>2023-03-23T12:07:28.604Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库三个关键性能指标</p><p><em><strong>TPS</strong></em></p><p>Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。</p><p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问。(业务TPS &#x3D; CAPS × 每个呼叫平均TPS)</p><p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p><p><em><strong>QPS</strong></em></p><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><p>对应fetches&#x2F;sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p><em><strong>IOPS</strong></em></p><p>IOPS (Input&#x2F;Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I&#x2F;O请求数量，一般以每秒处理的I&#x2F;O请求数量为单位，I&#x2F;O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(Online Transaction Processing)，IOPS是关键衡量指标。另一个重要指标是数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL数据库三个关键性能指标&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;TPS&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。&lt;/p&gt;
&lt;p&gt;TPS包括一条消息入和一条消息出，加</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://precipitation0224.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tcpip卷一协议知识总结</title>
    <link href="http://precipitation0224.github.io/2023/02/19/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/02/19/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-19T15:07:10.000Z</published>
    <updated>2023-03-23T12:09:09.544Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一章：概述</strong></p><p>1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层</p><p>2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，port用于tcp和udp的逻辑号码</p><p><strong>第二章：数据链路层</strong></p><p>1、ARP：ip地址转mac地址，以太网（网卡）协议，最大传输单元MTU，IP数据报过大则分片，环回接口（loopback）即本地</p><p><strong>第三章：IP协议、ARP协议</strong></p><p>1、IP协议作为核心，但其不可靠，可靠交托于上层协议，IP协议头包含，版本、首部长度、服务类型、字节数、标识、标志、片偏移、生存时间（tracerounter工作原理）、协议、首部校验和、源IP地址、目的IP地址、其他选项</p><p>2、子网寻址，IP地址等价于网络号+（子网号+）主机号，通过高速缓存表自查再广播，有则响应</p><p><strong>第四章：ICMP协议、ping和Traceroute</strong></p><p>1、IP不保证可靠，ICMP保证送达；some errors：主机不可达，路由不可达，给主机一个改错的机会，ICMP数据包由8bit错误类型，8bit代码和16bit校验和组成</p><p>2、ping声纳定位，类型码为0发出请求，收到请求的主机用类型码8回复，traceroute，解决ping的ip头限制问题，问udp是否到达主机，目的主机说端口不可达（port num&gt;30000）</p><p><strong>第五章：IP选路、动态选路</strong></p><p>1、5种flags，路由可用U，路由到网关G，路由到主机H，创建重定向报文D，路由被重定向报文修改M</p><p>2、动态选路协议，核心路由表（合适的网络），选择路由的协议，内部网关协议（IGP），OSPF取代RIP，两者都为代表</p><p>3、unix系统上通常有路由守护程序routed，另一个叫gate，RIP定义域RFC1058中，作为UDP的上层协议，以hop为计数器，即走过多少路由</p><p>4、对已知路由器发送rip请求报文，其他路由完整表；收到请求交表；接受回应并更新自己的路由表，使用小hop数；30s更新路由表，其弊端是无子网的概念，环路危险，hop限制网络大小</p><p><strong>第六章：UDP协议</strong></p><p>1、UDP协议头，包含了端口号、检验和、UDP长度</p><p>2、UDP和TCP设计伪首部来计算检验和，两次检查是否到达目的地，IP分片是根据MTU来，UDP发送前先要发送ARP以获得目的主机的MAC地址，UDP第一个分片发出ARP，分片等待</p><p>3、接受主机会给授予主机发ICMP处理不下报文，服务器泛化广播能力，服务器根据客户IP地址和端口号判断数据包合法不，并且服务器应该限制本地IP地址，依次绑定自己到网络接口的某一个端口上</p><p><strong>第七章：广播和多播、IGMP协议</strong></p><p>1、数据链路层数据头里具体的目的地址，以太网是MAC地址，路由即可定向单播，多播组是D类</p><p>2、广播和多播性质类似，路由器将数据放到局域网里，网卡对这些数据进行过滤，主机运行IP进程时，给网卡绑定虚拟多播IP地址，网卡让其进来从而实现通信，主机内核轻松，网卡忙点</p><p>3、IGMP让其他需要知道自己处于哪个多播组的主机和路由器知道自己的状态，多播组主机，多播组路由器，接受主机通过网卡过滤，路由器决定几个多播组</p><p><strong>第八章：DNS域名系统</strong></p><p>1、一个独立管理的DNS子树叫做zone，如二级域名，本身作为一个分布式数据库，转发至根服务器，自上而下转发查询，自带高速缓存，方便下次查询</p><p>2、DNS采取域名对应表查询，in-addr.arpa，大多数查询时UDP查询，TCP查询仅当查询数据产生了数据阶段，运用TCP的分片能力进行数据传输，辅服务器要拿主服务器的zone信息的时候</p><p><strong>第九章：TCP协议概述</strong></p><p>1、TCP面向连接，有ICMP差错检测报文，应用数据被分割成TCP满意的块，数据报长度保持不变，TCP发出段，启动一个定时器，超时重传</p><p>2、TCP保持首部和数据的校验和，记端到端的校验和，检测数据在传输过程的变化，IP数据报，TCP数据报都可能失序，TCP需要重排后交付应用层</p><p>3、TCP流量控制，防止接收端缓冲区溢出，可靠不得到不停止发送，TCP首部含更多信息</p><p><strong>第十章：TCP连接的建立与中止</strong></p><p>1、客户端向服务器申请开启某一端口，用于SYN段等于1的TCP报文，服务器端发回一个ACK报文，TCP全双工可以同时发送和接收，三次握手四次挥手的解释</p><p>2、建立连接确认对方的最大报文长度（MSS）以便于通信，SYN的长度是MTU减去固定IP首部和TCP首部的长度</p><p>3、客户端状态流程：CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</p><p>4、服务器状态流程：CLOSED-&gt;LISTEN-&gt;SYN-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED</p><p>5、MSL平静时间概念，应用程序无法使用插口，半关闭状态，应用程序有接受数据的能力，但无法发送数据，等应用层来决定关闭这个状态</p><p>6、UDP仅需输入队列，TCP对于每一个连接都要建立独立的进程，以保证对话的独立性，呼入连接请求队列，解释了各种TCP服务器都有一个最大连接数的原因，根据主机IP和端口号进行区分</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676452143517-845e2589-f3cb-427f-93d4-c36417850a25.png" alt="img"><a href="http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png">http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png</a></p><p><strong>第十一章：TCP交互数据流、成块数据流</strong></p><p>1、以TCP协议为基础，建立在之上的协议有telnet、ssh、ftp、http等，根据数据的吞吐量又分为两大类：第一是交互数据类型，如telnet、ssh，做小流量的交换，敲击键盘回显文字，第二是数据成块类型，如ttp，要求TCP尽量运输数据，把数据吞吐量做大，提高效率</p><p>2、TCP交互数据流，就要想办法去降低网络负担，lo接口进行telnet通信，如按键过程，发送按键数据-服务器发送按键数据的ack-服务器端发送回显数据-客户端发送回显数据的ack，流量是40bit+41bit+41bit+40bit</p><p>3、两种策略，捎带ACK的发送方式，数据报不立刻处理，等待主机还有发送给远程主机的TCP数据报，时间一般设为200ms，另一种策略是Nagle算法，如BBS论坛帖子，数据稍等片刻一下就传过来了，TCP缓冲区只有一个TCP数据报，不断收集后来的数据，整合成一个大的数据报，等待响应主机的ACK报文，TCP_NODELAY来关闭此算法</p><p>4、TCP成块数据流，ftp接受延迟，因为其数据多，TCP协议中有16bit表示窗口的大小。发送端连续发送数据尽可能地填满接收端的缓冲区，接收端只需要发送一个ACK就好了，累积特性，减少了发送端和接受端的负担</p><p>5、滑动窗口本质是描述接收端TCP数据报缓冲区大小的数据，发送端以此发送数据，滑动窗口协议的三个术语，窗口合拢，窗口张开，窗口收缩，发送窗口范围里面的数据，窗口的大小通过socket来制定，4096非理想，16384可以使得吞吐量大大增加</p><p>6、数据拥塞，前面的策略用于局域网中，但在广域网中有问题，产生在slip低速链路的数据拥塞问题，TCP的解决方案是发送方确认连接双方的线路的数据最大吞吐量是多少，即拥塞窗口，其原理是TCP发送方发送一个数据报，等待对方的回应，得到回应后将窗口大小加倍，连续发送两个数据报，等到对方回应，再加倍，发送更多的数据报，知道超时报错，发送端就能知道通信双方线路的承载能力，即拥塞窗口的大小，传数据速度慢慢起来的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一章：概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层&lt;/p&gt;
&lt;p&gt;2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>more-effective-c++知识总结</title>
    <link href="http://precipitation0224.github.io/2023/02/16/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/02/16/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-16T15:06:32.000Z</published>
    <updated>2023-03-23T12:06:45.059Z</updated>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/102990753">https://blog.csdn.net/fengbingchun/article/details/102990753</a></p><ol><li>指针和引用的区别，任何情况下都不能使用指向空值的引用，引用必须初始化</li><li>尽量使用C++风格的类型转换，static_cast、const_cast、dynamic_cast、reinterpret_cast，注意的是dynamic_cast是继承关系向下的类型转换</li><li>不要对数组使用多态，只要不从一个具体类派生出另一个具体类就好</li><li>避免无用的构造缺省函数，数组的raw memory分配可以避免内存的浪费，构造函数初始化对象，行为特性或数字相仿的对象被初始化为空值或不确定的值也是合理的，也有空容器，需要空间来容纳指针，实例化模板，模板的类型参数应该提供一个缺省构造函数</li><li>谨慎定义类型转换函数，有两种函数允许编译器进行隐式类型的转换，单参数构造函数和隐式类型转换运算符，构造函数使用explicit声明，编译器会拒绝为了隐式类型转换而调用构造函数</li><li>自增自减的前缀和后缀形式，处理用户定义的类型时，尽可能地使用前缀increment，只因效率高</li><li>不要重载&amp;&amp;，||和，操作符，解释是C++使用布尔表达式短路求值法，前部分判定后半部分不判了，分为全局重载和类内重载，函数参数地计算顺序不能被控制</li><li>理解不同含义的new和delete，即new operator和operator new的区别，作为内置的操作符，含义不能改变，功能分两部分，第一是分配足够的内存以容纳所需类型的对象，第二是调用构造函数初始化内存中的对象，operator new函数的返回值是void*，返回一个未初始化的指针，未初始化的内存，new用于堆上建立一个对象，分配内存然后定制operator new，再获得指针的内存里建立一个对象使用的是placement new，避免在内存中使用delete操作符</li><li>使用析构函数防止资源泄漏，不只是用于指针上，还可以用在其他资源的分配和释放上，资源应该被封装在一个对象里，智能指针就是基于此</li><li>在构造函数中防止资源泄漏，只有一个对象的构造函数完全运行完毕，对象才会被构造，构造函数try catch捕获所有的异常，用unique_ptr对象替代指针成员变量，就可以防止构造函数在异常时发生资源泄漏</li><li>禁止异常信息传递到析构函数外，第一是在异常传递的堆栈stack-unwinding过程，被terminate调用，第二是确保析构函数能完成任务</li><li>理解一个抛出一个异常与传递一个参数或调用一个虚函数之间的差异，程序的控制权最终还会返回到函数的调用处，异常的抛出不会返回到出现异常的地方，抛出的对象应该被复制，catch进行异常匹配有两种类型转换，第一是继承类和基类之间的转换，第二是允许类型指针转变成无类型指针，const void*捕获任意指针异常</li><li>通过引用捕获异常，有四个标准的额异常都不是指向对象的指针，bad_alloc，bad_cast，bad_typeid和bad_exception，分别对应的是不可分配，不可引用，不可操作空指针，unexception异常</li><li>审慎使用异常规格，函数抛出不在异常考虑的范围这样的异常，std::unexcepted调用std::terminate，然后再调用abort，从而避免了std::terminate</li><li>了解异常处理的系统开销，避免使用无用的try块</li><li>牢记80-20准则，即2成代码使用了8成的程序资源，2成代码耗用了8成的运行时间，2成代码使用了8成的内存，2成代码执行8成的磁盘访问，8成维护投入到2成代码上</li><li>考虑使用过lazy evaluation</li><li>分期摊还期望的计算，设计一个数据结构解决频繁运行的计算块，前面的lazy evaluation就是以此提高程序效率</li><li>理解临时对象的来源，未命名的临时对象在两种条件下产生，进行隐式类型转换和函数返回对象时使得函数调用成功</li><li>协助完成返回值优化，有些函数必须返回对象，这是它们的运行方法，C++允许编译器优化不出现的临时对象</li><li>通过重载避免隐式类型转换，重载运算符必须带有一个用户定义类型的参数，没有必要大量重载，除非效率上有相应的提升</li><li>考虑用运算符的赋值形式op&#x3D;来代替其单独形式op，确保operator的赋值形式与一个operator的单独形式存在正常的关系，后者+根据前者+&#x3D;来实现</li><li>考虑变更程序库，不同程序库在效率、可扩展性、移植性、类型安全和其它一些领域上蕴含着不同的设计理念</li><li>理解虚函数、多继承、虚基类和RTTI所需的代码，虚拟函数必须与调用函数的对象的动态类型一致，编译器使用vtbl和vptr，必须为包含虚函数的类留出vtbl空间，看不见的数据称为vptr，被编译器加在对象里，只有编译器知道，虚函数不能内联，内联的含义是指在编译期间用被调用的函数体来代替函数调用的指令，虚函数的虚体现在在运行时才知道调用的是哪一个函数，RTTI(运行时类型识别)能够帮助找到对象和类的有关信息，存储在type_info这个对象里，通过typeid操作符访问一个类的type_info对象</li><li>将构造函数和非成员函数虚拟化，虚拟构造函数返回一个指针，指向调用函数的对象的新拷贝，被派生类重定义的虚拟函数不用必须与基类的虚函数具有一样的返回类型</li><li>限制某个类所能产生的对象数量，阻止建立某个类的对象，方法是将该类的构造函数声明在类的private域中</li><li>要求或禁止在堆中产生对象，禁止用于调用new，利用new操作符总是调用operator new函数这点来达到目的，可声明为private</li><li>灵巧smart指针，使用到模板，应用领域有资源管理和重复代码任务的自动化，auto_ptr已在C++11抛弃，改用unique_ptr替代</li><li>引用计数，即允许多个有相同值的对象共享这个值的实现，两个动机，第一是简化跟踪堆中的对象的过程，一旦对象被new，就要记录对象的拥有者，所有者负责对对象进行delete，通过传递指针型参数将一个对象的所有权传递到另一个对象中，引用计数免除跟踪对象的所有权，第二是基于对象有相同的值，存储多次是无聊的，所以考虑让所有对象共享这个值的实现，节省内存</li><li>代理类，可以通过代理类实现二维数组，区分operator[]进行的操作是读还是写，proxy类可以完成三个行为，第一是多维数组，第二是左值右值的区分，第三是隐式类型转换的限制，缺点是proxy本身作为一个临时对象，必须被构造和析构</li><li>让函数根据一个以上的对象来决定怎么虚拟</li><li>在未来时态下开发程序，需要考虑到代码的可复用性、可维护性、健壮性以及环境移植性</li><li>将非尾端类设计为抽象类</li><li>如何在同一程序中混合使用C++和C，函数重载是C++的特性，extern C看作是声明这个函数是C写的一样进行调用，静态初始化，静态类对象和定义在全局的、命名空间中的文件体中的类对象构造函数通常在main被执行前被调用，动态内存分配建立在堆上，在同一程序下混合两者，有以下的指导原则：一是确保C++和C编译器产生兼容的obj文件，二是函数声明为extern C，三是只要可能就C++写main，四是勇敢delete释放new分配的内存，用free释放malloc分配的内存，五是将语言传递的东西限制在C编译的数据结构范围内</li><li>让自己习惯使用标准C++语言</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reference link: &lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/102990753&quot;&gt;https://blog.csdn.net/fengbingchun/article/details</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>TCP三握四挥</title>
    <link href="http://precipitation0224.github.io/2023/02/16/tcp34/"/>
    <id>http://precipitation0224.github.io/2023/02/16/tcp34/</id>
    <published>2023-02-15T19:52:12.000Z</published>
    <updated>2023-03-23T12:00:56.089Z</updated>
    
    <content type="html"><![CDATA[<p>TCP 是一种面向连接的可靠传输协议，使用三次握手建立连接可以保证连接的可靠性和安全性。</p><p>具体来说，三次握手的流程如下：</p><ol><li>客户端向服务器发送一个 SYN 报文，其中包含一个随机的初始序号。</li><li>服务器收到 SYN 报文后，向客户端回复一个 SYN+ACK 报文，其中确认客户端的初始序号，并发送一个随机的初始序号。</li><li>客户端收到 SYN+ACK 报文后，向服务器回复一个 ACK 报文，其中确认服务器的初始序号。</li></ol><p>通过三次握手，可以确保双方都已经认可对方的身份，并且双方都已经准备好发送和接收数据。如果使用两次握手，由于没有第三次确认，可能会存在一些潜在的安全问题，例如可能会被攻击者伪造的 SYN 报文欺骗，从而导致连接建立失败或者连接被攻击者劫持。</p><p>至于为什么不是四次握手，是因为建立连接和关闭连接的过程是不一样的。建立连接时需要客户端和服务器都进行确认，因此需要三次握手；而关闭连接时只需要一方发送 FIN 报文，另一方回复 ACK 报文即可，因此只需要四次握手。</p><p>CP 的四次挥手是用来关闭一个 TCP 连接的过程，具体流程如下：</p><ol><li>客户端发送一个 FIN 报文，请求关闭连接。</li><li>服务器收到 FIN 报文后，向客户端回复一个 ACK 报文，确认收到关闭请求。</li><li>服务器发送一个 FIN 报文，请求关闭连接。</li><li>客户端收到 FIN 报文后，向服务器回复一个 ACK 报文，确认收到关闭请求。</li></ol><p>通过四次挥手，双方都可以安全地关闭连接并释放相应的资源。需要注意的是，关闭连接的过程是一个异步的过程，可能会出现一些延迟，因此需要双方都进行确认才能确保连接被彻底关闭。</p><p>需要注意的是，四次挥手中，客户端和服务器各发送了一次 FIN 报文，因此总共需要四次握手才能完成连接的关闭。这也是为什么四次挥手比三次握手复杂的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP 是一种面向连接的可靠传输协议，使用三次握手建立连接可以保证连接的可靠性和安全性。&lt;/p&gt;
&lt;p&gt;具体来说，三次握手的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端向服务器发送一个 SYN 报文，其中包含一个随机的初始序号。&lt;/li&gt;
&lt;li&gt;服务器收到 SYN 报文后</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://precipitation0224.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入地址后到渲染出数据的流程</title>
    <link href="http://precipitation0224.github.io/2023/02/14/xuanran/"/>
    <id>http://precipitation0224.github.io/2023/02/14/xuanran/</id>
    <published>2023-02-13T19:54:35.000Z</published>
    <updated>2023-03-23T12:02:19.930Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览器输入地址后，通常经过以下流程来渲染出数据：</p><ol><li>DNS 解析：浏览器首先会将输入的域名解析为对应的 IP 地址，以便与服务器建立连接。如果 DNS 缓存中已经存在对应的 IP 地址，则可以直接跳过此步骤。</li><li>建立连接：浏览器通过 TCP&#x2F;IP 协议与服务器建立连接，建立连接过程中包括 TCP 的三次握手。</li><li>发送请求：浏览器向服务器发送 HTTP 请求，请求包括请求方法、请求头、请求体等信息。如果请求的资源需要认证，则会在请求头中加入相应的认证信息。</li><li>接收响应：服务器收到请求后会返回 HTTP 响应，响应包括响应头、响应体等信息。</li><li>解析 HTML：浏览器根据响应头中的 content-type 判断响应体的类型，如果是 HTML 页面，则浏览器会解析 HTML，构建 DOM 树和 CSSOM 树，形成渲染树。</li><li>布局和绘制：浏览器根据渲染树中的节点信息，计算节点在页面中的位置和大小等信息，进行布局，然后将节点绘制到屏幕上。</li><li>执行 JavaScript：如果页面中包含 JavaScript 代码，则浏览器会执行相应的 JavaScript 代码，可能会对 DOM 树和 CSSOM 树进行修改，从而触发页面的重新布局和绘制。</li><li>渲染完成：页面的渲染完成后，用户就可以在浏览器中看到相应的页面内容。</li></ol><p>需要注意的是，以上流程是一个简化的描述，实际上在浏览器的渲染过程中，还包括了很多细节和优化，例如缓存、预加载、资源压缩等等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在浏览器输入地址后，通常经过以下流程来渲染出数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 解析：浏览器首先会将输入的域名解析为对应的 IP 地址，以便与服务器建立连接。如果 DNS 缓存中已经存在对应的 IP 地址，则可以直接跳过此步骤。&lt;/li&gt;
&lt;li&gt;建立连接：浏览器通过</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://precipitation0224.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>http 1.0/2/3优化</title>
    <link href="http://precipitation0224.github.io/2023/02/14/1-0-2-3%E4%BC%98%E5%8C%96/"/>
    <id>http://precipitation0224.github.io/2023/02/14/1-0-2-3%E4%BC%98%E5%8C%96/</id>
    <published>2023-02-13T18:43:59.000Z</published>
    <updated>2023-03-23T12:03:32.175Z</updated>
    
    <content type="html"><![CDATA[<p>6、http1.0&#x2F;1 2 3优化</p><p><em><strong>HTTP1.0</strong></em></p><p>1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。</p><p>浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪也每个客户单，也不记录过去的请求（无状态）。</p><p>这种无状态性可以借助<strong>cookie&#x2F;session</strong>机制来做身份认证和状态记录。</p><p>无法复用连接</p><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p><p>队头阻塞（head of line blocking）</p><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p><p><em><strong>HTTP 1.1</strong></em></p><ul><li>长连接，流水线，使用connection:keep-alive使用长连接</li><li>请求管道化</li><li>增加缓存处理（新的字段如cache-control）</li><li>增加Host字段，支持断点传输等</li><li>由于长连接会给服务器造成压力</li></ul><p><em><strong>HTTP 2.0</strong></em></p><ul><li>二进制分帧</li><li>头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小</li><li>多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求</li><li>服务器推送（Sever push）</li></ul><p><em><strong>HTTP 3.0</strong></em></p><ul><li>基于google的QUIC协议，而quic协议是使用udp实现的</li><li>减少了tcp三次握手时间，以及tls握手时间</li><li>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题</li><li>优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗</li><li>连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接</li><li>更合适的流量控制</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;6、http1.0&amp;#x2F;1 2 3优化&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;HTTP1.0&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。&lt;/p&gt;
&lt;p&gt;浏览器每次</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://precipitation0224.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>异步写入和同步写入</title>
    <link href="http://precipitation0224.github.io/2023/02/12/tongbuyibu/"/>
    <id>http://precipitation0224.github.io/2023/02/12/tongbuyibu/</id>
    <published>2023-02-11T19:51:01.000Z</published>
    <updated>2023-03-23T11:51:44.699Z</updated>
    
    <content type="html"><![CDATA[<p>同步写入是指当写入操作发生时，程序会一直等待直到写入完成，并且只有在写入完成后才会继续执行后续的代码。</p><p>异步写入是指当写入操作发生时，程序会立即返回并继续执行后续的代码，而不需要等待写入操作完成。这种方式可以提高程序的响应速度和吞吐量，但是也存在一定的风险，例如可能会导致数据丢失等问题。</p><p>当数据库在写入数据时宕机了，需要采取一些措施来处理这种情况。具体的解决方案可能因具体情况而异，但以下是一些常见的处理方式：</p><p><strong>数据备份</strong>：在宕机之前，定期备份数据库中的数据，以便在宕机后可以通过备份来恢复数据。</p><p><strong>事务处理</strong>：使用事务处理可以确保在执行多个操作时，如果其中一个操作失败，整个操作都会回滚，从而保证数据的一致性和完整性。</p><p><strong>写入缓存</strong>：使用写入缓存可以将数据先缓存到内存中，等到宕机之后再将数据写入磁盘中，从而减少数据丢失的风险。</p><p><strong>冗余备份</strong>：在多个服务器上备份相同的数据，当其中一个服务器宕机时，其他服务器可以继续提供服务，从而避免数据丢失。</p><p>无论采用何种处理方式，都需要对宕机的原因进行分析，并采取措施来防止类似的宕机事件再次发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;同步写入是指当写入操作发生时，程序会一直等待直到写入完成，并且只有在写入完成后才会继续执行后续的代码。&lt;/p&gt;
&lt;p&gt;异步写入是指当写入操作发生时，程序会立即返回并继续执行后续的代码，而不需要等待写入操作完成。这种方式可以提高程序的响应速度和吞吐量，但是也存在一定的风险，例</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>互斥锁和自旋锁</title>
    <link href="http://precipitation0224.github.io/2023/02/11/mutex/"/>
    <id>http://precipitation0224.github.io/2023/02/11/mutex/</id>
    <published>2023-02-10T20:07:34.000Z</published>
    <updated>2023-03-23T12:07:13.249Z</updated>
    
    <content type="html"><![CDATA[<p>互斥锁也是互斥量(Mutex)，作为保护临界区的特殊变量，两种状态locked和unlocked；</p><p>每个互斥锁内部有一个线程等待队列，用来保存互斥锁的线程，unlocked线程可得到锁，locked就阻塞到等待mutex的队列中。</p><p>自旋锁类似于互斥锁，不通过休眠阻塞进程，而是在获取锁之前一直处于忙则等待的状态，可以用于锁被持有时间短，线程无需额外调度的情况；自旋锁最多被一个进程所持有，若第二个线程申请，则会处于忙循环-旋转-等待锁重新可用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互斥锁也是互斥量(Mutex)，作为保护临界区的特殊变量，两种状态locked和unlocked；&lt;/p&gt;
&lt;p&gt;每个互斥锁内部有一个线程等待队列，用来保存互斥锁的线程，unlocked线程可得到锁，locked就阻塞到等待mutex的队列中。&lt;/p&gt;
&lt;p&gt;自旋锁类似于互</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>cookie总结</title>
    <link href="http://precipitation0224.github.io/2023/02/11/cookie%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/02/11/cookie%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-10T18:59:45.000Z</published>
    <updated>2023-03-23T12:04:07.205Z</updated>
    
    <content type="html"><![CDATA[<p>8、cookie</p><p><strong>cookie</strong>是当前识别用户，实现持久化会话的最好方式。简单点说就是服务器知道正在和哪个客户端通信，以及保持与已识别出的客户端通信。Cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它。同时可以对连接另一端的用户有更多的了解，并且能在用户浏览页面时对其进行跟踪。</p><p><strong>cookie</strong>可以分为以下两类：</p><p>（1）会话cookie。临时cookie，记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除了。</p><p>（2）持久cookie。持久cookie的生存时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。</p><p>唯一区别就是它们的过期时间。如果设置了Discard参数或没有设置Expires或没有设置Max-Age参数则说明这个cookie就是一个会话cookie。</p><p><strong>存储</strong>——浏览器负责存储cookie信息。不同的浏览器会以不同的方式来存储cookie。有的浏览器用cookis.txt存储。有的浏览器存储在高速缓存目录下独立的文本文件中。</p><p><strong>cookie</strong>存在安全隐患。第三方Web站点使用持久cookie来跟踪用户就是对cookie一种最大的滥用。将这种做法与IP地址和Referer首部信息结合在一起，这些营销公司就可以构建起相当精确的用户档案和浏览模式信息。</p><p><strong>cookie工作原理</strong></p><p>（1）用户首次访问Web站点时，Web服务器对用户一无所知。</p><p>（2）Web服务器通过Set-Cookie首部将cookie存放到浏览器中的cookie数据库中。cookie中包含了N个键值对，例如Cookie: id&#x3D;“1234”。cookie中可以包含任意信息，但它们通常都只包含一个服务器为了进行跟踪而产生的独特的识别码。</p><p>（3）将来用户再次访问同一站点时，浏览器会从cookie数据库中挑中那个服务器设置的cookie，并在cookie请求首部中（Cookie: id&#x3D;“1234”）将其传回给服务器。</p><p>（4）服务器可以通过id&#x3D;”1234”这个键值对来查找服务器为其访问积累的信息（购物历史、地址信息等）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;8、cookie&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie&lt;/strong&gt;是当前识别用户，实现持久化会话的最好方式。简单点说就是服务器知道正在和哪个客户端通信，以及保持与已识别出的客户端通信。Cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://precipitation0224.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>接雨水两侧动规问题</title>
    <link href="http://precipitation0224.github.io/2023/02/09/jieyushui/"/>
    <id>http://precipitation0224.github.io/2023/02/09/jieyushui/</id>
    <published>2023-02-08T20:30:02.000Z</published>
    <updated>2023-03-23T12:05:55.959Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../picture/jieyushui.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i)<br>            left[i] = <span class="hljs-built_in">max</span>(left[i<span class="hljs-number">-1</span>], height[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; --i)<br>            right[i] = <span class="hljs-built_in">max</span>(right[i+<span class="hljs-number">1</span>], height[i+<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> water = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br>            <span class="hljs-type">int</span> level = <span class="hljs-built_in">min</span>(left[i], right[i]);<br>            water += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, level-height[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> water;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键在于表示从左和从右的高度，以及用最小的高度乘上间距即是容积.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../picture/jieyushui.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
