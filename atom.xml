<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yummy home</title>
  
  <subtitle>欢迎你来看看我呀</subtitle>
  <link href="http://precipitation0224.github.io/atom.xml" rel="self"/>
  
  <link href="http://precipitation0224.github.io/"/>
  <updated>2023-05-28T03:52:32.080Z</updated>
  <id>http://precipitation0224.github.io/</id>
  
  <author>
    <name>Yummy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>联邦学习下的表征学习相关paper</title>
    <link href="http://precipitation0224.github.io/2023/05/27/fedrep/"/>
    <id>http://precipitation0224.github.io/2023/05/27/fedrep/</id>
    <published>2023-05-27T11:39:45.000Z</published>
    <updated>2023-05-28T03:52:32.080Z</updated>
    
    <content type="html"><![CDATA[<p><strong>FedClassAvg: Local Representation Learning for Personalized Federated Learning on Heterogeneous Neural Networks</strong></p><p>个性化联合学习旨在允许众多客户在不交换私人数据的情况下，以高效沟通的方式参与协作培训，同时培训个性化模型。然而，许多个性化联合学习算法假设客户端具有相同的神经网络结构，而针对不同模型的算法仍未得到充分研究。在这项研究中，我们提出了一种新的个性化联合学习方法，称为联合分类器平均(FedClassAvg)。用于有监督学习任务的深度神经网络由特征提取器层和分类器层组成。FedClassAvg将分类器权重聚合为特征空间上决策边界的协议，以便具有不独立且相同分布(非IID)数据的客户可以了解稀缺标签。此外，应用局部特征表示学习来稳定决策边界，提高客户的局部特征提取能力。现有的方法需要收集辅助数据或模型权重来生成对应的数据，而FedClassAvg只需要客户端与几个完全连接的层进行通信，这是非常高效的通信效率。此外，FedClassAvg不需要额外的优化问题，如知识转移，这需要密集的计算开销。我们通过大量的实验对FedClassAvg进行了评估，并证明了它在异类个性化联合学习任务上的性能优于目前最先进的算法。</p><p><strong>Think Locally, Act Globally: Federated Learning with Local and Global Representations</strong></p><p>联合学习是一种对分布在多个设备上的私有数据进行模型训练的方法。为了保持设备数据的私密性，全局模型仅通过传递参数和更新进行训练，这对大型模型的可扩展性构成了挑战。为此，我们提出了一种新的联合学习算法，该算法联合学习每个设备上的紧凑局部表示和所有设备上的全局模型。因此，全局模型可以更小，因为它只对局部表示进行操作，从而减少了传递的参数的数量。从理论上讲，我们提供了一个泛化分析，它表明局部和全局模型的组合既减少了数据中的方差，也减少了设备分布之间的方差。经验上，我们证明了本地模型能够在保持性能的同时实现有效沟通的训练。我们还评估了从真实移动数据中预测个性化情绪的任务，其中隐私是关键。最后，本地模型处理来自新设备的异类数据，并学习混淆种族、年龄和性别等受保护属性的公平表示法。</p><p><strong>Collaborative Unsupervised Visual Representation Learning from Decentralized Data</strong></p><p>无监督表示学习利用互联网上的集中数据取得了出色的性能。然而，隐私保护意识的增强限制了分散的未标记图像数据的共享，这些数据在多方(例如移动电话和相机)中呈爆炸性增长。因此，一个自然的问题是如何利用这些数据来学习下游任务的可视化表示，同时保护数据隐私。针对这一问题，我们提出了一种新的联邦无监督学习框架FEDU。在该框架中，每一方使用在线网络和目标网络的对比学习来独立地从未标记的数据中训练模型。然后，中央服务器聚合训练的模型，并用聚合的模型更新客户端的模型。它保护数据隐私，因为每一方都只能访问其原始数据。多个缔约方之间分散的数据通常是非独立和相同分布的(非IID)，导致性能下降。为了应对这一挑战，我们提出了两种简单而有效的方法：1)我们设计了通信协议，只上传在线网络的编码者进行服务器聚合，并使用聚合的编码者更新它们；2)我们引入了一个新的模块，根据非IID引起的分歧来动态决定如何更新预测器。预测器是在线网络的另一个组成部分。广泛的实验和消融证明了FEDU的有效性和重要性。在非IID数据的线性和半监督评估中，它的性能比只有一方的训练方法高出5%以上，比其他方法高出14%以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;FedClassAvg: Local Representation Learning for Personalized Federated Learning on Heterogeneous Neural Networks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个</summary>
      
    
    
    
    
    <category term="联邦学习和多视图聚类" scheme="http://precipitation0224.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>联邦多视图表征训练</title>
    <link href="http://precipitation0224.github.io/2023/05/24/fedmvt/"/>
    <id>http://precipitation0224.github.io/2023/05/24/fedmvt/</id>
    <published>2023-05-24T12:57:46.000Z</published>
    <updated>2023-05-28T03:50:52.621Z</updated>
    
    <content type="html"><![CDATA[<p>FedMVT: Semi-supervised Vertical Federated Learning with MultiView Training</p><p><img src="/../picture/fedmvt.png"></p><p>提出了联邦多视图训练(FedMVT)，这是一种半监督学习方法，可以在有限重叠样本的情况下提高VFL的性能。FedMVT利用特征表示估计和伪标签预测扩展训练集，并联合训练三个分类器，提高模型的表征学习能力。FedMVT不仅显著提高了VFL中联邦模型的性能，而且还提高了拥有标签一方的局部模型的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FedMVT: Semi-supervised Vertical Federated Learning with MultiView Training&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../picture/fedmvt.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;提出了联邦多视图训练(F</summary>
      
    
    
    
    
    <category term="联邦学习和多视图聚类" scheme="http://precipitation0224.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的测试及第三方库Ginkgo使用</title>
    <link href="http://precipitation0224.github.io/2023/04/23/gotest/"/>
    <id>http://precipitation0224.github.io/2023/04/23/gotest/</id>
    <published>2023-04-22T19:14:05.000Z</published>
    <updated>2023-04-22T12:03:28.132Z</updated>
    
    <content type="html"><![CDATA[<p>软件测试的定义：通过模拟实际使用环境，发现并报告软件中的缺陷和错误的过程，软件测试很重要，它可以保证软件的质量和可靠性，同时减少因缺陷而造成的损失和成本。</p><p>软件测试生命周期通常包括计划、分析、设计、执行和评估阶段。分析阶段，分析需求和确定的范围；设计阶段，编写测试用例和测试脚本；执行阶段，执行测试并记录结果；评估阶段，评估测试的效果，生成测试报告。</p><p>软件测试方法包括功能测试、性能测试、安全测试、易用性测试、兼容性测试、可靠性测试等。</p><p>测试用例是一个测试计划的基本单元，用于验证软件是否符合预期行为。测试用例应包括输入、预期输出、实际输出和测试结果。</p><p>黑盒测试是在<strong>不了解内部结构的情况下</strong>对软件进行测试，白盒测试是在<strong>了解软件内部结构</strong>的情况下对软件进行测试，着重于<strong>测试代码的正确性和完整性</strong>。</p><p>单元测试是对软件中最小的可测试单元进行测试，通常是一个函数或一个模块，如go内置的testing。</p><p>这里演示一个简单的testing包测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subtract</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a - b<br>&#125;<br><br><span class="hljs-keyword">package</span> math<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    result := Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-number">5</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Add(2, 3) = %d; want 5&quot;</span>, result)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSubtract</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    result := Subtract(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-number">3</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Subtract(5, 2) = %d; want 3&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行<em>go test</em>有:</p><p><img src="/../picture/mathtest.png"></p><p>自动化测试是使用工具和脚本来代替手动测试过程的测试方法，包括Selenium、Appium、Robot Framework和Cypress等。</p><p>性能测试是测试软件的性能和稳定性，主要是测试系统在各种负载下的响应时间、吞吐量和并发用户数等方面，包括Apache JMeter、Gatling和Locust等。</p><p>Go语言第三方库，对Ginkgo和Gomega进行介绍。</p><p>Ginkgo：Ginkgo是一个BDD风格的测试框架，支持Go语言中的自然语言测试表述。它具有嵌套的Describe和Context块，可以描述程序的各个方面，也可以使用It函数编写具体的测试用例。</p><p>Gomega：Gomega是一个用于Go语言的断言库，可以与Ginkgo和GoConvey等测试框架配合使用。它提供了丰富的匹配器函数和简单易用的API，可以方便地编写测试代码。</p><p>下面给出一个简单的测试demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* mypackage_test.go */</span><br><span class="hljs-keyword">package</span> mypackage_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;mypackage&quot;</span><br>    <br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;MyPackage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    It(<span class="hljs-string">&quot;should return true&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        result := mypackage.MyFunction()<br>        Expect(result).To(Equal(<span class="hljs-literal">true</span>))<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* mypackage_suite_test.go */</span><br><span class="hljs-keyword">package</span> mypackage_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;testing&quot;</span><br><br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMyPackage</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    RegisterFailHandler(Fail)<br>    RunSpecs(t, <span class="hljs-string">&quot;MyPackage Suite&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>后面只需在终端运行ginkgo即可，得到一下的测试输出：</p><p><img src="/../picture/ginkgotest.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件测试的定义：通过模拟实际使用环境，发现并报告软件中的缺陷和错误的过程，软件测试很重要，它可以保证软件的质量和可靠性，同时减少因缺陷而造成的损失和成本。&lt;/p&gt;
&lt;p&gt;软件测试生命周期通常包括计划、分析、设计、执行和评估阶段。分析阶段，分析需求和确定的范围；设计阶段，编写</summary>
      
    
    
    
    
    <category term="Golang" scheme="http://precipitation0224.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>golang中的GC</title>
    <link href="http://precipitation0224.github.io/2023/03/30/gogc/"/>
    <id>http://precipitation0224.github.io/2023/03/30/gogc/</id>
    <published>2023-03-29T20:11:14.000Z</published>
    <updated>2023-04-22T12:09:28.018Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言采用了一种基于垃圾回收的内存管理机制，即使用垃圾回收器来<u>自动管理内存分配和释放</u>，以便可以更轻松地编写代码，而不必担心内存分配和释放的问题。</p><p>在Go语言中，内存分配是通过调用new或make函数来完成的。new函数用于分配值类型（如int、struct等）的内存，而make函数用于分配引用类型（如slice、map、channel等）的内存。</p><p>看一个示例，使用new和make来分配内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用 new 函数分配一个 int 类型的内存，并将其初始化为 0</span><br>    p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 使用 * 运算符来访问指针所指向的内存，并修改其值</span><br>    *p = <span class="hljs-number">123</span><br><br>    <span class="hljs-comment">// 输出指针的值和所指向的内存的值</span><br>    fmt.Printf(<span class="hljs-string">&quot;p=%p, *p=%d\n&quot;</span>, p, *p)<br><br>    <span class="hljs-comment">// 使用 make 函数分配一个 int 类型的 slice，并将其初始化为 0</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">// 使用 [] 运算符来访问 slice 中的元素，并修改其值</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    s[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>    s[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br><br>    <span class="hljs-comment">// 输出 slice 的长度和容量，以及其中的元素</span><br>    fmt.Printf(<span class="hljs-string">&quot;len(s)=%d, cap(s)=%d, s=%v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-comment">// p=0xc000018088, *p=123 len(s)=10, cap(s)=10, s=[1 2 3 0 0 0 0 0 0 0]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当Go程序运行时，Go语言的垃圾回收器（Garbage Collector，GC）会自动分配和管理内存，以便程序员可以专注于编写代码，而无需手动进行内存分配和释放。在Go语言中，垃圾回收器采用的是标记-清除（Mark and Sweep）算法，即对于所有已分配的内存进行周期性的垃圾回收。</p><p>下面是<em>Garbage Collector</em>的一些重要特点和行为：</p><p><u><strong>分配内存</strong></u>：Go程序中的内存分配是由垃圾回收器负责的。使用new或make函数分配内存时，垃圾回收器会在堆（Heap）中为该对象分配一块新的内存。在分配内存时，垃圾回收器会跟踪已使用和未使用的内存块，以便在需要时回收未使用的内存。<br><u><strong>标记对象</strong></u>：垃圾回收器需要识别出哪些对象是活动的（即仍然在程序中使用），哪些对象是垃圾（即不再使用并且可以被回收）。垃圾回收器使用“三色标记”算法来标记活动对象和垃圾对象。它会从根对象（如全局变量、栈中的变量等）开始，递归遍历所有对象，并将活动对象标记为“白色”，未标记的对象即为垃圾。<br><u><strong>清除垃圾</strong></u>：在标记过程中，垃圾回收器会在对象上设置标记，以表明该对象已经被标记。标记结束后，垃圾回收器会扫描堆中所有未标记的对象，并将它们的内存释放回堆中。在清除过程中，垃圾回收器会把所有垃圾对象所占用的内存块合并起来，形成更大的内存块，以便将来分配给新对象使用。<br><u><strong>停止-复制GC</strong></u>：除了标记-清除算法之外，Go垃圾回收器还采用了停止-复制（Stop and Copy）算法。这种算法将堆分成两部分：From空间和To空间。在垃圾回收过程中，所有活动对象都被复制到To空间中，而From空间中的所有垃圾都被清除。在清除过程中，垃圾回收器会将From空间中的对象复制到To空间中，并交换From和To的角色。这种算法有助于减少内存碎片，并提高分配效率。</p><p>再对自动回收进行解释，一般是不手动触发的，但如果实在要手动出发也可以，调用的是runtime.gc()来触发垃圾回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 分配一个较大的切片</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000000</span>)<br><br>    <span class="hljs-comment">// 使用切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>        s[i] = i<br>    &#125;<br><br>    <span class="hljs-comment">// 释放切片</span><br>    s = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-comment">// 手动触发垃圾回收</span><br>    runtime.GC()<br><br>    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先分配了一个长度为1000000的切片，然后使用该切片，并将其设置为nil以释放内存。最后，我们手动调用了runtime.GC()函数，强制 Go 语言的垃圾回收器回收未使用的内存。</p><p>手动触发垃圾回收并不是 Go 语言中推荐的做法，因为 Go 语言的垃圾回收器通常会自动回收未使用的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言采用了一种基于垃圾回收的内存管理机制，即使用垃圾回收器来&lt;u&gt;自动管理内存分配和释放&lt;/u&gt;，以便可以更轻松地编写代码，而不必担心内存分配和释放的问题。&lt;/p&gt;
&lt;p&gt;在Go语言中，内存分配是通过调用new或make函数来完成的。new函数用于分配值类型（如int、</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GMP-Goroutine的调度器</title>
    <link href="http://precipitation0224.github.io/2023/03/27/gmp/"/>
    <id>http://precipitation0224.github.io/2023/03/27/gmp/</id>
    <published>2023-03-27T09:50:46.000Z</published>
    <updated>2023-03-27T01:56:03.085Z</updated>
    
    <content type="html"><![CDATA[<p>GMP指的是Goroutine Multiprocessing。</p><p>Goroutine是Go语言的一种轻量级线程，可以在单个进程中同时运行多个Goroutine，并且Goroutine之间可以相互通信和同步。GMP则是指在多核CPU上利用Goroutine 实现多进程并发的技术，也被称为”<strong><u>Go并发编程</u></strong>“。</p><p>GMP技术充分利用了现代多核处理器的特点，通过将任务分配到多个Goroutine上实现并行计算，从而提高了程序的性能和吞吐量。在GMP中，每个Goroutine都是一个轻量级的进程，它们之间可以共享内存，通过Channel进行通信和同步，而无需显式的加锁或解锁。</p><p>在Go语言中，使用GMP技术可以方便地实现高并发的网络编程、多任务计算、并行处理等应用场景。同时，Go语言标准库提供了丰富的Goroutine和Channel相关的API，进一步简化了GMP技术的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(num <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 告知wait group当前goroutine已完成计算</span><br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>        sum += i<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;Goroutine %d: sum(%d) = %d\n&quot;</span>, num, num, sum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用wait group等待所有goroutine完成计算</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 告知wait group有一个新的goroutine正在运行</span><br>        <span class="hljs-keyword">go</span> calculate(i+<span class="hljs-number">1</span>, &amp;wg)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有goroutine完成计算</span><br>    fmt.Println(<span class="hljs-string">&quot;All goroutines completed!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../picture/gmp.png"></p><p>在上面的示例代码中，我们定义了一个<strong>calculate</strong>函数，该函数会计算从0到给定数值之间的所有整数的和，并打印出计算结果。然后，我们在<strong>main</strong>函数中使用循环启动了4个<em>Goroutine</em>，每个<em>Goroutine</em>都会调用<strong>calculate</strong>函数进行计算。为了确保所有<em>Goroutine</em>都完成了计算，我们使用了<strong>sync.WaitGroup</strong>来等待它们的完成。</p><p>总结GMP的思路：</p><p>将任务分配到多个<em>Goroutine</em>上，然后使用<em>WaitGroup</em>等待它们的完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GMP指的是Goroutine Multiprocessing。&lt;/p&gt;
&lt;p&gt;Goroutine是Go语言的一种轻量级线程，可以在单个进程中同时运行多个Goroutine，并且Goroutine之间可以相互通信和同步。GMP则是指在多核CPU上利用Goroutine 实现</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang中Goroutine和Channel的Demo</title>
    <link href="http://precipitation0224.github.io/2023/03/27/grountinechan/"/>
    <id>http://precipitation0224.github.io/2023/03/27/grountinechan/</id>
    <published>2023-03-26T22:08:51.000Z</published>
    <updated>2023-03-28T12:07:22.312Z</updated>
    
    <content type="html"><![CDATA[<p>Golang中Goroutine和Channel的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, results <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> jobs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;worker %d processing job %d\n&quot;</span>, id, j)<br>time.Sleep(time.Second)<br>results &lt;- j * <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> numJobs = <span class="hljs-number">5</span><br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numJobs)<br>results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numJobs)<br><br><span class="hljs-keyword">for</span> w := <span class="hljs-number">1</span>; w &lt;= <span class="hljs-number">3</span>; w++ &#123;<br><span class="hljs-keyword">go</span> worker(w, jobs, results)<br>&#125;<br><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= numJobs; j++ &#123;<br>jobs &lt;- j<br>&#125;<br><span class="hljs-built_in">close</span>(jobs)<br><br><span class="hljs-keyword">for</span> a := <span class="hljs-number">1</span>; a &lt;= numJobs; a++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;result %d\n&quot;</span>, &lt;-results)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>程序结果：</strong></p><p><img src="/../picture/gorountinechan.png#pic_left"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Golang中Goroutine和Channel的实例&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>goroutine和mutex协作</title>
    <link href="http://precipitation0224.github.io/2023/03/23/goroutine/"/>
    <id>http://precipitation0224.github.io/2023/03/23/goroutine/</id>
    <published>2023-03-22T21:35:17.000Z</published>
    <updated>2023-04-22T12:09:57.137Z</updated>
    
    <content type="html"><![CDATA[<p>Goroutine 是 Golang 中的轻量级线程，可以由 Go 语言的运行时（runtime）进行调度。Goroutine 可以在单个线程中实现并发执行，因此可以在一个程序中创建大量的 Goroutine，而不会造成系统资源的浪费。</p><p>在golang中，创建协程的方式很简单，使用<em>go</em>关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 这里是 Goroutine 的代码逻辑</span><br>&#125;()<br></code></pre></td></tr></table></figure><p>Memory由内存分配器管理负责，可以动态地分配和释放内存，使得程序能够更加高效地利用系统资源。而Golang 中的内存分配器采用了类似于 C++ 中的<strong>内存池</strong>技术。在程序启动时，内存分配器会预先分配一些内存，称为堆。当需要分配内存时，内存分配器会从堆中分配一部分内存，并将其标记为已使用。当内存不再需要时，内存分配器会将其释放，并将其标记为未使用。</p><p>前面提到了<em>Gorountine</em>，那么给出<em>Goroutine</em>的<strong>调度逻辑</strong>：</p><p>Golang 中的<em>Goroutine</em>调度是由<em>runtime</em>模块进行管理的。在Golang中，所有的Goroutine都会被分配到一个逻辑处理器上执行。逻辑处理器可以看作是一个虚拟的CPU核心，每个逻辑处理器都可以执行多个 <em>Goroutine</em>。</p><p>当一个<em>Goroutine</em>遇到I&#x2F;O操作或者调用time.Sleep等函数时，它会主动将处理器释放给其他<em>Goroutine</em>执行。在下一次调度时，<em>runtime</em>模块会重新将该<em>Goroutine</em>分配到一个逻辑处理器上执行。</p><p>下一点，就是要考虑并发的安全性，那就要引入锁了，具体到go的sync包下的<em>Mutex</em>。</p><p>一块代码实例展示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> mutex sync.Mutex<br>    count := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            mutex.Lock()<br>            count++<br>            mutex.Unlock()<br><br>            wg.Done()<br>        &#125;()<br>    &#125;<br><br>    wg.Wait()<br>    <span class="hljs-comment">// 最后的结果也是100</span><br>    fmt.Printf(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, count)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的demo中，我们创建了一个包含100个<em>Goroutine</em>的循环，每个<em>Goroutine</em>都会将一个计数器<em>count</em>的值加一。为了保证<em>Goroutine</em>的安全性，我们使用了<em>Mutex</em>锁来保证在同一时间内只有一个<em>Goroutine</em>能够访问count变量。</p><p>在代码中，我们使用了sync包提供的<em>WaitGroup</em>和Mutex。<em>WaitGroup</em>可以帮助我们等待所有的<em>Goroutine</em>执行完毕，而<em>Mutex</em>则用于保护<em>coun</em>t变量的访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Goroutine 是 Golang 中的轻量级线程，可以由 Go 语言的运行时（runtime）进行调度。Goroutine 可以在单个线程中实现并发执行，因此可以在一个程序中创建大量的 Goroutine，而不会造成系统资源的浪费。&lt;/p&gt;
&lt;p&gt;在golang中，创建</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>LFU</title>
    <link href="http://precipitation0224.github.io/2023/03/14/LFU/"/>
    <id>http://precipitation0224.github.io/2023/03/14/LFU/</id>
    <published>2023-03-13T22:48:08.000Z</published>
    <updated>2023-03-24T05:26:32.119Z</updated>
    
    <content type="html"><![CDATA[<p>LFU缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity), <span class="hljs-built_in">min_freq</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; &#125;<br>        <span class="hljs-keyword">auto</span> it = key_st[key];<br>        <span class="hljs-type">int</span> freq = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it);<br><br>        <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[freq];<br>        <span class="hljs-keyword">auto</span> &amp;&amp;other = freq_st[freq + <span class="hljs-number">1</span>];<br>        other.<span class="hljs-built_in">splice</span>(other.<span class="hljs-built_in">begin</span>(), lst, it);<br><br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it)++; <span class="hljs-comment">// 更新键值的使用频率</span><br>        <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>            freq_st.<span class="hljs-built_in">erase</span>(freq);<br>            <span class="hljs-keyword">if</span> (min_freq == freq) &#123;<br>                min_freq++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*it);<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 测试用例含 capacity == 0</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果键 key 已存在，则变更其值，并更新该 key 对应的 freq</span><br>            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*key_st[key]) = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果键不存在，请插入键值对</span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            <span class="hljs-comment">// 当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项</span><br>            <span class="hljs-comment">// 当两个或更多个键具有相同使用频率时，应该去除 最近最久未使用 的键。</span><br>            <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[min_freq];<br>            key_st.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(lst.<span class="hljs-built_in">back</span>()));<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>                freq_st.<span class="hljs-built_in">erase</span>(min_freq);<br>            &#125;<br>        &#125;<br>        min_freq = <span class="hljs-number">1</span>; <span class="hljs-comment">// 这是可以肯定的</span><br>        freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(key, value, <span class="hljs-number">1</span>);<br>        key_st[key] = freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> min_freq; <span class="hljs-comment">// 用于跟踪使用最少的频率</span><br>    <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Tuple; <span class="hljs-comment">// &lt;key, value, freq&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;&gt; freq_st; <span class="hljs-comment">// 相同使用频率的键值对放入在同一个链表中</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;::iterator&gt; key_st;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LFU缓存&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="http://precipitation0224.github.io/2023/03/14/LRU/"/>
    <id>http://precipitation0224.github.io/2023/03/14/LRU/</id>
    <published>2023-03-13T22:48:03.000Z</published>
    <updated>2023-03-24T05:22:03.118Z</updated>
    
    <content type="html"><![CDATA[<p>LRU缓存机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 快速查询和删除（哈希表）、快速查询最久未使用、删除元素、移动元素（链表）</span><br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> it = st[key];<br><br>        <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>        lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it);<br>        <span class="hljs-keyword">return</span> it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 已经存在，则变更其数据值 value</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">find</span>(key); it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            it-&gt;second-&gt;second = value;<br>            <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>            lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it-&gt;second);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果插入操作会导致关键字数量超过 capacity，则应该先 逐出 最久未使用的关键字。</span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            st.<span class="hljs-built_in">erase</span>(lst.<span class="hljs-built_in">rbegin</span>()-&gt;first);<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不存在，则向缓存中插入该组 key-value</span><br>        lst.<span class="hljs-built_in">emplace_front</span>(key, value);<br>        st[key] = lst.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Pair;<br>    <span class="hljs-type">int</span> capacity;<br>    list&lt;Pair&gt; lst; <span class="hljs-comment">// &lt;key, value&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Pair&gt;::iterator&gt; st; <span class="hljs-comment">// &lt;key, key_value_pair_iterator&gt;</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LRU缓存机制&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迭代器的随机访问</title>
    <link href="http://precipitation0224.github.io/2023/03/12/iteratoraccess/"/>
    <id>http://precipitation0224.github.io/2023/03/12/iteratoraccess/</id>
    <published>2023-03-11T21:31:49.000Z</published>
    <updated>2023-04-07T13:35:38.421Z</updated>
    
    <content type="html"><![CDATA[<p>STL中的随机访问迭代器是在其他迭代器基础上实现的，其本质是对指针的封装，可以像指针一样进行算数运算和随机访问，需要支持以下的操作</p><ul><li>迭代器加减运算</li><li>迭代器之间的比较运算</li><li>迭代器和指针之间的转换</li><li>通过迭代器访问元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomAccessIterator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> pointer = T*;<br>    <span class="hljs-keyword">using</span> reference = T&amp;;<br>    <span class="hljs-keyword">using</span> iterator_category = std::random_access_iterator_tag;<br><br>    <span class="hljs-built_in">RandomAccessIterator</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">RandomAccessIterator</span>(pointer p) : <span class="hljs-built_in">ptr_</span>(p) &#123;&#125;<br>    <span class="hljs-built_in">RandomAccessIterator</span>(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) : <span class="hljs-built_in">ptr_</span>(other.ptr_) &#123;&#125;<br>    ~<span class="hljs-built_in">RandomAccessIterator</span>() = <span class="hljs-keyword">default</span>;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) &#123;<br>        ptr_ = other.ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> *ptr_;<br>    &#125;<br><br>    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        ++ptr_;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        --ptr_;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>+=(difference_type n) &#123;<br>        ptr_ += n;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>+(difference_type n) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp += n;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>-=(difference_type n) &#123;<br>        ptr_ -= n;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>-(difference_type n) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp -= n;<br>    &#125;<br><br>    difference_type <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ - other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ == other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ != other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &lt; other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &gt; other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &lt;= other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &gt;= other.ptr_;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    pointer ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">it</span><span class="hljs-params">(arr)</span></span>;<br>    <span class="hljs-function">RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">it_end</span><span class="hljs-params">(arr + <span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 随机访问第3个元素</span><br>    <span class="hljs-type">int</span> value1 = *(it + <span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value1 = &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 随机访问第1个元素</span><br>    <span class="hljs-type">int</span> value2 = *(it_end - <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value2 = &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 通过迭代器访问元素</span><br>    <span class="hljs-keyword">for</span> (RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; it_tmp = it; it_tmp != it_end; ++it_tmp) &#123;<br>        std::cout &lt;&lt; *it_tmp &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 比较迭代器大小</span><br><span class="hljs-type">bool</span> result1 = it &lt; it_end;<br><span class="hljs-type">bool</span> result2 = it + <span class="hljs-number">1</span> &gt;= it_end <span class="hljs-number">-3</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;result1 = &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;result2 = &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，我们定义了一个模板类<code>RandomAccessIterator</code>，并且实现了随机访问迭代器所需的各个成员函数。在<code>main()</code>函数中，我们使用了<code>RandomAccessIterator</code>来访问一个数组，并展示了随机访问第3个和第1个元素的方式，以及通过迭代器遍历整个数组，比较迭代器的大小等操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STL中的随机访问迭代器是在其他迭代器基础上实现的，其本质是对指针的封装，可以像指针一样进行算数运算和随机访问，需要支持以下的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代器加减运算&lt;/li&gt;
&lt;li&gt;迭代器之间的比较运算&lt;/li&gt;
&lt;li&gt;迭代器和指针之间的转换&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://precipitation0224.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>浮点数和MD5,Base64</title>
    <link href="http://precipitation0224.github.io/2023/03/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/"/>
    <id>http://precipitation0224.github.io/2023/03/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/</id>
    <published>2023-03-10T18:32:32.000Z</published>
    <updated>2023-03-23T12:11:09.639Z</updated>
    
    <content type="html"><![CDATA[<p>4、浮点数的存储方式</p><ol><li><p>符号位：‘+’存储为0，‘-’存储为1</p></li><li><p>将数字转化成二进制数</p></li><li><p>将二进制数规范化为 1.xxxxxxxx*2^n</p></li><li><p>将n转化为指数（+127） 尾数xxxx后面补零</p></li></ol><p>5、介绍MD5、Base64</p><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。md5运算结果是一个固定长度为128位的二进制数，经过一系列的运算得到32个16进制数。</p><p>Base64是一种使用64基的位置计数法。它使用2的最大次方来代表仅可打印的ASCII字符。这使它可用来作为电子邮件的传输编码。在Base64中的变量使用字符A-Z、a-z和0-9，这样共有62个字符，用来作为开始的64个数字，最后两个用来作为数字的符号在不同的系统中而不同。一些如unencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。</p><p>MD5加密算法是不可逆的，base64加密算法是可逆的；MD5加密算法是不可逆的，base64加密算法是可逆的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;4、浮点数的存储方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;符号位：‘+’存储为0，‘-’存储为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将数字转化成二进制数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将二进制数规范化为 1.xxxxxxxx*2^n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将n转</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>vector动态扩容机制</title>
    <link href="http://precipitation0224.github.io/2023/03/10/vectorexpand/"/>
    <id>http://precipitation0224.github.io/2023/03/10/vectorexpand/</id>
    <published>2023-03-09T21:30:57.000Z</published>
    <updated>2023-04-07T13:34:47.302Z</updated>
    
    <content type="html"><![CDATA[<p>vector中的动态扩容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* push_back() */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alloc</span>&gt;<br><span class="hljs-type">void</span> vector&lt;T, Alloc&gt;::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">const</span> value_type&amp; val)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123; <span class="hljs-comment">// 如果还有剩余空间，直接插入元素</span><br>        _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish, val);<br>        ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则需要重新分配空间</span><br>        _M_insert_aux(<span class="hljs-built_in">end</span>(), val);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alloc</span>&gt;<br><span class="hljs-type">void</span> vector&lt;T, Alloc&gt;::_M_insert_aux(iterator position, <span class="hljs-type">const</span> T&amp; x)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123; <span class="hljs-comment">// 如果还有剩余空间，直接插入元素</span><br>        _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish, *(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">1</span>));<br>        ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>        T x_copy = x;<br>        std::<span class="hljs-built_in">copy_backward</span>(position, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">1</span>);<br>        *position = x_copy;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则需要扩容</span><br>        <span class="hljs-type">const</span> size_type old_size = <span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">const</span> size_type new_size = old_size != <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> * old_size : <span class="hljs-number">1</span>;<br>        iterator new_start = _M_allocate(new_size);<br>        iterator new_finish = new_start;<br>        <span class="hljs-keyword">try</span> &#123;<br>            new_finish = std::__uninitialized_copy_a(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, position, new_start, _M_get_Tp_allocator());<br>            _Alloc_traits::<span class="hljs-built_in">construct</span>(_M_get_Tp_allocator(), new_finish, x);<br>            ++new_finish;<br>            new_finish = std::__uninitialized_copy_a(position, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish, new_finish, _M_get_Tp_allocator());<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (...) &#123;<br>            _M_destroy(new_start, new_finish);<br>            _M_deallocate(new_start, new_size);<br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>        _M_destroy(<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">end</span>());<br>        _M_deallocate(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage - <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start);<br>        <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start = new_start;<br>        <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish = new_finish;<br>        <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage = new_start + new_size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>vector的底层实现使用了动态数组，即在内存中分配一段连续的空间来存储元素。</li><li>当vector的元素数量达到其容量时，需要进行扩容。vector的扩容是通过重新分配一段更大的内存空间，并将原有的元素拷贝到新空间来实现的。</li><li>为了避免频繁的扩容操作，vector采用了倍增策略来确定新的容量大小。即在扩容时，将原有容量乘以一个系数，通常为2，来计算新的容量大小。</li><li>在实现中，vector使用了allocator来管理内存分配，以保证分配的内存块是对齐的并遵循C++的类型安全规则。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* reverse() */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alloc</span>&gt;<br><span class="hljs-type">void</span> vector&lt;T, Alloc&gt;::<span class="hljs-built_in">reverse</span>() <span class="hljs-keyword">noexcept</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;_M_ipml._M_finish-<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start&gt;<span class="hljs-number">1</span>) &#123;<br>        std::_reverse(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在源代码中，可以看到当vector内部存储的元素数量大于1时，才会调用std::__reverse()函数对其进行反转。下面是std::__reverse()函数的源代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* std::_reverse() */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _BidirectionalIterator&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)<br>&#123;<br>    <span class="hljs-comment">// 反转区间[first, last)中的元素</span><br>    <span class="hljs-comment">// 首尾两个迭代器分别指向区间的首尾</span><br>    <span class="hljs-keyword">while</span> (__first != __last &amp;&amp; __first != --__last) &#123;<br>        <span class="hljs-comment">// 将首尾两个元素进行交换</span><br>        std::<span class="hljs-built_in">iter_swap</span>(__first, __last);<br>        <span class="hljs-comment">// 将迭代器向前和向后移动</span><br>        ++__first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在std::__reverse()函数中，使用了双向迭代器，并利用std::iter_swap()函数将首尾两个元素进行交换，然后将迭代器向前和向后移动，直到迭代器相遇或者前一个迭代器等于后一个迭代器减1。通过分析以上源代码，我们可以看到STL中reverse()函数的实现采用了双向迭代器，并利用std::iter_swap()函数交换元素，这个函数是标准库中定义的交换元素的函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vector中的动态扩容&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    
    <category term="C++" scheme="http://precipitation0224.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数动态绑定</title>
    <link href="http://precipitation0224.github.io/2023/03/08/virtualpointer/"/>
    <id>http://precipitation0224.github.io/2023/03/08/virtualpointer/</id>
    <published>2023-03-07T20:01:55.000Z</published>
    <updated>2023-03-23T12:10:10.008Z</updated>
    
    <content type="html"><![CDATA[<p>14、虚函数如何实现动态转发，每个类都有虚函数表吗</p><p>虚函数是在某基类中声明为<em><strong>virtual</strong></em>并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。</p><p>函数是通过<strong>虚函数表</strong>来实现的。每一个含有虚函数的类，都会有一个虚函数表用来存放虚函数的地址，同时类会有一个<strong>虚表指针</strong>去指向虚函数表的首地址,<strong>对象的首地址就存放着虚表指针</strong>。</p><p><strong>虚函数表：</strong>要讲清楚动态绑定的流程，首先需要了解清楚类里面虚函数表的定义，虚函数表是记录虚函数入口地址的一串数组（实际是一个函数指针数组），它只存在于定义了虚函数的类里面，这里给出一个例子来展示类中虚函数表的存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//空类的大小为1</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//大小为4，成员变量会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为4，非虚函数不会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为16，定义虚函数会增加类的大小，但是这个增加不是虚函数带来了的，而是指向虚函数表的指针所占的空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//大小为16，从这儿可以看到，类里面的多个虚函数都维护在一个虚函数表里面，只有一个指向虚函数表的指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(C)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(D)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(E)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//实际上，虚函数不占用类对象的存储空间，</span><br><span class="hljs-comment">//所以含有一个以上的虚函数的类对象大小与仅含一个虚函数大小相同</span><br><span class="hljs-comment">//同时，针对每个类，只维护一个【虚函数表（函数指针数组数组）】</span><br><span class="hljs-comment">//用于存放该类中虚函数的地址，每个【含一个及以上虚函数的对象都会含有一个指向该类虚函数表的指针】。</span><br></code></pre></td></tr></table></figure><p><strong>动态绑定虚函数工作原理：</strong> 前面提到，每一个类会为所有虚函数数维护一个虚函数表，并且有一个指针指向这个表的首地址，这个虚函数表记录着所有的虚函数的入口地址。那么在动态绑定时，编译器是如何给基类指针返回一个正确的函数入口地址，这里给出一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> a1;<br>        <span class="hljs-type">int</span> a2;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::display()&quot;</span>&lt;&lt;endl;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::clone()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::init()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> B&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::execute()&quot;</span>&lt;&lt;endl;&#125; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;C::init()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-keyword">override</span><br></code></pre></td></tr></table></figure><p>这里给出A,B,C三个类的内存情况，如下图。可以得出这么几个结论：</p><ol><li>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的</li><li>同名虚函数在基类和派生类中的虚函数表中，索引是一致的，如下图，A,B,C的display的索引都是0</li><li>派生类中，一旦对基类中的虚函数进行了覆盖，那么派生类的虚函数表中响应函数的入口地址会被替换成覆盖后的函数的地址。</li><li>一旦有新的虚函数定义，会加入到当前虚函数表的末端。</li></ol><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><em><strong>reference link</strong></em>: <a href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;14、虚函数如何实现动态转发，每个类都有虚函数表吗&lt;/p&gt;
&lt;p&gt;虚函数是在某基类中声明为&lt;em&gt;&lt;strong&gt;virtual&lt;/strong&gt;&lt;/em&gt;并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。&lt;/p&gt;
&lt;p&gt;函数是通过&lt;strong&gt;虚函数</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>http缺陷，tls和QUIC</title>
    <link href="http://precipitation0224.github.io/2023/03/07/tls/"/>
    <id>http://precipitation0224.github.io/2023/03/07/tls/</id>
    <published>2023-03-06T19:53:04.000Z</published>
    <updated>2023-03-23T12:09:46.219Z</updated>
    
    <content type="html"><![CDATA[<p>10、http安全保证，tls，如何握手</p><p>HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：</p><ol><li>通信使用明文，内容可能被窃听。</li><li>不验证通信方的身份，因此有可能遭到伪装。</li><li>无法验证报文的完整性，所以有可能被篡改。</li><li>传统的HTTP请求过程都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求和响应被黑客拦截，并且里面含有密码等敏感数据的话，会非常危险。</li></ol><p><em><strong>QUIC</strong></em> 协议 (RFC 9000) 旨在提高 Web 性能并减少访问延迟，同时保持通信机密。 一种基本方法是通过将 QUIC 握手与 TLS 1.3 握手集成并将多个 QUIC 数据包合并到一个 UDP 数据报中来减少初始往返时间 (RTT)。</p><p>总的来说，QUIC 相比于 HTTP&#x2F;2.0 来说，具有下面这些优势：</p><ul><li>使用 UDP 协议，不需要三次连接进行握手，而且也会缩短 TLS 建立连接的时间。</li><li>解决了队头阻塞问题</li><li>实现动态可插拔，在应用层实现了拥塞控制算法，可以随时切换。</li><li>报文头和报文体分别进行认证和加密处理，保障安全性。</li><li>连接能够平滑迁移</li></ul><p>连接平滑迁移指的是，你的手机或者移动设备在 4G 信号下和 WiFi 等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;10、http安全保证，tls，如何握手&lt;/p&gt;
&lt;p&gt;HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通信使用明文，内容可能被窃听。&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>string的缺陷和指针选择</title>
    <link href="http://precipitation0224.github.io/2023/03/05/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/"/>
    <id>http://precipitation0224.github.io/2023/03/05/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/</id>
    <published>2023-03-05T13:07:29.000Z</published>
    <updated>2023-03-23T12:08:53.215Z</updated>
    
    <content type="html"><![CDATA[<p>2、std::string的缺陷</p><p>最大的缺点是 std::string 是「字节串」而非「字符串」</p><ol><li>它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；</li><li>不能很好的处理宽字节的字符；</li><li>没有足够多的好用的函数，没有format格式输出，要借助要用stdio.h头文件里的 sprintf 函数。</li></ol><p>3、智能指针和原生指针的开销</p><p><strong>泛型指针：</strong></p><p>泛型指针有多种含义。1) 指void*指针，可以指向任意数据类型，因此具有“泛型”含义。2) 指具有指针特性的泛型数据结构，包含泛型的迭代器、智能指针等。 广义的迭代器是一种不透明指针，能够实现遍历访问操作。通常所说的迭代器是指狭义的迭代器，即基于C++的STL中基于泛型的iterator_traits实现的类的实例。总体来说，泛型指针和迭代器是两个不同的概念，其中的交集则是通常提到的迭代器类。</p><p><strong>原生指针：</strong></p><p>原生指针就是普通指针， 定义类似：类型 <em>变量名（int <em>p）;相反的若是一个类重载了‘</em>’和‘-&gt;’的运算符，能够像指针同样用‘</em>’和‘-&gt;’操做，就不是原生的，如iterator等。说“原生”是指“最简朴最基本的那一种”。因为现在很多东西都抽象化理论化了，所以“以前的那种最简朴最基本的指针”只是一个抽象概念（比如iterator）的表现形式之一。</p><p>c++的原生指针又可以分为普通指针，成员指针，函数指针。</p><p><strong>智能指针：</strong></p><p>智能指针是c++2.0的新特性之一，其最大的特点在于其结合了指针和对象构造析构的优点RAII，使得其在其生存期结束时可以及时释放其所管理的资源（动态内存分配得到的资源）。由于 C++ 语言没有自动内存回收机制，程序员每次得自己处理内存相关问题，但用智能指针便可以有效缓解这类问题。 一般是把指针封装到一个称之为智能指针类中，这个类中另外还封装了一个使用计数器，对指针的复制等操作将导致该计数器的值加1，对指针的delete操作则会减1，值为0时，指针为NULL。下面是智能指针的选择。</p><p>（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括三种：</p><ol><li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li><li>两个对象包含都指向第三个对象的指针；</li><li>STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</li></ol><p>（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2、std::string的缺陷&lt;/p&gt;
&lt;p&gt;最大的缺点是 std::string 是「字节串」而非「字符串」&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>静态库和动态库</title>
    <link href="http://precipitation0224.github.io/2023/03/04/staticlib/"/>
    <id>http://precipitation0224.github.io/2023/03/04/staticlib/</id>
    <published>2023-03-03T20:08:03.000Z</published>
    <updated>2023-03-23T12:08:19.694Z</updated>
    
    <content type="html"><![CDATA[<p>静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；</p><p>linux是.a文件，windows是.lib文件</p><p>制作流程，先通过gcc生成.o文件，再通过ar(<strong>参数选项rcs</strong>)将.o文件打包生成.a文件。</p><p>动态库在运行程序之前还需要配置动态库的加载路径</p><p>linux是.so文件，windows是.dll文件</p><p>通过gcc生成.o文件(<strong>参数选项fpic</strong>)，再通过gcc生成.so文件(<strong>参数选项shared</strong>)。</p><p>静态库和动态库的区别，静态库链接时，静态库中的代码会打包到可执行程序中，编译时加载，发布程序无需提供静态库，移植方便，消耗内存，更新部署复杂；动态库链接时，动态库代码不会打包到可执行程序中，运行时加载，发布程序时要提供动态库，内存占用小，更新部署发布简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；&lt;/p&gt;
&lt;p&gt;linux是.a文件，windows是.lib文件&lt;/p&gt;
&lt;p&gt;制作流程，先通过gcc生成.o文件，再通过ar(&lt;strong&gt;参数选项rcs&lt;/strong&gt;)将.o文件打包生成</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>预防sql注入</title>
    <link href="http://precipitation0224.github.io/2023/03/02/sql/"/>
    <id>http://precipitation0224.github.io/2023/03/02/sql/</id>
    <published>2023-03-02T10:35:06.000Z</published>
    <updated>2023-03-23T12:08:06.804Z</updated>
    
    <content type="html"><![CDATA[<p>11、避免sql注入</p><p><em><strong>SQL 注入（SQL Injection）</strong></em>，是 Web 开发中最常见的一种安全漏洞。</p><p>可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p><ol><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li><li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li><li>对进入数据库的特殊字符进行转义处理，或编码转换</li><li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li><li>发布前，利用工具进行 SQL 注入检测</li><li>报错信息不要包含 SQL 信息输出到 Web 页面</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11、避免sql注入&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;SQL 注入（SQL Injection）&lt;/strong&gt;&lt;/em&gt;，是 Web 开发中最常见的一种安全漏洞。&lt;/p&gt;
&lt;p&gt;可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>select原理和缺点</title>
    <link href="http://precipitation0224.github.io/2023/03/02/slio/"/>
    <id>http://precipitation0224.github.io/2023/03/02/slio/</id>
    <published>2023-03-01T20:19:33.000Z</published>
    <updated>2023-03-23T12:07:55.479Z</updated>
    
    <content type="html"><![CDATA[<p>select是一种IO多路复用计数，思想如下：</p><ol><li>要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；</li><li>系统调用select()，监听列表中的文件描述符的事件，函数本身是阻塞的，直到文件描述符的一个或多个进行IO时，函数才返回，修改文件描述符的值，0为未检测到事件，1为检测到事件；</li><li>select()返回时，会告诉进程有多少描述符要进行IO操作，遍历列表IO。</li></ol><p>select同时也有缺点</p><ol><li>调用select就要要fd集合从用户态拷贝到内核态，开销很大；</li><li>内核要遍历所有fd；</li><li>支持的文件描述符数量太小，1024bits；</li><li>文件描述符集合不能重用，内核检测到事件就要修改，每次都要重置；</li><li>select只知道有几个fd发生事件，具体哪几个还要遍历集合才知道。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;select是一种IO多路复用计数，思想如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；&lt;/l</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>联邦学习下的多视图聚类</title>
    <link href="http://precipitation0224.github.io/2023/02/27/fedmvc/"/>
    <id>http://precipitation0224.github.io/2023/02/27/fedmvc/</id>
    <published>2023-02-26T19:54:02.000Z</published>
    <updated>2023-03-23T12:05:41.284Z</updated>
    
    <content type="html"><![CDATA[<p>多视图聚类是指利用多个视图或特征描述同一组样本，在不同视图或特征空间中聚类样本。联邦学习是一种分布式机器学习框架，可以实现在数据分散的情况下进行模型训练。</p><p>在联邦学习中，多个设备或数据源共同训练模型，每个设备或数据源负责一部分数据，并通过模型的迭代来学习全局模型，从而避免了数据集中的隐私泄露问题。</p><p>在以联邦学习为背景的多视图聚类中，可以采用以下几种思路：</p><ol><li>基于<strong>模型</strong>的方法：在联邦学习框架下，利用各设备或数据源训练出的模型，对不同视图的数据进行预测，将预测结果作为新的特征，然后进行聚类。这种方法需要每个设备或数据源都具有相同的模型架构和参数设置。</li><li>基于<strong>特征</strong>的方法：在联邦学习框架下，将各设备或数据源的特征向量作为不同视图，在不同视图之间进行特征选择和特征融合，得到新的特征向量，然后进行聚类。</li><li>基于<strong>信息传递</strong>的方法：在联邦学习框架下，将各设备或数据源的聚类结果进行信息传递，利用传递的聚类结果得到新的特征向量，然后进行聚类。这种方法可以利用不同设备或数据源之间的信息交流和知识共享，提高聚类效果。</li><li>基于<strong>深度学习</strong>的方法：在联邦学习框架下，利用深度学习模型对不同视图的数据进行特征提取和特征融合，得到新的特征向量，然后进行聚类。这种方法需要在联邦学习框架下训练深度学习模型，并利用模型进行特征提取和融合。</li></ol><p>总之，基于联邦学习的多视图聚类需要充分利用各设备或数据源之间的信息交流和知识共享，结合不同视图之间的特征和模型，实现更精确和高效的聚类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多视图聚类是指利用多个视图或特征描述同一组样本，在不同视图或特征空间中聚类样本。联邦学习是一种分布式机器学习框架，可以实现在数据分散的情况下进行模型训练。&lt;/p&gt;
&lt;p&gt;在联邦学习中，多个设备或数据源共同训练模型，每个设备或数据源负责一部分数据，并通过模型的迭代来学习全局模</summary>
      
    
    
    
    
    <category term="科研" scheme="http://precipitation0224.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库三个关键性能指标</title>
    <link href="http://precipitation0224.github.io/2023/02/23/mysqleff/"/>
    <id>http://precipitation0224.github.io/2023/02/23/mysqleff/</id>
    <published>2023-02-23T11:00:41.000Z</published>
    <updated>2023-03-23T12:07:28.604Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库三个关键性能指标</p><p><em><strong>TPS</strong></em></p><p>Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。</p><p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问。(业务TPS &#x3D; CAPS × 每个呼叫平均TPS)</p><p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p><p><em><strong>QPS</strong></em></p><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><p>对应fetches&#x2F;sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p><em><strong>IOPS</strong></em></p><p>IOPS (Input&#x2F;Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I&#x2F;O请求数量，一般以每秒处理的I&#x2F;O请求数量为单位，I&#x2F;O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(Online Transaction Processing)，IOPS是关键衡量指标。另一个重要指标是数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL数据库三个关键性能指标&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;TPS&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。&lt;/p&gt;
&lt;p&gt;TPS包括一条消息入和一条消息出，加</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://precipitation0224.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
