<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yummy home</title>
  
  <subtitle>欢迎你来看看我呀</subtitle>
  <link href="http://precipitation0224.github.io/atom.xml" rel="self"/>
  
  <link href="http://precipitation0224.github.io/"/>
  <updated>2023-03-20T12:20:03.407Z</updated>
  <id>http://precipitation0224.github.io/</id>
  
  <author>
    <name>Yummy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>select原理和缺点</title>
    <link href="http://precipitation0224.github.io/2023/03/21/slio/"/>
    <id>http://precipitation0224.github.io/2023/03/21/slio/</id>
    <published>2023-03-20T20:19:33.000Z</published>
    <updated>2023-03-20T12:20:03.407Z</updated>
    
    <content type="html"><![CDATA[<p>select是一种IO多路复用计数，思想如下：</p><ol><li>要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；</li><li>系统调用select()，监听列表中的文件描述符的事件，函数本身是阻塞的，直到文件描述符的一个或多个进行IO时，函数才返回，修改文件描述符的值，0为未检测到事件，1为检测到事件；</li><li>select()返回时，会告诉进程有多少描述符要进行IO操作，遍历列表IO。</li></ol><p>select同时也有缺点</p><ol><li>调用select就要要fd集合从用户态拷贝到内核态，开销很大；</li><li>内核要遍历所有fd；</li><li>支持的文件描述符数量太小，1024bits；</li><li>文件描述符集合不能重用，内核检测到事件就要修改，每次都要重置；</li><li>select只知道有几个fd发生事件，具体哪几个还要遍历集合才知道。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;select是一种IO多路复用计数，思想如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；&lt;/l</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>lambda</title>
    <link href="http://precipitation0224.github.io/2023/03/21/lambda/"/>
    <id>http://precipitation0224.github.io/2023/03/21/lambda/</id>
    <published>2023-03-20T20:11:29.000Z</published>
    <updated>2023-03-20T12:11:53.889Z</updated>
    
    <content type="html"><![CDATA[<p>C++11的Lambda特性</p><p><strong>lambda 匿名函数</strong>很简单，可以套用如下的<strong>语法格式</strong>：[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型         {           函数体;         };</p><p>其中各部分的含义分别为：</p><p>a. <strong>[外部变量方位方式说明符]</strong>     [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p><p>b. <strong>(参数)</strong>     和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p><p>c. <strong>mutable</strong>     此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。**注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p><p>d. <strong>noexcept&#x2F;throw()</strong>     可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p><p>e. <strong>-&gt; 返回值类型</strong>     指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”。</p><p>f. <strong>函数体</strong>     和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">//对 a 数组中的元素进行排序</span><br>    <span class="hljs-built_in">sort</span>(num, num+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">bool</span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; );<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : num)&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*    </span><br><span class="hljs-comment">    程序运行结果：</span><br><span class="hljs-comment">          1 2 3 4</span><br><span class="hljs-comment">*/</span>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11的Lambda特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lambda 匿名函数&lt;/strong&gt;很简单，可以套用如下的&lt;strong&gt;语法格式&lt;/strong&gt;：[外部变量访问方式说明符] (参数) mutable noexcept&amp;#x2F;throw() -&amp;gt;</summary>
      
    
    
    
    
    <category term="C++11" scheme="http://precipitation0224.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>静态库和动态库</title>
    <link href="http://precipitation0224.github.io/2023/03/21/staticlib/"/>
    <id>http://precipitation0224.github.io/2023/03/21/staticlib/</id>
    <published>2023-03-20T20:08:03.000Z</published>
    <updated>2023-03-20T12:09:47.240Z</updated>
    
    <content type="html"><![CDATA[<p>静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；</p><p>linux是.a文件，windows是.lib文件</p><p>制作流程，先通过gcc生成.o文件，再通过ar(<strong>参数选项rcs</strong>)将.o文件打包生成.a文件。</p><p>动态库在运行程序之前还需要配置动态库的加载路径</p><p>linux是.so文件，windows是.dll文件</p><p>通过gcc生成.o文件(<strong>参数选项fpic</strong>)，再通过gcc生成.so文件(<strong>参数选项shared</strong>)。</p><p>静态库和动态库的区别，静态库链接时，静态库中的代码会打包到可执行程序中，编译时加载，发布程序无需提供静态库，移植方便，消耗内存，更新部署复杂；动态库链接时，动态库代码不会打包到可执行程序中，运行时加载，发布程序时要提供动态库，内存占用小，更新部署发布简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；&lt;/p&gt;
&lt;p&gt;linux是.a文件，windows是.lib文件&lt;/p&gt;
&lt;p&gt;制作流程，先通过gcc生成.o文件，再通过ar(&lt;strong&gt;参数选项rcs&lt;/strong&gt;)将.o文件打包生成</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>互斥锁和自旋锁</title>
    <link href="http://precipitation0224.github.io/2023/03/21/mutex/"/>
    <id>http://precipitation0224.github.io/2023/03/21/mutex/</id>
    <published>2023-03-20T20:07:34.000Z</published>
    <updated>2023-03-20T12:09:11.057Z</updated>
    
    <content type="html"><![CDATA[<p>互斥锁也是互斥量(Mutex)，作为保护临界区的特殊变量，两种状态locked和unlocked；</p><p>每个互斥锁内部有一个线程等待队列，用来保存互斥锁的线程，unlocked线程可得到锁，locked就阻塞到等待mutex的队列中。</p><p>自旋锁类似于互斥锁，不通过休眠阻塞进程，而是在获取锁之前一直处于忙则等待的状态，可以用于锁被持有时间短，线程无需额外调度的情况；自旋锁最多被一个进程所持有，若第二个线程申请，则会处于忙循环-旋转-等待锁重新可用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互斥锁也是互斥量(Mutex)，作为保护临界区的特殊变量，两种状态locked和unlocked；&lt;/p&gt;
&lt;p&gt;每个互斥锁内部有一个线程等待队列，用来保存互斥锁的线程，unlocked线程可得到锁，locked就阻塞到等待mutex的队列中。&lt;/p&gt;
&lt;p&gt;自旋锁类似于互</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库三个关键性能指标</title>
    <link href="http://precipitation0224.github.io/2023/03/18/mysqleff/"/>
    <id>http://precipitation0224.github.io/2023/03/18/mysqleff/</id>
    <published>2023-03-18T11:00:41.000Z</published>
    <updated>2023-03-18T05:04:16.889Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库三个关键性能指标</p><p><em><strong>TPS</strong></em></p><p>Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。</p><p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问。(业务TPS &#x3D; CAPS × 每个呼叫平均TPS)</p><p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p><p><em><strong>QPS</strong></em></p><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><p>对应fetches&#x2F;sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p><em><strong>IOPS</strong></em></p><p>IOPS (Input&#x2F;Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I&#x2F;O请求数量，一般以每秒处理的I&#x2F;O请求数量为单位，I&#x2F;O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(Online Transaction Processing)，IOPS是关键衡量指标。另一个重要指标是数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL数据库三个关键性能指标&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;TPS&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。&lt;/p&gt;
&lt;p&gt;TPS包括一条消息入和一条消息出，加</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://precipitation0224.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Muduo库关键代码及思想</title>
    <link href="http://precipitation0224.github.io/2023/03/18/muduo/"/>
    <id>http://precipitation0224.github.io/2023/03/18/muduo/</id>
    <published>2023-03-18T11:00:11.000Z</published>
    <updated>2023-03-18T05:04:06.230Z</updated>
    
    <content type="html"><![CDATA[<p>Muduo库关键代码及思想</p><p>Muduo库是基于Reactor模式实现的TCP网络编程库。Muduo库有三个核心组件支撑一个reactor实现 [<strong>持续</strong>] 的 [<strong>监听</strong>] 一组fd，并根据每个fd上发生的事件 [<strong>调用</strong>] 相应的处理函数。这三个组件分别是Channel类、Poller&#x2F;EpollPoller类以及EventLoop类。</p><p><strong>Channel类其实相当于一个文件描述符的保姆</strong></p><p>在TCP网络编程中，想要IO多路复用监听某个文件描述符，就要把这个fd和该fd感兴趣的事件通过epoll_ctl<strong>注册</strong>到IO多路复用模块上。当事件监听器监听到该fd发生了某个事件。事件监听器返回 [发生事件的fd集合]以及[每个fd都发生了什么事件]。</p><p>Channel类则封装了一个 [fd] 和这个 [fd感兴趣事件] 以及事件监听器监听到 [该fd实际发生的事件]。同时Channel类还提供了<strong>设置</strong>该fd的感兴趣事件，以及将该fd及其感兴趣事件<strong>注册</strong>到事件监听器或从事件监听器上<strong>移除</strong>，以及<strong>保存</strong>了该fd的每种事件对应的处理函数。</p><p><strong>负责监听文件描述符事件是否触发</strong>以及<strong>返回发生事件的文件描述符以及具体事件</strong>的模块就是Poller。所以<strong>一个Poller对象对应一个事件监听器</strong>（这里我不确定要不要把Poller就当作事件监听器）。在multi-reactor模型中，有多少reactor就有多少Poller。</p><p>muduo提供了epoll和poll两种IO多路复用方法来实现事件监听。不过默认是使用epoll来实现，也可以通过选项选择poll。但是我自己重构的muduo库只支持epoll。</p><p>这个Poller是个抽象虚类，由EpollPoller和PollPoller继承实现，与监听文件描述符和返回监听结果的具体方法也基本上是在这两个派生类中实现。EpollPoller就是封装了用epoll方法实现的与事件监听有关的各种方法，PollPoller就是封装了poll方法实现的与事件监听有关的各种方法。</p><p>Poller封装了和事件监听有关的方法和成员，调用一次Poller::poll方法它就能给你返回事件监听器的监听结果（发生事件的fd 及其 发生的事件）。作为一个网络服务器，需要有持续监听、持续获取监听结果、持续处理监听结果对应的事件的能力，也就是我们需要<strong>循环</strong>的去 【调用Poller:poll方法获取实际发生事件的Channel集合，然后调用这些Channel里面保管的不同类型事件的处理函数（调用Channel::HandlerEvent方法）。】</p><p>EventLoop就是负责实现<strong>“循环”</strong>，负责驱动<strong>“循环”</strong>的重要模块！！Channel和Poller其实相当于EventLoop的手下，EventLoop整合封装了二者并向上提供了更方便的接口来使用。</p><p>TCP网络编程的本质其实是处理下面这几个事件：</p><ul><li>连接的建立。</li><li>连接的断开：包括主动断开和被动断开。</li><li>消息到达，客户端连接文件描述符可读。</li><li>消息发送，向客户端连接文件描述符写数据。</li></ul><p>Echo服务器的搭建代码逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EventLoop loop;<br>    <span class="hljs-comment">//这个EventLoop就是main EventLoop，即负责循环事件监听处理新用户连接事件的事件循环器。第一章概述篇的图2里面的EventLoop1就是我们的main EventLoop。</span><br>    <br>    <span class="hljs-function">InetAddress <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-number">4567</span>)</span></span>;<br>    <span class="hljs-comment">//InetAddress其实是对socket编程中的sockaddr_in进行封装，使其变为更友好简单的接口而已。</span><br>    <br>    <span class="hljs-function">EchoServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;loop, addr, <span class="hljs-string">&quot;EchoServer-01&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//EchoServer类，自己等一下往下翻一下。</span><br>    <br>    server.<span class="hljs-built_in">start</span>(); <br>    <span class="hljs-comment">//启动TcpServer服务器</span><br>    <br>    loop.<span class="hljs-built_in">loop</span>(); <span class="hljs-comment">//执行EventLoop::loop()函数，这个函数在概述篇的EventLoop小节有提及，自己去看一下！！</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EchoServer</span>(EventLoop *loop,<br>            <span class="hljs-type">const</span> InetAddress &amp;addr, <br>            <span class="hljs-type">const</span> std::string &amp;name)<br>        : <span class="hljs-built_in">server_</span>(loop, addr, name)<br>        , <span class="hljs-built_in">loop_</span>(loop)<br>    &#123;<br>        server_.<span class="hljs-built_in">setConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1)<br>        );<br>        <span class="hljs-comment">// 将用户定义的连接事件处理函数注册进TcpServer中，TcpServer发生连接事件时会执行onConnection函数。</span><br>            <br>        server_.<span class="hljs-built_in">setMessageCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onMessage, <span class="hljs-keyword">this</span>,<br>                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)<br>        );<br>        <span class="hljs-comment">//将用户定义的可读事件处理函数注册进TcpServer中，TcpServer发生可读事件时会执行onMessage函数。</span><br><br>        <br>        server_.<span class="hljs-built_in">setThreadNum</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置sub reactor数量，你这里设置为3，就和概述篇图2中的EventLoop2 EventLoop3 EventLoop4对应，有三个sub EventLoop。</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        server_.<span class="hljs-built_in">start</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//用户定义的连接事件处理函数：当服务端接收到新连接建立请求，则打印Connection UP，如果是关闭连接请求，则打印Connection Down</span><br>        <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">connected</span>())<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn,</span></span><br><span class="hljs-params"><span class="hljs-function">                   Buffer *buf,</span></span><br><span class="hljs-params"><span class="hljs-function">                   Timestamp time)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//用户定义的可读事件处理函数：当一个Tcp连接发生了可读事件就把它这个接收到的消息原封不动的还回去</span><br>        std::string msg = buf-&gt;<span class="hljs-built_in">retrieveAllAsString</span>();<br>        conn-&gt;<span class="hljs-built_in">send</span>(msg);<br>        conn-&gt;<span class="hljs-built_in">shutdown</span>(); <br>    &#125;<br>    EventLoop *loop_;<br>    TcpServer server_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简单总结为以下几步：</p><ol><li>建立事件循环器EventLoop: EventLoop loop;</li><li>建立服务器对象，即TcpServer类对象 : TcpServer server_;</li><li>向TcpServer注册各类事件的用户自定义的处理函数: setMessageCallback()、setConnectionCallback();</li><li>启动server：server.start();</li><li>开启事件循环: loop.loop()。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Muduo库关键代码及思想&lt;/p&gt;
&lt;p&gt;Muduo库是基于Reactor模式实现的TCP网络编程库。Muduo库有三个核心组件支撑一个reactor实现 [&lt;strong&gt;持续&lt;/strong&gt;] 的 [&lt;strong&gt;监听&lt;/strong&gt;] 一组fd，并根据每个fd上</summary>
      
    
    
    
    
    <category term="网络编程" scheme="http://precipitation0224.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Reator网络编程模型</title>
    <link href="http://precipitation0224.github.io/2023/03/18/reactor/"/>
    <id>http://precipitation0224.github.io/2023/03/18/reactor/</id>
    <published>2023-03-18T10:59:51.000Z</published>
    <updated>2023-03-18T05:04:52.535Z</updated>
    
    <content type="html"><![CDATA[<p>Reator网络编程模型</p><p>首先介绍下Reactor这一网络编程模型，I&#x2F;O多路复用可以用作并发事件驱动(<strong>event-driven</strong>)程序的基础，即整个事件驱动模型是一个状态机，包含了状态(state), 输入事件(input-event), 状态转移(transition), 状态转移即状态到输入事件的一组映射。通过I&#x2F;O多路复用的技术检测事件的发生，并根据具体的事件(通常为读写)，进行不同的操作，即<strong>状态转移</strong>。</p><p>Reactor模式是一种典型的事件驱动的编程模型，Reactor逆置了程序处理的流程，其基本的思想即为Hollywood Principle— ‘Don’t call us, we’ll call you’.</p><p>Reactor事件处理机制为：主程序将事件以及对应事件处理的方法在Reactor上进行注册, 如果相应的事件发生，Reactor将会主动调用事件注册的接口，即 <strong>回调函数</strong>. libevent即为封装了epoll并注册相应的事件(I&#x2F;O读写，时间事件，信号事件)以及回调函数，实现的事件驱动的框架。</p><p>Reactor事件处理机制的编程模型，在Redis中也得到了很好的运用，Redis中基于I&#x2F;O多路复用(mutiplexing) 开发Reactor事件处理机制，监听多个套接字的AE_READABLE读，AE_WRITABLE写事件。读事件绑定读操作和具体执行命令的操作函数，写事件绑定命令回复的操作函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">register_handler</span><span class="hljs-params">(EventHandler *pHandler, <span class="hljs-type">int</span> event)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">remove_handler</span><span class="hljs-params">(EventHandler *pHandler, <span class="hljs-type">int</span> event)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_events</span><span class="hljs-params">(timeval *ptv)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件管理的接口，内部使用event demultiplexer注册，注销事件；并运行事件循环，当有事件进入”就绪”状态时，调用注册事件的回调函数处理事件。event demultiplexer通常是由操作系统提供的I&#x2F;O多路复用的机制，例如select, epoll. 程序首先将handler（事件源）以及对应的事件注册到event demultiplexer上；当有事件到达时，event demultiplexer就会发出通知，通知Reactor调用事件处理程序进行处理。event handler事件处理程序提供了一组接口，在Reactor相应的事件发生时调用，执行相应的事件处理，通常会绑定一个有效的handler。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event_Handler</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// events maybe read/write/timeout/close .etc</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle_events</span><span class="hljs-params">(<span class="hljs-type">int</span> events)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> HANDLE <span class="hljs-title">get_handle</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件驱动的一般模型，利用linux select epoll模型，注册相应的回调函数对应不同的事件，根据I&#x2F;O多路复用的机制，实现高并发，高可扩展性。</p><p><em><strong>flow：</strong></em></p><ol><li>registerhandler() </li><li>handle_events()</li><li>select()</li><li>connect()</li><li>handleevent()</li><li>accept()</li><li>create()</li><li>registerhandler()</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EventType;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Epoll</span> &#123;<br>    <span class="hljs-comment">// 封装了epoll I/O 多路复用的机制, Event demultiplexer</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NO_FLAGS = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_INDEFINITELY = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EVENTS = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-built_in">Epoll</span>() &#123;<br>        fileDescriptor = <span class="hljs-built_in">epoll_create1</span>(NO_FLAGS);<br>        event.data.fd = STDIN_FILENO;<br>        <span class="hljs-comment">// 设置epoll event 为EPOLLIN(对应文件描述符可读)， EPOLLPRI(对应文件描述符有紧急事件可读)</span><br>        event.events = EPOLLIN | EPOLLPRI;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">epoll_wait</span>(fileDescriptor, events.<span class="hljs-built_in">data</span>(), MAX_EVENTS, BLOCK_INDEFINITELY);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">control</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">epoll_ctl</span>(fileDescriptor, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Epoll</span>() &#123;<br>        <span class="hljs-built_in">close</span>(fileDescriptor);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> fileDescriptor;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span><br>            event;<br>    std::array&lt;epoll_event, MAX_EVENTS&gt; events&#123;&#125;;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHandler</span> &#123;<br>    <span class="hljs-comment">// Event Handler</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handle_event</span><span class="hljs-params">(EventType et)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Event Handler: &quot;</span> &lt;&lt; et &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> &#123;<br>    <span class="hljs-comment">// Dispatcher</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Reactor</span>() &#123;<br>        epoll.<span class="hljs-built_in">control</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//注册对应的回调函数到handlers中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addHandler</span><span class="hljs-params">(std::string event, EventHandler callback)</span> </span>&#123;<br>        handlers.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(event), std::<span class="hljs-built_in">move</span>(callback));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> numberOfEvents = <span class="hljs-built_in">wait</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numberOfEvents; ++i) &#123;<br>                std::string input;<br>                std::<span class="hljs-built_in">getline</span>(std::cin, input);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 根据的具体的事件去找对应的handler，并执行相应的操作</span><br>                    handlers.<span class="hljs-built_in">at</span>(input).<span class="hljs-built_in">handle_event</span>(<span class="hljs-built_in">EventType</span>(i));<br>                &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::out_of_range &amp;e) &#123;<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;no  handler for &quot;</span> &lt;&lt; input &lt;&lt; std::endl;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// handlers Table, 存储事件以及其对应的handlers</span><br>    std::unordered_map&lt;std::string, EventHandler&gt; handlers&#123;&#125;;<br>    Epoll epoll;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> numberOfEvents = epoll.<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-keyword">return</span> numberOfEvents;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Reactor reactor;<br><br>    reactor.<span class="hljs-built_in">addHandler</span>(<span class="hljs-string">&quot;a&quot;</span>, EventHandler&#123;&#125;);<br>    reactor.<span class="hljs-built_in">addHandler</span>(<span class="hljs-string">&quot;b&quot;</span>, EventHandler&#123;&#125;);<br>    reactor.<span class="hljs-built_in">run</span>();<br>&#125; <br></code></pre></td></tr></table></figure><p>总结：reactor本质上就是在linux线程等待IO时，CPU切换到其他线程执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Reator网络编程模型&lt;/p&gt;
&lt;p&gt;首先介绍下Reactor这一网络编程模型，I&amp;#x2F;O多路复用可以用作并发事件驱动(&lt;strong&gt;event-driven&lt;/strong&gt;)程序的基础，即整个事件驱动模型是一个状态机，包含了状态(state), 输入事件(in</summary>
      
    
    
    
    
    <category term="网络编程" scheme="http://precipitation0224.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>预防sql注入</title>
    <link href="http://precipitation0224.github.io/2023/03/16/sql/"/>
    <id>http://precipitation0224.github.io/2023/03/16/sql/</id>
    <published>2023-03-16T10:35:06.000Z</published>
    <updated>2023-03-16T02:36:09.936Z</updated>
    
    <content type="html"><![CDATA[<p>11、避免sql注入</p><p><em><strong>SQL 注入（SQL Injection）</strong></em>，是 Web 开发中最常见的一种安全漏洞。</p><p>可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p><ol><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li><li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li><li>对进入数据库的特殊字符进行转义处理，或编码转换</li><li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li><li>发布前，利用工具进行 SQL 注入检测</li><li>报错信息不要包含 SQL 信息输出到 Web 页面</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11、避免sql注入&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;SQL 注入（SQL Injection）&lt;/strong&gt;&lt;/em&gt;，是 Web 开发中最常见的一种安全漏洞。&lt;/p&gt;
&lt;p&gt;可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>虚函数动态绑定</title>
    <link href="http://precipitation0224.github.io/2023/03/16/virtualpointer/"/>
    <id>http://precipitation0224.github.io/2023/03/16/virtualpointer/</id>
    <published>2023-03-15T20:01:55.000Z</published>
    <updated>2023-03-15T12:07:06.448Z</updated>
    
    <content type="html"><![CDATA[<p>14、虚函数如何实现动态转发，每个类都有虚函数表吗</p><p>虚函数是在某基类中声明为<em><strong>virtual</strong></em>并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。</p><p>函数是通过<strong>虚函数表</strong>来实现的。每一个含有虚函数的类，都会有一个虚函数表用来存放虚函数的地址，同时类会有一个<strong>虚表指针</strong>去指向虚函数表的首地址,<strong>对象的首地址就存放着虚表指针</strong>。</p><p><strong>虚函数表：</strong>要讲清楚动态绑定的流程，首先需要了解清楚类里面虚函数表的定义，虚函数表是记录虚函数入口地址的一串数组（实际是一个函数指针数组），它只存在于定义了虚函数的类里面，这里给出一个例子来展示类中虚函数表的存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//空类的大小为1</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//大小为4，成员变量会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为4，非虚函数不会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为16，定义虚函数会增加类的大小，但是这个增加不是虚函数带来了的，而是指向虚函数表的指针所占的空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//大小为16，从这儿可以看到，类里面的多个虚函数都维护在一个虚函数表里面，只有一个指向虚函数表的指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(C)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(D)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(E)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//实际上，虚函数不占用类对象的存储空间，</span><br><span class="hljs-comment">//所以含有一个以上的虚函数的类对象大小与仅含一个虚函数大小相同</span><br><span class="hljs-comment">//同时，针对每个类，只维护一个【虚函数表（函数指针数组数组）】</span><br><span class="hljs-comment">//用于存放该类中虚函数的地址，每个【含一个及以上虚函数的对象都会含有一个指向该类虚函数表的指针】。</span><br></code></pre></td></tr></table></figure><p><strong>动态绑定虚函数工作原理：</strong> 前面提到，每一个类会为所有虚函数数维护一个虚函数表，并且有一个指针指向这个表的首地址，这个虚函数表记录着所有的虚函数的入口地址。那么在动态绑定时，编译器是如何给基类指针返回一个正确的函数入口地址，这里给出一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> a1;<br>        <span class="hljs-type">int</span> a2;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::display()&quot;</span>&lt;&lt;endl;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::clone()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::init()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> B&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::execute()&quot;</span>&lt;&lt;endl;&#125; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;C::init()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-keyword">override</span><br></code></pre></td></tr></table></figure><p>这里给出A,B,C三个类的内存情况，如下图。可以得出这么几个结论：</p><ol><li>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的</li><li>同名虚函数在基类和派生类中的虚函数表中，索引是一致的，如下图，A,B,C的display的索引都是0</li><li>派生类中，一旦对基类中的虚函数进行了覆盖，那么派生类的虚函数表中响应函数的入口地址会被替换成覆盖后的函数的地址。</li><li>一旦有新的虚函数定义，会加入到当前虚函数表的末端。</li></ol><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><em><strong>reference link</strong></em>: <a href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;14、虚函数如何实现动态转发，每个类都有虚函数表吗&lt;/p&gt;
&lt;p&gt;虚函数是在某基类中声明为&lt;em&gt;&lt;strong&gt;virtual&lt;/strong&gt;&lt;/em&gt;并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。&lt;/p&gt;
&lt;p&gt;函数是通过&lt;strong&gt;虚函数</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>http缺陷，tls和QUIC</title>
    <link href="http://precipitation0224.github.io/2023/03/16/tls/"/>
    <id>http://precipitation0224.github.io/2023/03/16/tls/</id>
    <published>2023-03-15T19:53:04.000Z</published>
    <updated>2023-03-15T11:53:49.191Z</updated>
    
    <content type="html"><![CDATA[<p>10、http安全保证，tls，如何握手</p><p>HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：</p><ol><li>通信使用明文，内容可能被窃听。</li><li>不验证通信方的身份，因此有可能遭到伪装。</li><li>无法验证报文的完整性，所以有可能被篡改。</li><li>传统的HTTP请求过程都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求和响应被黑客拦截，并且里面含有密码等敏感数据的话，会非常危险。</li></ol><p><em><strong>QUIC</strong></em> 协议 (RFC 9000) 旨在提高 Web 性能并减少访问延迟，同时保持通信机密。 一种基本方法是通过将 QUIC 握手与 TLS 1.3 握手集成并将多个 QUIC 数据包合并到一个 UDP 数据报中来减少初始往返时间 (RTT)。</p><p>总的来说，QUIC 相比于 HTTP&#x2F;2.0 来说，具有下面这些优势：</p><ul><li>使用 UDP 协议，不需要三次连接进行握手，而且也会缩短 TLS 建立连接的时间。</li><li>解决了队头阻塞问题</li><li>实现动态可插拔，在应用层实现了拥塞控制算法，可以随时切换。</li><li>报文头和报文体分别进行认证和加密处理，保障安全性。</li><li>连接能够平滑迁移</li></ul><p>连接平滑迁移指的是，你的手机或者移动设备在 4G 信号下和 WiFi 等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;10、http安全保证，tls，如何握手&lt;/p&gt;
&lt;p&gt;HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通信使用明文，内容可能被窃听。&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>C++中的unicode</title>
    <link href="http://precipitation0224.github.io/2023/03/16/C-%E4%B8%AD%E7%9A%84unicode/"/>
    <id>http://precipitation0224.github.io/2023/03/16/C-%E4%B8%AD%E7%9A%84unicode/</id>
    <published>2023-03-15T18:50:57.000Z</published>
    <updated>2023-03-15T10:51:38.295Z</updated>
    
    <content type="html"><![CDATA[<p>7、utf8，utf16区别，c++用哪个</p><p><strong>UTF-8(8-bit Unicode Transformation Format)</strong></p><p>UTF-8是一种变长编码，对于一个Unicode的字符被编码成1至4个字节</p><p>优点:<br>1.向后兼容ASCII编码；<br>2.没有字节序(大小端)的问题适合网络传输；<br>3.存储英文和拉丁文等字符非常节省存储空间。<br>缺点:<br>1.变长编码不利于文本处理；<br>2.对于CJK等文字比较浪费存储空间。</p><p><strong>UTF-16(16-bit Unicode Transformation Format)</strong></p><p>UTF-16也是一种变长编码，对于一个Unicode字符被编码成1至2个码元，每个码元为16位</p><p>优点:<br>1.绝大部分的文字都可以用两个字节编码，对于CJK文字是比较节省空间的；<br>2.文本处理比UTF-8方便得多。<br>缺点:<br>1.存储和传输需要考虑字节序的问题；<br>2.不兼容ASCII。</p><p><strong>USL（Unicode String Literals）</strong>是C++11对Unicode提供的语言级别的支持。在C++11之前C++中有个<strong>wchar_t</strong>的类型用于存储宽字符（Wide-Character）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UTFCONVERT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UTFCONVERT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br> <br><span class="hljs-comment">// 从UTF16编码字符串构建，需要带BOM标记</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 从UTF16 LE编码的字符串创建</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16le_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 从UTF16BE编码字符串创建</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16be_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 获取转换为UTF-16 LE编码的字符串</span><br><span class="hljs-function">std::u16string <span class="hljs-title">utf8_to_utf16le</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; u8str, <span class="hljs-type">bool</span> addbom = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span>* ok = <span class="hljs-literal">NULL</span>)</span></span>;<br> <br><span class="hljs-comment">// 获取转换为UTF-16 BE的字符串</span><br><span class="hljs-function">std::u16string <span class="hljs-title">utf8_to_utf16be</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; u8str, <span class="hljs-type">bool</span> addbom = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span>* ok = <span class="hljs-literal">NULL</span>)</span></span>;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//! __UTFCONVERT_H__</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;7、utf8，utf16区别，c++用哪个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8(8-bit Unicode Transformation Format)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTF-8是一种变长编码，对于一个Unicode的字符被编码成1至4个字节&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>http 1.0/2/3优化</title>
    <link href="http://precipitation0224.github.io/2023/03/16/1-0-2-3%E4%BC%98%E5%8C%96/"/>
    <id>http://precipitation0224.github.io/2023/03/16/1-0-2-3%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-15T18:43:59.000Z</published>
    <updated>2023-03-15T10:52:41.760Z</updated>
    
    <content type="html"><![CDATA[<p>6、http1.0&#x2F;1 2 3优化</p><p><em><strong>HTTP1.0</strong></em></p><p>1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。</p><p>浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪也每个客户单，也不记录过去的请求（无状态）。</p><p>这种无状态性可以借助<strong>cookie&#x2F;session</strong>机制来做身份认证和状态记录。</p><p>无法复用连接</p><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p><p>队头阻塞（head of line blocking）</p><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p><p><em><strong>HTTP 1.1</strong></em></p><ul><li>长连接，流水线，使用connection:keep-alive使用长连接</li><li>请求管道化</li><li>增加缓存处理（新的字段如cache-control）</li><li>增加Host字段，支持断点传输等</li><li>由于长连接会给服务器造成压力</li></ul><p><em><strong>HTTP 2.0</strong></em></p><ul><li>二进制分帧</li><li>头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小</li><li>多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求</li><li>服务器推送（Sever push）</li></ul><p><em><strong>HTTP 3.0</strong></em></p><ul><li>基于google的QUIC协议，而quic协议是使用udp实现的</li><li>减少了tcp三次握手时间，以及tls握手时间</li><li>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题</li><li>优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗</li><li>连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接</li><li>更合适的流量控制</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;6、http1.0&amp;#x2F;1 2 3优化&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;HTTP1.0&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。&lt;/p&gt;
&lt;p&gt;浏览器每次</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>浮点数和MD5,Base64</title>
    <link href="http://precipitation0224.github.io/2023/03/16/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/"/>
    <id>http://precipitation0224.github.io/2023/03/16/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/</id>
    <published>2023-03-15T18:32:32.000Z</published>
    <updated>2023-03-15T10:34:22.935Z</updated>
    
    <content type="html"><![CDATA[<p>4、浮点数的存储方式</p><ol><li><p>符号位：‘+’存储为0，‘-’存储为1</p></li><li><p>将数字转化成二进制数</p></li><li><p>将二进制数规范化为 1.xxxxxxxx*2^n</p></li><li><p>将n转化为指数（+127） 尾数xxxx后面补零</p></li></ol><p>5、介绍MD5、Base64</p><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。md5运算结果是一个固定长度为128位的二进制数，经过一系列的运算得到32个16进制数。</p><p>Base64是一种使用64基的位置计数法。它使用2的最大次方来代表仅可打印的ASCII字符。这使它可用来作为电子邮件的传输编码。在Base64中的变量使用字符A-Z、a-z和0-9，这样共有62个字符，用来作为开始的64个数字，最后两个用来作为数字的符号在不同的系统中而不同。一些如unencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。</p><p>MD5加密算法是不可逆的，base64加密算法是可逆的；MD5加密算法是不可逆的，base64加密算法是可逆的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;4、浮点数的存储方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;符号位：‘+’存储为0，‘-’存储为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将数字转化成二进制数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将二进制数规范化为 1.xxxxxxxx*2^n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将n转</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>string的缺陷和指针选择</title>
    <link href="http://precipitation0224.github.io/2023/03/15/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/"/>
    <id>http://precipitation0224.github.io/2023/03/15/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/</id>
    <published>2023-03-15T13:07:29.000Z</published>
    <updated>2023-03-15T05:08:01.595Z</updated>
    
    <content type="html"><![CDATA[<p>2、std::string的缺陷</p><p>最大的缺点是 std::string 是「字节串」而非「字符串」</p><ol><li>它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；</li><li>不能很好的处理宽字节的字符；</li><li>没有足够多的好用的函数，没有format格式输出，要借助要用stdio.h头文件里的 sprintf 函数。</li></ol><p>3、智能指针和原生指针的开销</p><p><strong>泛型指针：</strong></p><p>泛型指针有多种含义。1) 指void*指针，可以指向任意数据类型，因此具有“泛型”含义。2) 指具有指针特性的泛型数据结构，包含泛型的迭代器、智能指针等。 广义的迭代器是一种不透明指针，能够实现遍历访问操作。通常所说的迭代器是指狭义的迭代器，即基于C++的STL中基于泛型的iterator_traits实现的类的实例。总体来说，泛型指针和迭代器是两个不同的概念，其中的交集则是通常提到的迭代器类。</p><p><strong>原生指针：</strong></p><p>原生指针就是普通指针， 定义类似：类型 <em>变量名（int <em>p）;相反的若是一个类重载了‘</em>’和‘-&gt;’的运算符，能够像指针同样用‘</em>’和‘-&gt;’操做，就不是原生的，如iterator等。说“原生”是指“最简朴最基本的那一种”。因为现在很多东西都抽象化理论化了，所以“以前的那种最简朴最基本的指针”只是一个抽象概念（比如iterator）的表现形式之一。</p><p>c++的原生指针又可以分为普通指针，成员指针，函数指针。</p><p><strong>智能指针：</strong></p><p>智能指针是c++2.0的新特性之一，其最大的特点在于其结合了指针和对象构造析构的优点RAII，使得其在其生存期结束时可以及时释放其所管理的资源（动态内存分配得到的资源）。由于 C++ 语言没有自动内存回收机制，程序员每次得自己处理内存相关问题，但用智能指针便可以有效缓解这类问题。 一般是把指针封装到一个称之为智能指针类中，这个类中另外还封装了一个使用计数器，对指针的复制等操作将导致该计数器的值加1，对指针的delete操作则会减1，值为0时，指针为NULL。下面是智能指针的选择。</p><p>（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括三种：</p><ol><li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li><li>两个对象包含都指向第三个对象的指针；</li><li>STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</li></ol><p>（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2、std::string的缺陷&lt;/p&gt;
&lt;p&gt;最大的缺点是 std::string 是「字节串」而非「字符串」&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>两道基础算法</title>
    <link href="http://precipitation0224.github.io/2023/03/15/%E4%B8%A4%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <id>http://precipitation0224.github.io/2023/03/15/%E4%B8%A4%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-15T10:59:52.000Z</published>
    <updated>2023-03-15T03:02:22.158Z</updated>
    
    <content type="html"><![CDATA[<p>16、Q1：整数与ip地址的转换；Q2：小q第一天挖11币，第二天比前一天少一个币，以此类推，但休息一天又可以挖到11币,问第n天能挖多少币</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* ip转无符号数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">ipToInt</span><span class="hljs-params">(string ip)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = ip.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; ipList;<br>    <span class="hljs-comment">//split</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; l &amp;&amp; ip[j] != <span class="hljs-string">&#x27;.&#x27;</span>) j++;<br>        ipList.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(ip.<span class="hljs-built_in">substr</span>(i, j - i)));<br>        i = j;<br>    &#125;<br>    <span class="hljs-type">int</span> n = ipList.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">unsigned</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res = res &lt;&lt; <span class="hljs-number">8</span> | ipList[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 无符号数转ip</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">intToIp</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> num)</span> </span>&#123;<br>    vector&lt;string&gt; ipList;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>        string seg = <span class="hljs-built_in">to_string</span>(num &amp; <span class="hljs-number">255</span>);<br>        ipList.<span class="hljs-built_in">push_back</span>(seg);<br>        num = num &gt;&gt; <span class="hljs-number">8</span>;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ipList.<span class="hljs-built_in">begin</span>(), ipList.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>) res += ipList[i];<br>        <span class="hljs-keyword">else</span> res += ipList[i] + <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 递减累和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addArr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        res += n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*小q挖币</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qCoin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">1</span>);<br>    dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">2</span>);<br>    dp[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">3</span>);<br>    dp[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">4</span>);<br>    dp[<span class="hljs-number">6</span>] = <span class="hljs-number">6</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> dp[n];<br>    <span class="hljs-comment">// 周期循环的思想</span><br>    <span class="hljs-type">int</span> times = n / <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> tail = n % <span class="hljs-number">6</span>;<br>dp[times*<span class="hljs-number">6</span>] = times*dp[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">if</span>(tail==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[times*<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tail;++i) &#123;<br>        dp[times*<span class="hljs-number">6</span>+i] = dp[times*<span class="hljs-number">6</span>] + dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;16、Q1：整数与ip地址的转换；Q2：小q第一天挖11币，第二天比前一天少一个币，以此类推，但休息一天又可以挖到11币,问第n天能挖多少币&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>C++11知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/15/cpp11%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/15/cpp11%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-15T10:29:13.000Z</published>
    <updated>2023-03-15T10:54:38.534Z</updated>
    
    <content type="html"><![CDATA[<p>1、c++11的一些特性</p><p><em><strong>类型推导</strong></em>——C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p><p>其中有两个关键字：</p><ul><li><strong>auto</strong>：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">auto a = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> boost::typeindex::type_id_with_cur&lt;decltype(a)&gt;().pretty_name() = int<br></code></pre></td></tr></table></figure><ul><li><strong>decltype</strong>：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;i = <span class="hljs-number">1</span>;<span class="hljs-keyword">decltype</span>(i) b = <span class="hljs-number">2</span>; <span class="hljs-comment">// boost::typeindex::type_id_with_cur&lt;decltype(b)&gt;().pretty_name() = const int&amp;</span><br></code></pre></td></tr></table></figure><p><em><strong>左值右值</strong></em>——复制构造和移动构造，空间占用堆内存是否拷贝，如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。</p><p>std::move函数可以将左值转换为右值引用，减少了不必要的拷贝操作。</p><p><code>std::string str = &quot;Hello&quot;;std::vector&lt;string&gt; vec;vec.push_back(std::move(str)); // str==&quot;&quot;;</code><br>尽可能地<em><strong>列表初始化</strong></em></p><p><em><strong>std::function和lambda表达式</strong></em></p><p>可调用对象满足一点即可：</p><ul><li><p>是一个函数指针</p></li><li><p>是一个具有operator()成员函数的类对象(传说中的仿函数)，lambda表达式</p></li><li><p>是一个可被转换为函数指针的类对象</p></li><li><p>是一个类成员(函数)指针</p></li><li><p>bind表达式或其它函数对象</p></li></ul><p>function是上面这种可调用对象的封装器，可以把std::function看做一个函数对象，用于表示函数这个抽象概念。std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空，调用空的std::function的目标会抛出std::bad_function_call异常。</p><p>lambda表达式可以说是c++11引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> f1 = [=]()&#123; <span class="hljs-keyword">return</span> a; &#125;; <span class="hljs-comment">// 值捕获a</span><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">auto</span> f2 = [=]() &#123; <span class="hljs-keyword">return</span> a++; &#125;; <span class="hljs-comment">// 修改按值捕获的外部变量，error</span><br><span class="hljs-keyword">auto</span> f3 = [=]() <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> a++; &#125;;<br></code></pre></td></tr></table></figure><p><em><strong>default</strong></em>默认构造函数，这就不会让编译器隐式生成默认构造函数</p><p><em><strong>nullptr</strong></em>是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。</p><p><em><strong>final和override</strong></em>，其中final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><p><em><strong>enum class</strong></em>带作用域的枚举代码，使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AColor</span> &#123;<br>    kRed,<br>    kGreen,<br>    kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BColor</span> &#123;<br>    kWhite,<br>    kBlack,<br>    kYellow<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">AColorc</span> &#123;<br>    kRed,<br>    kGreen,<br>    kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">BColorc</span> &#123;<br>    kWhite,<br>    kBlack,<br>    kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (kRed == kWhite) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (AColorc::kRed == BColorc::kWhite) &#123; <span class="hljs-comment">// 编译失败</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>constexpr</strong></em>用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：</p><p>两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、c++11的一些特性&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;类型推导&lt;/strong&gt;&lt;/em&gt;——C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。&lt;/p&gt;
&lt;p&gt;其中有两个关键字：&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="interview" scheme="http://precipitation0224.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>thoughts</title>
    <link href="http://precipitation0224.github.io/2023/03/15/thoughts/"/>
    <id>http://precipitation0224.github.io/2023/03/15/thoughts/</id>
    <published>2023-03-14T20:20:44.000Z</published>
    <updated>2023-03-14T12:21:18.949Z</updated>
    
    <content type="html"><![CDATA[<p>修bug真的是好烦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修bug真的是好烦！&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="my os" scheme="http://precipitation0224.github.io/tags/my-os/"/>
    
  </entry>
  
  <entry>
    <title>Tcpip卷一协议知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:07:10.000Z</published>
    <updated>2023-03-14T08:03:56.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一章：概述</strong></p><p>1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层</p><p>2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，port用于tcp和udp的逻辑号码</p><p><strong>第二章：数据链路层</strong></p><p>1、ARP：ip地址转mac地址，以太网（网卡）协议，最大传输单元MTU，IP数据报过大则分片，环回接口（loopback）即本地</p><p><strong>第三章：IP协议、ARP协议</strong></p><p>1、IP协议作为核心，但其不可靠，可靠交托于上层协议，IP协议头包含，版本、首部长度、服务类型、字节数、标识、标志、片偏移、生存时间（tracerounter工作原理）、协议、首部校验和、源IP地址、目的IP地址、其他选项</p><p>2、子网寻址，IP地址等价于网络号+（子网号+）主机号，通过高速缓存表自查再广播，有则响应</p><p><strong>第四章：ICMP协议、ping和Traceroute</strong></p><p>1、IP不保证可靠，ICMP保证送达；some errors：主机不可达，路由不可达，给主机一个改错的机会，ICMP数据包由8bit错误类型，8bit代码和16bit校验和组成</p><p>2、ping声纳定位，类型码为0发出请求，收到请求的主机用类型码8回复，traceroute，解决ping的ip头限制问题，问udp是否到达主机，目的主机说端口不可达（port num&gt;30000）</p><p><strong>第五章：IP选路、动态选路</strong></p><p>1、5种flags，路由可用U，路由到网关G，路由到主机H，创建重定向报文D，路由被重定向报文修改M</p><p>2、动态选路协议，核心路由表（合适的网络），选择路由的协议，内部网关协议（IGP），OSPF取代RIP，两者都为代表</p><p>3、unix系统上通常有路由守护程序routed，另一个叫gate，RIP定义域RFC1058中，作为UDP的上层协议，以hop为计数器，即走过多少路由</p><p>4、对已知路由器发送rip请求报文，其他路由完整表；收到请求交表；接受回应并更新自己的路由表，使用小hop数；30s更新路由表，其弊端是无子网的概念，环路危险，hop限制网络大小</p><p><strong>第六章：UDP协议</strong></p><p>1、UDP协议头，包含了端口号、检验和、UDP长度</p><p>2、UDP和TCP设计伪首部来计算检验和，两次检查是否到达目的地，IP分片是根据MTU来，UDP发送前先要发送ARP以获得目的主机的MAC地址，UDP第一个分片发出ARP，分片等待</p><p>3、接受主机会给授予主机发ICMP处理不下报文，服务器泛化广播能力，服务器根据客户IP地址和端口号判断数据包合法不，并且服务器应该限制本地IP地址，依次绑定自己到网络接口的某一个端口上</p><p><strong>第七章：广播和多播、IGMP协议</strong></p><p>1、数据链路层数据头里具体的目的地址，以太网是MAC地址，路由即可定向单播，多播组是D类</p><p>2、广播和多播性质类似，路由器将数据放到局域网里，网卡对这些数据进行过滤，主机运行IP进程时，给网卡绑定虚拟多播IP地址，网卡让其进来从而实现通信，主机内核轻松，网卡忙点</p><p>3、IGMP让其他需要知道自己处于哪个多播组的主机和路由器知道自己的状态，多播组主机，多播组路由器，接受主机通过网卡过滤，路由器决定几个多播组</p><p><strong>第八章：DNS域名系统</strong></p><p>1、一个独立管理的DNS子树叫做zone，如二级域名，本身作为一个分布式数据库，转发至根服务器，自上而下转发查询，自带高速缓存，方便下次查询</p><p>2、DNS采取域名对应表查询，in-addr.arpa，大多数查询时UDP查询，TCP查询仅当查询数据产生了数据阶段，运用TCP的分片能力进行数据传输，辅服务器要拿主服务器的zone信息的时候</p><p><strong>第九章：TCP协议概述</strong></p><p>1、TCP面向连接，有ICMP差错检测报文，应用数据被分割成TCP满意的块，数据报长度保持不变，TCP发出段，启动一个定时器，超时重传</p><p>2、TCP保持首部和数据的校验和，记端到端的校验和，检测数据在传输过程的变化，IP数据报，TCP数据报都可能失序，TCP需要重排后交付应用层</p><p>3、TCP流量控制，防止接收端缓冲区溢出，可靠不得到不停止发送，TCP首部含更多信息</p><p><strong>第十章：TCP连接的建立与中止</strong></p><p>1、客户端向服务器申请开启某一端口，用于SYN段等于1的TCP报文，服务器端发回一个ACK报文，TCP全双工可以同时发送和接收，三次握手四次挥手的解释</p><p>2、建立连接确认对方的最大报文长度（MSS）以便于通信，SYN的长度是MTU减去固定IP首部和TCP首部的长度</p><p>3、客户端状态流程：CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</p><p>4、服务器状态流程：CLOSED-&gt;LISTEN-&gt;SYN-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED</p><p>5、MSL平静时间概念，应用程序无法使用插口，半关闭状态，应用程序有接受数据的能力，但无法发送数据，等应用层来决定关闭这个状态</p><p>6、UDP仅需输入队列，TCP对于每一个连接都要建立独立的进程，以保证对话的独立性，呼入连接请求队列，解释了各种TCP服务器都有一个最大连接数的原因，根据主机IP和端口号进行区分</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676452143517-845e2589-f3cb-427f-93d4-c36417850a25.png" alt="img"><a href="http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png">http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png</a></p><p><strong>第十一章：TCP交互数据流、成块数据流</strong></p><p>1、以TCP协议为基础，建立在之上的协议有telnet、ssh、ftp、http等，根据数据的吞吐量又分为两大类：第一是交互数据类型，如telnet、ssh，做小流量的交换，敲击键盘回显文字，第二是数据成块类型，如ttp，要求TCP尽量运输数据，把数据吞吐量做大，提高效率</p><p>2、TCP交互数据流，就要想办法去降低网络负担，lo接口进行telnet通信，如按键过程，发送按键数据-服务器发送按键数据的ack-服务器端发送回显数据-客户端发送回显数据的ack，流量是40bit+41bit+41bit+40bit</p><p>3、两种策略，捎带ACK的发送方式，数据报不立刻处理，等待主机还有发送给远程主机的TCP数据报，时间一般设为200ms，另一种策略是Nagle算法，如BBS论坛帖子，数据稍等片刻一下就传过来了，TCP缓冲区只有一个TCP数据报，不断收集后来的数据，整合成一个大的数据报，等待响应主机的ACK报文，TCP_NODELAY来关闭此算法</p><p>4、TCP成块数据流，ftp接受延迟，因为其数据多，TCP协议中有16bit表示窗口的大小。发送端连续发送数据尽可能地填满接收端的缓冲区，接收端只需要发送一个ACK就好了，累积特性，减少了发送端和接受端的负担</p><p>5、滑动窗口本质是描述接收端TCP数据报缓冲区大小的数据，发送端以此发送数据，滑动窗口协议的三个术语，窗口合拢，窗口张开，窗口收缩，发送窗口范围里面的数据，窗口的大小通过socket来制定，4096非理想，16384可以使得吞吐量大大增加</p><p>6、数据拥塞，前面的策略用于局域网中，但在广域网中有问题，产生在slip低速链路的数据拥塞问题，TCP的解决方案是发送方确认连接双方的线路的数据最大吞吐量是多少，即拥塞窗口，其原理是TCP发送方发送一个数据报，等待对方的回应，得到回应后将窗口大小加倍，连续发送两个数据报，等到对方回应，再加倍，发送更多的数据报，知道超时报错，发送端就能知道通信双方线路的承载能力，即拥塞窗口的大小，传数据速度慢慢起来的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一章：概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层&lt;/p&gt;
&lt;p&gt;2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>STL设计知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/STL%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/STL%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:06:54.000Z</published>
    <updated>2023-03-14T07:10:20.006Z</updated>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/103223914">https://blog.csdn.net/fengbingchun/article/details/103223914</a></p><ol><li>慎重选择容器类型，序列容器，关联容器，非STL容器，对STL进行分类，连续内存容器(vector、string、deque)和基于节点的容器(list、forward_list)，容器内部的引用计数技术，rope基于引用计数，本身是用可持久化平衡树实现的重型string<img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1677981449440-89bff10a-e505-4057-bc6d-49ae3aad5afa.png" alt="img"></li><li>STL本身是泛化，不写独立于容器类型的代码，数组泛化为以其包含对象类型为参数的容器，函数泛化为以其使用的迭代器类型为参数的算法，将容器隐藏到一个类中，以减少通过类接口与容器相关的信息</li><li>确保容器中的对象拷贝正确高效，对象是其拷贝在容器中，取出对象也是对象的拷贝，存在继承关系时，拷贝会导致剥离，防止子对象特有信息丢失就是使容器包含指针</li><li>调用empty检测size()是否为0</li><li>区间成员函数优先于与之对应的单元素成员函数，用两个迭代器确定成员操作所执行的区间，推荐assign和insert，清楚表达意图，表现更高效率</li><li>视情况使用命名迭代器对象</li><li>容器中包含new指针，在析构前delete掉指针，为避免资源泄漏，必须用引用计数计数形式的智能指针对象代替指针</li><li>切勿创建包含auto_ptr的容器对象，创建后即转移对象的所有权，包含智能指针没问题</li><li>慎用选择删除元素的方法，对于vector、string或deque这样的容器，erase-remove是删除特定值元素的最好办法，list对应list::remove，关联map这样的容器使用erase，判别式加if，遍历容器元素，返回值更新迭代器，关联容器则后缀递增</li><li>分配子的约定和限制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reference link: &lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/103223914&quot;&gt;https://blog.csdn.net/fengbingchun/article/details</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
  <entry>
    <title>more-effective-c++知识总结</title>
    <link href="http://precipitation0224.github.io/2023/03/14/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://precipitation0224.github.io/2023/03/14/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-14T15:06:32.000Z</published>
    <updated>2023-03-14T07:09:55.322Z</updated>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/102990753">https://blog.csdn.net/fengbingchun/article/details/102990753</a></p><ol><li>指针和引用的区别，任何情况下都不能使用指向空值的引用，引用必须初始化</li><li>尽量使用C++风格的类型转换，static_cast、const_cast、dynamic_cast、reinterpret_cast，注意的是dynamic_cast是继承关系向下的类型转换</li><li>不要对数组使用多态，只要不从一个具体类派生出另一个具体类就好</li><li>避免无用的构造缺省函数，数组的raw memory分配可以避免内存的浪费，构造函数初始化对象，行为特性或数字相仿的对象被初始化为空值或不确定的值也是合理的，也有空容器，需要空间来容纳指针，实例化模板，模板的类型参数应该提供一个缺省构造函数</li><li>谨慎定义类型转换函数，有两种函数允许编译器进行隐式类型的转换，单参数构造函数和隐式类型转换运算符，构造函数使用explicit声明，编译器会拒绝为了隐式类型转换而调用构造函数</li><li>自增自减的前缀和后缀形式，处理用户定义的类型时，尽可能地使用前缀increment，只因效率高</li><li>不要重载&amp;&amp;，||和，操作符，解释是C++使用布尔表达式短路求值法，前部分判定后半部分不判了，分为全局重载和类内重载，函数参数地计算顺序不能被控制</li><li>理解不同含义的new和delete，即new operator和operator new的区别，作为内置的操作符，含义不能改变，功能分两部分，第一是分配足够的内存以容纳所需类型的对象，第二是调用构造函数初始化内存中的对象，operator new函数的返回值是void*，返回一个未初始化的指针，未初始化的内存，new用于堆上建立一个对象，分配内存然后定制operator new，再获得指针的内存里建立一个对象使用的是placement new，避免在内存中使用delete操作符</li><li>使用析构函数防止资源泄漏，不只是用于指针上，还可以用在其他资源的分配和释放上，资源应该被封装在一个对象里，智能指针就是基于此</li><li>在构造函数中防止资源泄漏，只有一个对象的构造函数完全运行完毕，对象才会被构造，构造函数try catch捕获所有的异常，用unique_ptr对象替代指针成员变量，就可以防止构造函数在异常时发生资源泄漏</li><li>禁止异常信息传递到析构函数外，第一是在异常传递的堆栈stack-unwinding过程，被terminate调用，第二是确保析构函数能完成任务</li><li>理解一个抛出一个异常与传递一个参数或调用一个虚函数之间的差异，程序的控制权最终还会返回到函数的调用处，异常的抛出不会返回到出现异常的地方，抛出的对象应该被复制，catch进行异常匹配有两种类型转换，第一是继承类和基类之间的转换，第二是允许类型指针转变成无类型指针，const void*捕获任意指针异常</li><li>通过引用捕获异常，有四个标准的额异常都不是指向对象的指针，bad_alloc，bad_cast，bad_typeid和bad_exception，分别对应的是不可分配，不可引用，不可操作空指针，unexception异常</li><li>审慎使用异常规格，函数抛出不在异常考虑的范围这样的异常，std::unexcepted调用std::terminate，然后再调用abort，从而避免了std::terminate</li><li>了解异常处理的系统开销，避免使用无用的try块</li><li>牢记80-20准则，即2成代码使用了8成的程序资源，2成代码耗用了8成的运行时间，2成代码使用了8成的内存，2成代码执行8成的磁盘访问，8成维护投入到2成代码上</li><li>考虑使用过lazy evaluation</li><li>分期摊还期望的计算，设计一个数据结构解决频繁运行的计算块，前面的lazy evaluation就是以此提高程序效率</li><li>理解临时对象的来源，未命名的临时对象在两种条件下产生，进行隐式类型转换和函数返回对象时使得函数调用成功</li><li>协助完成返回值优化，有些函数必须返回对象，这是它们的运行方法，C++允许编译器优化不出现的临时对象</li><li>通过重载避免隐式类型转换，重载运算符必须带有一个用户定义类型的参数，没有必要大量重载，除非效率上有相应的提升</li><li>考虑用运算符的赋值形式op&#x3D;来代替其单独形式op，确保operator的赋值形式与一个operator的单独形式存在正常的关系，后者+根据前者+&#x3D;来实现</li><li>考虑变更程序库，不同程序库在效率、可扩展性、移植性、类型安全和其它一些领域上蕴含着不同的设计理念</li><li>理解虚函数、多继承、虚基类和RTTI所需的代码，虚拟函数必须与调用函数的对象的动态类型一致，编译器使用vtbl和vptr，必须为包含虚函数的类留出vtbl空间，看不见的数据称为vptr，被编译器加在对象里，只有编译器知道，虚函数不能内联，内联的含义是指在编译期间用被调用的函数体来代替函数调用的指令，虚函数的虚体现在在运行时才知道调用的是哪一个函数，RTTI(运行时类型识别)能够帮助找到对象和类的有关信息，存储在type_info这个对象里，通过typeid操作符访问一个类的type_info对象</li><li>将构造函数和非成员函数虚拟化，虚拟构造函数返回一个指针，指向调用函数的对象的新拷贝，被派生类重定义的虚拟函数不用必须与基类的虚函数具有一样的返回类型</li><li>限制某个类所能产生的对象数量，阻止建立某个类的对象，方法是将该类的构造函数声明在类的private域中</li><li>要求或禁止在堆中产生对象，禁止用于调用new，利用new操作符总是调用operator new函数这点来达到目的，可声明为private</li><li>灵巧smart指针，使用到模板，应用领域有资源管理和重复代码任务的自动化，auto_ptr已在C++11抛弃，改用unique_ptr替代</li><li>引用计数，即允许多个有相同值的对象共享这个值的实现，两个动机，第一是简化跟踪堆中的对象的过程，一旦对象被new，就要记录对象的拥有者，所有者负责对对象进行delete，通过传递指针型参数将一个对象的所有权传递到另一个对象中，引用计数免除跟踪对象的所有权，第二是基于对象有相同的值，存储多次是无聊的，所以考虑让所有对象共享这个值的实现，节省内存</li><li>代理类，可以通过代理类实现二维数组，区分operator[]进行的操作是读还是写，proxy类可以完成三个行为，第一是多维数组，第二是左值右值的区分，第三是隐式类型转换的限制，缺点是proxy本身作为一个临时对象，必须被构造和析构</li><li>让函数根据一个以上的对象来决定怎么虚拟</li><li>在未来时态下开发程序，需要考虑到代码的可复用性、可维护性、健壮性以及环境移植性</li><li>将非尾端类设计为抽象类</li><li>如何在同一程序中混合使用C++和C，函数重载是C++的特性，extern C看作是声明这个函数是C写的一样进行调用，静态初始化，静态类对象和定义在全局的、命名空间中的文件体中的类对象构造函数通常在main被执行前被调用，动态内存分配建立在堆上，在同一程序下混合两者，有以下的指导原则：一是确保C++和C编译器产生兼容的obj文件，二是函数声明为extern C，三是只要可能就C++写main，四是勇敢delete释放new分配的内存，用free释放malloc分配的内存，五是将语言传递的东西限制在C编译的数据结构范围内</li><li>让自己习惯使用标准C++语言</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reference link: &lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/102990753&quot;&gt;https://blog.csdn.net/fengbingchun/article/details</summary>
      
    
    
    
    
    <category term="my notes" scheme="http://precipitation0224.github.io/tags/my-notes/"/>
    
  </entry>
  
</feed>
