<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yummy home</title>
  
  <subtitle>欢迎你来看看我呀</subtitle>
  <link href="http://precipitation0224.github.io/atom.xml" rel="self"/>
  
  <link href="http://precipitation0224.github.io/"/>
  <updated>2023-08-24T06:53:37.790Z</updated>
  <id>http://precipitation0224.github.io/</id>
  
  <author>
    <name>Yummy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据结构——Set实现</title>
    <link href="http://precipitation0224.github.io/2023/07/03/07-03-redis_Set/"/>
    <id>http://precipitation0224.github.io/2023/07/03/07-03-redis_Set/</id>
    <published>2023-07-03T15:28:38.000Z</published>
    <updated>2023-08-24T06:53:37.790Z</updated>
    
    <content type="html"><![CDATA[<p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p><p>每个 intset.h&#x2F;intset 结构表示一个整数集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br><br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br><br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br><br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];<br><br>&#125; intset;<br></code></pre></td></tr></table></figure><p>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p><p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p><p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</p><p>关于整数集合的总结：</p><ul><li>整数集合是集合键的底层实现之一。</li><li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li><li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li><li>整数集合只支持升级操作， 不支持降级操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;p&gt;整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 i</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://precipitation0224.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构——SortedSet实现</title>
    <link href="http://precipitation0224.github.io/2023/07/03/07-03-redis_SortedSet/"/>
    <id>http://precipitation0224.github.io/2023/07/03/07-03-redis_SortedSet/</id>
    <published>2023-07-03T15:28:38.000Z</published>
    <updated>2023-08-24T06:51:21.551Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。<br>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。</p><p>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。</p><p>Redis 的跳跃表由 redis.h&#x2F;zskiplistNode 和 redis.h&#x2F;zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p><p>跳跃表节点的实现由 redis.h&#x2F;zskiplistNode 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br><br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br><br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br><br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p>zskiplist 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br><br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br><br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p>关于跳跃表的总结：</p><ul><li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li><li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li><li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。&lt;br&gt;跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。在大部分情况下， 跳跃表的效率可以</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://precipitation0224.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构——Hash实现</title>
    <link href="http://precipitation0224.github.io/2023/07/03/07-03-redis_Hash/"/>
    <id>http://precipitation0224.github.io/2023/07/03/07-03-redis_Hash/</id>
    <published>2023-07-03T10:16:25.000Z</published>
    <updated>2023-08-24T06:45:56.754Z</updated>
    
    <content type="html"><![CDATA[<p>字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。其中 Key 是唯一的。类似 Java 的 Map。</p><p>Redis 字典所使用的哈希表由 dict.h&#x2F;dictht 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br><br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br><br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">// 总是等于 size - 1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br><br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br><br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p><p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br><br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-type">void</span> *key;<br><br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>    &#125; v;<br><br>    <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</p><p>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p><p>Redis 中的字典由 dict.h&#x2F;dict 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br><br>    <span class="hljs-comment">// 类型特定函数</span><br>    dictType *type;<br><br>    <span class="hljs-comment">// 私有数据</span><br>    <span class="hljs-type">void</span> *privdata;<br><br>    <span class="hljs-comment">// 哈希表</span><br>    dictht ht[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// rehash 索引</span><br>    <span class="hljs-comment">// 当 rehash 不在进行时，值为 -1</span><br>    <span class="hljs-type">int</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li><li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>当将一个新的键值对插入到字典中，需要计算索引值，Redis 计算索引值的方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="hljs-built_in">hash</span> = <span class="hljs-built_in">dict</span>-&gt;<span class="hljs-built_in">type</span>-&gt;hashFunction(key);<br><br><span class="hljs-comment"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="hljs-comment"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br>index = <span class="hljs-built_in">hash</span> &amp; <span class="hljs-built_in">dict</span>-&gt;ht[x].sizemask;<br></code></pre></td></tr></table></figure><p><strong>Redis 的字典实现的特性可以总结如下：</strong></p><ul><li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li><li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li><li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li><li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。其中 Key 是唯一的。类似 Java 的 Map。&lt;/p&gt;
&lt;p&gt;Redis 字典所使用</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://precipitation0224.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构——List实现</title>
    <link href="http://precipitation0224.github.io/2023/07/03/07-02-redis_List/"/>
    <id>http://precipitation0224.github.io/2023/07/03/07-02-redis_List/</id>
    <published>2023-07-02T22:16:25.000Z</published>
    <updated>2023-08-24T06:02:40.660Z</updated>
    
    <content type="html"><![CDATA[<p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在 Redis 中的应用非常广泛，比如 List 的底层实现之一链表，当一个 List 包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为 List 的底层实现。除了用作 List 的底层实现之外，发布与订阅、慢查询、监视器等动能也用到了链表， Redis 服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。<br>每个链表节点使用一个 adlist.h&#x2F;listNode 结构来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br><br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br><br>    <span class="hljs-comment">// 后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br><br>    <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-type">void</span> *value;<br><br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h&#x2F;list 来持有链表的话， 操作起来会更方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br><br>    <span class="hljs-comment">// 表头节点</span><br>    listNode *head;<br><br>    <span class="hljs-comment">// 表尾节点</span><br>    listNode *tail;<br><br>    <span class="hljs-comment">// 链表所包含的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br><br>    <span class="hljs-comment">// 节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br><br>    <span class="hljs-comment">// 节点值释放函数</span><br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br><br>    <span class="hljs-comment">// 节点值对比函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br><br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li></ul><p><strong>Redis 的链表实现的特性可以总结如下：</strong></p><p>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</p><p>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</p><p>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</p><p>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</p><p>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在 Redis 中的应用非常广泛，比如 List 的底层实现之一链表，当一个 List 包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://precipitation0224.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构——String实现</title>
    <link href="http://precipitation0224.github.io/2023/07/03/07-02-redis_String/"/>
    <id>http://precipitation0224.github.io/2023/07/03/07-02-redis_String/</id>
    <published>2023-07-02T19:31:25.000Z</published>
    <updated>2023-08-24T05:57:40.750Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p><p>SDS结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">// 记录 buf 数组中已使用字节的数量</span><br>    <span class="hljs-comment">// 等于 SDS 所保存字符串的长度</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br>    <span class="hljs-comment">// 字节数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</p><p>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</p><p>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。 SDS 与 C 语言字符串比较相近，但拥有更过的优势：</p><ol><li>SDS 获取字符串长度时间复杂度O(1)：因为 SDS 通过 len 字段来存储长度，使用时直接读取就可以；C 语言要想获取字符串长度需要遍历整个字符串，时间复杂度O(N)。</li><li>SDS 能杜绝缓冲区的溢出：因为当 SDS API 要对 SDS 进行修改时，会先检查 SDS 的空间是否足够，如果不够的话 SDS 会自动扩容，So，不会造成缓冲区溢出。而 C 语言则不剧本这个功能。</li><li>SDS 能减少修改字符串时带来的内存重分配次数：<ul><li>空间预分配：当SDS 扩容时不只是会增加需要的空间大小，还会额外的分配一些未使用的空间。分配的规则是：如果分配后SDS的长度小于 1MB，那么会分配等于分配后SDS 的大小的未使用空间，简单说就是，SDS 动态分配后是 16KB，那么就会多分配 16KB 的未使用空间；如果 小于 1MB，那么久分配 1MB 的未使用空间。</li><li>惰性空间释放： 惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，并不会立即内存重分配来回收多出来的字节，而是用 free 来记录未使用空间。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。&lt;/p&gt;
&lt;p&gt;SDS结构：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://precipitation0224.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构</title>
    <link href="http://precipitation0224.github.io/2023/07/03/07-02-redis_ds/"/>
    <id>http://precipitation0224.github.io/2023/07/03/07-02-redis_ds/</id>
    <published>2023-07-02T16:11:20.000Z</published>
    <updated>2023-08-24T05:50:48.716Z</updated>
    
    <content type="html"><![CDATA[<p>五种数据结构</p><p><strong>1. String</strong></p><ul><li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</li><li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw。</li><li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li></ul><p><strong>2. List</strong></p><ul><li>列表对象的编码可以是 ziplist 或者 linkedlist 。</li><li>列表对象保存的所有字符串元素的长度都小于 64 字节并且保存的元素数量小于 512 个，使用 ziplist 编码；否则使用 linkedlist；</li></ul><p><strong>3. Hash</strong></p><ul><li>哈希对象的编码可以是 ziplist 或者 hashtable 。</li><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节并且保存的键值对数量小于 512 个，使用ziplist 编码；否则使用hashtable；</li></ul><p><strong>4. Set</strong></p><ul><li>集合对象的编码可以是 intset 或者 hashtable 。</li><li>集合对象保存的所有元素都是整数值并且保存的元素数量不超过 512 个，使用intset 编码；否则使用hashtable；</li></ul><p><strong>5. Sorted Set</strong></p><ul><li>有序集合的编码可以是 ziplist 或者 skiplist</li><li>有序集合保存的元素数量小于 128 个并且保存的所有元素成员的长度都小于 64 字节。使用 ziplist 编码；否则使用skiplist。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;五种数据结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. String&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://precipitation0224.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>TCP相关问题</title>
    <link href="http://precipitation0224.github.io/2023/06/28/06-28-tcp_qa/"/>
    <id>http://precipitation0224.github.io/2023/06/28/06-28-tcp_qa/</id>
    <published>2023-06-28T12:11:30.000Z</published>
    <updated>2023-08-24T05:35:03.636Z</updated>
    
    <content type="html"><![CDATA[<p>1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</p><p>建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 </p><p>2、为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</p><p>两个存在的理由：1、无法保证最后发送的ACK报文会一定被对方收到，所以需要重发可能丢失的ACK报文。2、关闭链接一段时间后可能会在相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接已经终止后再现。2MSL足以让分组最多存活msl秒被丢弃。 </p><p>3、为什么必须是三次握手，不能用两次握手进行连接？</p><p>记住服务器的资源宝贵不能浪费! 如果在断开连接后，第一次握手请求连接的包才到会使服务器打开连接，占用资源而且容易被恶意攻击！防止攻击的方法，缩短服务器等待时间。两次握手容易死锁。如果服务器的应答分组在传输中丢失，将不知道S建立什么样的序列号，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？&lt;/p&gt;
&lt;p&gt;建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接断开解析</title>
    <link href="http://precipitation0224.github.io/2023/06/27/06-26-tcp/"/>
    <id>http://precipitation0224.github.io/2023/06/27/06-26-tcp/</id>
    <published>2023-06-26T22:11:30.000Z</published>
    <updated>2023-08-24T05:32:36.699Z</updated>
    
    <content type="html"><![CDATA[<p>TCP状态码有6种标示：</p><p>① SYN(synchronous建立联机)；</p><p>② ACK(acknowledgement 确认)</p><p>③ PSH(push传送)</p><p>④ FIN(finish结束)</p><p>⑤ RST(reset重置)</p><p>⑥ URG(urgent紧急)</p><p>Sequence number(顺序号码) &#x2F;&#x2F;Acknowledge number(确认号码)</p><p>第一次握手：主机A发送位码为SYN&#x3D;1，随机产生seq number&#x3D;1234567的数据包到服务器，主机B由SYN&#x3D;1知道，A要求建立联机；</p><p>第二次握手，主机B收到请求后要确认联机信息，向A发送ack number&#x3D;(主机A的seq+1)，SYN&#x3D;1,ACK&#x3D;1，随机产生seq number&#x3D;7654321的包；</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ACK是否为1，若正确，主机A会再发送ack number&#x3D;（主机B的seq+1）,ACK&#x3D;1，主机B收到后确认seq值与ACK&#x3D;1则连接建立成功。</p><p>四次握手是指终止TCP连接协议时，需要在客户端和服务器之间发送四个包</p><p>第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。</p><p>第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。</p><p>第三次挥手：被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。</p><p>第四次挥手：主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。</p><p>超时重传指的是，发送数据包在一定的时间周期内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为RTO. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP状态码有6种标示：&lt;/p&gt;
&lt;p&gt;① SYN(synchronous建立联机)；&lt;/p&gt;
&lt;p&gt;② ACK(acknowledgement 确认)&lt;/p&gt;
&lt;p&gt;③ PSH(push传送)&lt;/p&gt;
&lt;p&gt;④ FIN(finish结束)&lt;/p&gt;
&lt;p&gt;⑤ RST(res</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://precipitation0224.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>联邦学习下的表征学习相关paper</title>
    <link href="http://precipitation0224.github.io/2023/05/27/fedrep/"/>
    <id>http://precipitation0224.github.io/2023/05/27/fedrep/</id>
    <published>2023-05-27T11:39:45.000Z</published>
    <updated>2023-05-28T03:52:32.080Z</updated>
    
    <content type="html"><![CDATA[<p><strong>FedClassAvg: Local Representation Learning for Personalized Federated Learning on Heterogeneous Neural Networks</strong></p><p>个性化联合学习旨在允许众多客户在不交换私人数据的情况下，以高效沟通的方式参与协作培训，同时培训个性化模型。然而，许多个性化联合学习算法假设客户端具有相同的神经网络结构，而针对不同模型的算法仍未得到充分研究。在这项研究中，我们提出了一种新的个性化联合学习方法，称为联合分类器平均(FedClassAvg)。用于有监督学习任务的深度神经网络由特征提取器层和分类器层组成。FedClassAvg将分类器权重聚合为特征空间上决策边界的协议，以便具有不独立且相同分布(非IID)数据的客户可以了解稀缺标签。此外，应用局部特征表示学习来稳定决策边界，提高客户的局部特征提取能力。现有的方法需要收集辅助数据或模型权重来生成对应的数据，而FedClassAvg只需要客户端与几个完全连接的层进行通信，这是非常高效的通信效率。此外，FedClassAvg不需要额外的优化问题，如知识转移，这需要密集的计算开销。我们通过大量的实验对FedClassAvg进行了评估，并证明了它在异类个性化联合学习任务上的性能优于目前最先进的算法。</p><p><strong>Think Locally, Act Globally: Federated Learning with Local and Global Representations</strong></p><p>联合学习是一种对分布在多个设备上的私有数据进行模型训练的方法。为了保持设备数据的私密性，全局模型仅通过传递参数和更新进行训练，这对大型模型的可扩展性构成了挑战。为此，我们提出了一种新的联合学习算法，该算法联合学习每个设备上的紧凑局部表示和所有设备上的全局模型。因此，全局模型可以更小，因为它只对局部表示进行操作，从而减少了传递的参数的数量。从理论上讲，我们提供了一个泛化分析，它表明局部和全局模型的组合既减少了数据中的方差，也减少了设备分布之间的方差。经验上，我们证明了本地模型能够在保持性能的同时实现有效沟通的训练。我们还评估了从真实移动数据中预测个性化情绪的任务，其中隐私是关键。最后，本地模型处理来自新设备的异类数据，并学习混淆种族、年龄和性别等受保护属性的公平表示法。</p><p><strong>Collaborative Unsupervised Visual Representation Learning from Decentralized Data</strong></p><p>无监督表示学习利用互联网上的集中数据取得了出色的性能。然而，隐私保护意识的增强限制了分散的未标记图像数据的共享，这些数据在多方(例如移动电话和相机)中呈爆炸性增长。因此，一个自然的问题是如何利用这些数据来学习下游任务的可视化表示，同时保护数据隐私。针对这一问题，我们提出了一种新的联邦无监督学习框架FEDU。在该框架中，每一方使用在线网络和目标网络的对比学习来独立地从未标记的数据中训练模型。然后，中央服务器聚合训练的模型，并用聚合的模型更新客户端的模型。它保护数据隐私，因为每一方都只能访问其原始数据。多个缔约方之间分散的数据通常是非独立和相同分布的(非IID)，导致性能下降。为了应对这一挑战，我们提出了两种简单而有效的方法：1)我们设计了通信协议，只上传在线网络的编码者进行服务器聚合，并使用聚合的编码者更新它们；2)我们引入了一个新的模块，根据非IID引起的分歧来动态决定如何更新预测器。预测器是在线网络的另一个组成部分。广泛的实验和消融证明了FEDU的有效性和重要性。在非IID数据的线性和半监督评估中，它的性能比只有一方的训练方法高出5%以上，比其他方法高出14%以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;FedClassAvg: Local Representation Learning for Personalized Federated Learning on Heterogeneous Neural Networks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个</summary>
      
    
    
    
    
    <category term="联邦学习和多视图聚类" scheme="http://precipitation0224.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>联邦多视图表征训练</title>
    <link href="http://precipitation0224.github.io/2023/05/24/fedmvt/"/>
    <id>http://precipitation0224.github.io/2023/05/24/fedmvt/</id>
    <published>2023-05-24T12:57:46.000Z</published>
    <updated>2023-05-28T03:50:52.621Z</updated>
    
    <content type="html"><![CDATA[<p>FedMVT: Semi-supervised Vertical Federated Learning with MultiView Training</p><p><img src="/../picture/fedmvt.png"></p><p>提出了联邦多视图训练(FedMVT)，这是一种半监督学习方法，可以在有限重叠样本的情况下提高VFL的性能。FedMVT利用特征表示估计和伪标签预测扩展训练集，并联合训练三个分类器，提高模型的表征学习能力。FedMVT不仅显著提高了VFL中联邦模型的性能，而且还提高了拥有标签一方的局部模型的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FedMVT: Semi-supervised Vertical Federated Learning with MultiView Training&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../picture/fedmvt.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;提出了联邦多视图训练(F</summary>
      
    
    
    
    
    <category term="联邦学习和多视图聚类" scheme="http://precipitation0224.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>使用Selenium进行web测试</title>
    <link href="http://precipitation0224.github.io/2023/05/15/seleniumTst/"/>
    <id>http://precipitation0224.github.io/2023/05/15/seleniumTst/</id>
    <published>2023-05-14T22:11:30.000Z</published>
    <updated>2023-05-28T14:22:01.926Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium是一个用于自动化Web应用程序测试的强大工具。它支持多种编程语言，包括Java、Python、C#等。下面是使用Selenium进行测试的一般步骤：<br>1、安装Selenium：首先，需要在测试环境中安装Selenium。具体的安装步骤可能因使用的编程语言和测试框架而有所不同。<br>2、配置测试环境：在测试项目中，需要引入Selenium库和相关依赖。具体的配置方式也因使用的编程语言和测试框架而有所不同。可以使用构建工具（如Maven或Gradle）来管理依赖项，并确保测试环境正确设置。<br>3、编写测试代码：根据测试需求，编写使用Selenium的测试代码。下面是一个使用Java和JUnit进行Selenium测试的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.openqa.selenium.By;<br><span class="hljs-keyword">import</span> org.openqa.selenium.WebDriver;<br><span class="hljs-keyword">import</span> org.openqa.selenium.WebElement;<br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleSeleniumTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> WebDriver driver;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> void setup() &#123;<br>        <span class="hljs-comment">// 设置ChromeDriver路径</span><br>        System.setProperty(<span class="hljs-string">&quot;webdriver.chrome.driver&quot;</span>, <span class="hljs-string">&quot;path/to/chromedriver&quot;</span>);<br><br>        <span class="hljs-comment">// 创建ChromeDriver实例</span><br>        driver = new ChromeDriver();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> void testLogin() &#123;<br>        <span class="hljs-comment">// 打开网页</span><br>        driver.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;https://example.com&quot;</span>);<br><br>        <span class="hljs-comment">// 找到用户名和密码输入框，并输入值</span><br>        WebElement usernameInput = driver.findElement(By.id(<span class="hljs-string">&quot;username&quot;</span>));<br>        WebElement passwordInput = driver.findElement(By.id(<span class="hljs-string">&quot;password&quot;</span>));<br>        usernameInput.sendKeys(<span class="hljs-string">&quot;myusername&quot;</span>);<br>        passwordInput.sendKeys(<span class="hljs-string">&quot;mypassword&quot;</span>);<br><br>        <span class="hljs-comment">// 找到登录按钮，并点击</span><br>        WebElement loginButton = driver.findElement(By.id(<span class="hljs-string">&quot;loginButton&quot;</span>));<br>        loginButton.click();<br><br>        <span class="hljs-comment">// 验证登录成功后的操作，例如验证登录后的页面元素是否正确显示等</span><br>        WebElement welcomeMessage = driver.findElement(By.id(<span class="hljs-string">&quot;welcomeMessage&quot;</span>));<br>        Assert.assertEquals(<span class="hljs-string">&quot;Welcome, User!&quot;</span>, welcomeMessage.getText());<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> void teardown() &#123;<br>        <span class="hljs-comment">// 关闭浏览器</span><br>        driver.quit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用Chrome浏览器驱动，打开网页，模拟输入用户名和密码，并验证登录后的操作。在测试之前，我们使用**@Before<strong>注解设置了ChromeDriver实例，在测试之后，使用</strong>@After**注解关闭浏览器。</p><p>4、运行测试：运行你的测试代码，可以使用你所使用的测试框架提供的命令或集成开发环境（IDE）中的测试运行功能来执行测试。</p><p><strong>另外，Selenium还可以与其他测试框架和工具集成，例如JUnit、TestNG、Cucumber等，以扩展测试的能力和灵活性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Selenium是一个用于自动化Web应用程序测试的强大工具。它支持多种编程语言，包括Java、Python、C#等。下面是使用Selenium进行测试的一般步骤：&lt;br&gt;1、安装Selenium：首先，需要在测试环境中安装Selenium。具体的安装步骤可能因使用的编程语</summary>
      
    
    
    
    
    <category term="软件测试" scheme="http://precipitation0224.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio测试</title>
    <link href="http://precipitation0224.github.io/2023/05/11/androidTst/"/>
    <id>http://precipitation0224.github.io/2023/05/11/androidTst/</id>
    <published>2023-05-10T21:58:38.000Z</published>
    <updated>2023-05-28T14:00:34.026Z</updated>
    
    <content type="html"><![CDATA[<p>使用Android Studio进行测试</p><ol><li>单元测试（Unit Testing）：Android Studio内置了JUnit测试框架，你可以编写和运行单元测试来验证应用程序中的独立单元（如方法、类等）的功能是否按预期工作。单元测试通常用于测试业务逻辑、算法等核心功能。</li><li>仪器化测试（Instrumented Testing）：Android Studio提供了一个称为AndroidJUnitRunner的测试运行器，用于执行仪器化测试。仪器化测试是在实际设备或模拟器上运行的测试，可以测试与设备硬件和操作系统交互的功能。你可以编写和执行UI测试、功能测试等仪器化测试。</li><li>UI测试：使用Android Studio的Espresso测试框架，你可以编写UI测试来验证应用程序的用户界面是否正确显示和交互。Espresso提供了一系列API和断言，可以模拟用户操作，如点击按钮、输入文本等，并进行验证。</li><li>调试工具：Android Studio还提供了丰富的调试工具，如调试器和日志查看器，用于帮助你分析和调试应用程序中的问题。你可以设置断点、监视变量的值、查看日志输出等，以便更好地理解应用程序的行为和解决潜在的问题。</li></ol><p>仪器化测试Demo：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx.test.ext.junit.runners.AndroidJUnit4;<br><span class="hljs-keyword">import</span> androidx.test.rule.ActivityTestRule;<br><br><span class="hljs-keyword">import</span> org.junit.Rule;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><br><span class="hljs-keyword">import</span> static androidx.test.espresso.Espresso.onView;<br><span class="hljs-keyword">import</span> static androidx.test.espresso.action.ViewActions.click;<br><span class="hljs-keyword">import</span> static androidx.test.espresso.action.ViewActions.typeText;<br><span class="hljs-keyword">import</span> static androidx.test.espresso.assertion.ViewAssertions.matches;<br><span class="hljs-keyword">import</span> static androidx.test.espresso.matcher.ViewMatchers.withId;<br><span class="hljs-keyword">import</span> static androidx.test.espresso.matcher.ViewMatchers.withText;<br><br><span class="hljs-meta">@RunWith(AndroidJUnit4.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleInstrumentedTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Rule</span><br>    <span class="hljs-keyword">public</span> ActivityTestRule&lt;MainActivity&gt; activityRule = new ActivityTestRule&lt;&gt;(MainActivity.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> void testButtonClick() &#123;<br>        <span class="hljs-comment">// 找到一个具有特定ID的按钮，并点击它</span><br>        onView(withId(R.id.button)).perform(click());<br><br>        <span class="hljs-comment">// 找到一个具有特定ID的TextView，并验证其文本</span><br>        onView(withId(R.id.textView)).check(matches(withText(<span class="hljs-string">&quot;Button Clicked&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> void testEditTextInput() &#123;<br>        <span class="hljs-comment">// 找到一个具有特定ID的EditText，并在其中输入文本</span><br>        onView(withId(R.id.editText)).perform(typeText(<span class="hljs-string">&quot;Hello Espresso&quot;</span>));<br><br>        <span class="hljs-comment">// 找到一个具有特定ID的按钮，并点击它</span><br>        onView(withId(R.id.button)).perform(click());<br><br>        <span class="hljs-comment">// 找到一个具有特定ID的TextView，并验证其文本</span><br>        onView(withId(R.id.textView)).check(matches(withText(<span class="hljs-string">&quot;Hello Espresso&quot;</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例中，使用了AndroidJUnit4测试运行器和ActivityTestRule来运行仪器化测试。在**testButtonClick()<strong>方法中，模拟了点击按钮的操作，并验证了文本视图的内容。在</strong>testEditTextInput()**方法中，模拟了在EditText中输入文本的操作，并验证了文本视图的内容。</p><p><strong>单元测试用例</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> static org.junit.Assert.assertEquals;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtilsTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> void testAddition() &#123;<br>        int result = MathUtils.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        assertEquals(<span class="hljs-number">5</span>, result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> void testSubtraction() &#123;<br>        int result = MathUtils.subtract(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>        assertEquals(<span class="hljs-number">2</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们对一个简单的MathUtils类进行了单元测试。我们使用JUnit的<strong>assertEquals</strong>断言来验证两个值是否相等。</p><p><strong>UI测试用例</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx.test.espresso.Espresso;<br><span class="hljs-keyword">import</span> androidx.test.espresso.action.ViewActions;<br><span class="hljs-keyword">import</span> androidx.test.espresso.matcher.ViewMatchers;<br><span class="hljs-keyword">import</span> androidx.test.ext.junit.runners.AndroidJUnit4;<br><span class="hljs-keyword">import</span> androidx.test.rule.ActivityTestRule;<br><br><span class="hljs-keyword">import</span> org.junit.Rule;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><br><span class="hljs-keyword">import</span> static androidx.test.espresso.assertion.ViewAssertions.matches;<br><span class="hljs-keyword">import</span> static androidx.test.espresso.matcher.ViewMatchers.withText;<br><br><span class="hljs-meta">@RunWith(AndroidJUnit4.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivityTest</span> &#123;<br><br>    <span class="hljs-meta">@Rule</span><br>    <span class="hljs-keyword">public</span> ActivityTestRule&lt;MainActivity&gt; activityRule = new ActivityTestRule&lt;&gt;(MainActivity.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> void testButtonClick() &#123;<br>        Espresso.onView(ViewMatchers.withId(R.id.button))<br>                .perform(ViewActions.click());<br><br>        Espresso.onView(ViewMatchers.withId(R.id.textView))<br>                .check(matches(withText(<span class="hljs-string">&quot;Button Clicked&quot;</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例演示了使用Espresso进行UI测试。我们使用<strong>onView</strong>和<strong>perform</strong>方法模拟点击按钮的操作，并使用<strong>check</strong>和<strong>matches</strong>方法来验证文本视图的内容。</p><p><strong>调试用例</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;DebugUtils&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> static int multiply(int a, int b) &#123;<br>        int result = a * b;<br>        Log.d(TAG, <span class="hljs-string">&quot;multiply: Result is &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用Android的日志工具<strong>Log</strong>输出调试信息。我们可以在Logcat中查看这些日志，以帮助我们分析应用程序的行为和调试潜在问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用Android Studio进行测试&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单元测试（Unit Testing）：Android Studio内置了JUnit测试框架，你可以编写和运行单元测试来验证应用程序中的独立单元（如方法、类等）的功能是否按预期工作。单元测试通常用于测试业务逻</summary>
      
    
    
    
    
    <category term="软件测试" scheme="http://precipitation0224.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的测试及第三方库Ginkgo使用</title>
    <link href="http://precipitation0224.github.io/2023/04/23/gotest/"/>
    <id>http://precipitation0224.github.io/2023/04/23/gotest/</id>
    <published>2023-04-22T19:14:05.000Z</published>
    <updated>2023-04-22T12:03:28.132Z</updated>
    
    <content type="html"><![CDATA[<p>软件测试的定义：通过模拟实际使用环境，发现并报告软件中的缺陷和错误的过程，软件测试很重要，它可以保证软件的质量和可靠性，同时减少因缺陷而造成的损失和成本。</p><p>软件测试生命周期通常包括计划、分析、设计、执行和评估阶段。分析阶段，分析需求和确定的范围；设计阶段，编写测试用例和测试脚本；执行阶段，执行测试并记录结果；评估阶段，评估测试的效果，生成测试报告。</p><p>软件测试方法包括功能测试、性能测试、安全测试、易用性测试、兼容性测试、可靠性测试等。</p><p>测试用例是一个测试计划的基本单元，用于验证软件是否符合预期行为。测试用例应包括输入、预期输出、实际输出和测试结果。</p><p>黑盒测试是在<strong>不了解内部结构的情况下</strong>对软件进行测试，白盒测试是在<strong>了解软件内部结构</strong>的情况下对软件进行测试，着重于<strong>测试代码的正确性和完整性</strong>。</p><p>单元测试是对软件中最小的可测试单元进行测试，通常是一个函数或一个模块，如go内置的testing。</p><p>这里演示一个简单的testing包测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subtract</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a - b<br>&#125;<br><br><span class="hljs-keyword">package</span> math<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    result := Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-number">5</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Add(2, 3) = %d; want 5&quot;</span>, result)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSubtract</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    result := Subtract(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-number">3</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Subtract(5, 2) = %d; want 3&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行<em>go test</em>有:</p><p><img src="/../picture/mathtest.png"></p><p>自动化测试是使用工具和脚本来代替手动测试过程的测试方法，包括Selenium、Appium、Robot Framework和Cypress等。</p><p>性能测试是测试软件的性能和稳定性，主要是测试系统在各种负载下的响应时间、吞吐量和并发用户数等方面，包括Apache JMeter、Gatling和Locust等。</p><p>Go语言第三方库，对Ginkgo和Gomega进行介绍。</p><p>Ginkgo：Ginkgo是一个BDD风格的测试框架，支持Go语言中的自然语言测试表述。它具有嵌套的Describe和Context块，可以描述程序的各个方面，也可以使用It函数编写具体的测试用例。</p><p>Gomega：Gomega是一个用于Go语言的断言库，可以与Ginkgo和GoConvey等测试框架配合使用。它提供了丰富的匹配器函数和简单易用的API，可以方便地编写测试代码。</p><p>下面给出一个简单的测试demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* mypackage_test.go */</span><br><span class="hljs-keyword">package</span> mypackage_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;mypackage&quot;</span><br>    <br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;MyPackage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    It(<span class="hljs-string">&quot;should return true&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        result := mypackage.MyFunction()<br>        Expect(result).To(Equal(<span class="hljs-literal">true</span>))<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* mypackage_suite_test.go */</span><br><span class="hljs-keyword">package</span> mypackage_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;testing&quot;</span><br><br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMyPackage</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    RegisterFailHandler(Fail)<br>    RunSpecs(t, <span class="hljs-string">&quot;MyPackage Suite&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>后面只需在终端运行ginkgo即可，得到一下的测试输出：</p><p><img src="/../picture/ginkgotest.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件测试的定义：通过模拟实际使用环境，发现并报告软件中的缺陷和错误的过程，软件测试很重要，它可以保证软件的质量和可靠性，同时减少因缺陷而造成的损失和成本。&lt;/p&gt;
&lt;p&gt;软件测试生命周期通常包括计划、分析、设计、执行和评估阶段。分析阶段，分析需求和确定的范围；设计阶段，编写</summary>
      
    
    
    
    
    <category term="Golang" scheme="http://precipitation0224.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>golang中的GC</title>
    <link href="http://precipitation0224.github.io/2023/03/30/gogc/"/>
    <id>http://precipitation0224.github.io/2023/03/30/gogc/</id>
    <published>2023-03-29T20:11:14.000Z</published>
    <updated>2023-04-22T12:09:28.018Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言采用了一种基于垃圾回收的内存管理机制，即使用垃圾回收器来<u>自动管理内存分配和释放</u>，以便可以更轻松地编写代码，而不必担心内存分配和释放的问题。</p><p>在Go语言中，内存分配是通过调用new或make函数来完成的。new函数用于分配值类型（如int、struct等）的内存，而make函数用于分配引用类型（如slice、map、channel等）的内存。</p><p>看一个示例，使用new和make来分配内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用 new 函数分配一个 int 类型的内存，并将其初始化为 0</span><br>    p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 使用 * 运算符来访问指针所指向的内存，并修改其值</span><br>    *p = <span class="hljs-number">123</span><br><br>    <span class="hljs-comment">// 输出指针的值和所指向的内存的值</span><br>    fmt.Printf(<span class="hljs-string">&quot;p=%p, *p=%d\n&quot;</span>, p, *p)<br><br>    <span class="hljs-comment">// 使用 make 函数分配一个 int 类型的 slice，并将其初始化为 0</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">// 使用 [] 运算符来访问 slice 中的元素，并修改其值</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    s[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>    s[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br><br>    <span class="hljs-comment">// 输出 slice 的长度和容量，以及其中的元素</span><br>    fmt.Printf(<span class="hljs-string">&quot;len(s)=%d, cap(s)=%d, s=%v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-comment">// p=0xc000018088, *p=123 len(s)=10, cap(s)=10, s=[1 2 3 0 0 0 0 0 0 0]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当Go程序运行时，Go语言的垃圾回收器（Garbage Collector，GC）会自动分配和管理内存，以便程序员可以专注于编写代码，而无需手动进行内存分配和释放。在Go语言中，垃圾回收器采用的是标记-清除（Mark and Sweep）算法，即对于所有已分配的内存进行周期性的垃圾回收。</p><p>下面是<em>Garbage Collector</em>的一些重要特点和行为：</p><p><u><strong>分配内存</strong></u>：Go程序中的内存分配是由垃圾回收器负责的。使用new或make函数分配内存时，垃圾回收器会在堆（Heap）中为该对象分配一块新的内存。在分配内存时，垃圾回收器会跟踪已使用和未使用的内存块，以便在需要时回收未使用的内存。<br><u><strong>标记对象</strong></u>：垃圾回收器需要识别出哪些对象是活动的（即仍然在程序中使用），哪些对象是垃圾（即不再使用并且可以被回收）。垃圾回收器使用“三色标记”算法来标记活动对象和垃圾对象。它会从根对象（如全局变量、栈中的变量等）开始，递归遍历所有对象，并将活动对象标记为“白色”，未标记的对象即为垃圾。<br><u><strong>清除垃圾</strong></u>：在标记过程中，垃圾回收器会在对象上设置标记，以表明该对象已经被标记。标记结束后，垃圾回收器会扫描堆中所有未标记的对象，并将它们的内存释放回堆中。在清除过程中，垃圾回收器会把所有垃圾对象所占用的内存块合并起来，形成更大的内存块，以便将来分配给新对象使用。<br><u><strong>停止-复制GC</strong></u>：除了标记-清除算法之外，Go垃圾回收器还采用了停止-复制（Stop and Copy）算法。这种算法将堆分成两部分：From空间和To空间。在垃圾回收过程中，所有活动对象都被复制到To空间中，而From空间中的所有垃圾都被清除。在清除过程中，垃圾回收器会将From空间中的对象复制到To空间中，并交换From和To的角色。这种算法有助于减少内存碎片，并提高分配效率。</p><p>再对自动回收进行解释，一般是不手动触发的，但如果实在要手动出发也可以，调用的是runtime.gc()来触发垃圾回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 分配一个较大的切片</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000000</span>)<br><br>    <span class="hljs-comment">// 使用切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>        s[i] = i<br>    &#125;<br><br>    <span class="hljs-comment">// 释放切片</span><br>    s = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-comment">// 手动触发垃圾回收</span><br>    runtime.GC()<br><br>    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先分配了一个长度为1000000的切片，然后使用该切片，并将其设置为nil以释放内存。最后，我们手动调用了runtime.GC()函数，强制 Go 语言的垃圾回收器回收未使用的内存。</p><p>手动触发垃圾回收并不是 Go 语言中推荐的做法，因为 Go 语言的垃圾回收器通常会自动回收未使用的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言采用了一种基于垃圾回收的内存管理机制，即使用垃圾回收器来&lt;u&gt;自动管理内存分配和释放&lt;/u&gt;，以便可以更轻松地编写代码，而不必担心内存分配和释放的问题。&lt;/p&gt;
&lt;p&gt;在Go语言中，内存分配是通过调用new或make函数来完成的。new函数用于分配值类型（如int、</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GMP-Goroutine的调度器</title>
    <link href="http://precipitation0224.github.io/2023/03/27/gmp/"/>
    <id>http://precipitation0224.github.io/2023/03/27/gmp/</id>
    <published>2023-03-27T09:50:46.000Z</published>
    <updated>2023-03-27T01:56:03.085Z</updated>
    
    <content type="html"><![CDATA[<p>GMP指的是Goroutine Multiprocessing。</p><p>Goroutine是Go语言的一种轻量级线程，可以在单个进程中同时运行多个Goroutine，并且Goroutine之间可以相互通信和同步。GMP则是指在多核CPU上利用Goroutine 实现多进程并发的技术，也被称为”<strong><u>Go并发编程</u></strong>“。</p><p>GMP技术充分利用了现代多核处理器的特点，通过将任务分配到多个Goroutine上实现并行计算，从而提高了程序的性能和吞吐量。在GMP中，每个Goroutine都是一个轻量级的进程，它们之间可以共享内存，通过Channel进行通信和同步，而无需显式的加锁或解锁。</p><p>在Go语言中，使用GMP技术可以方便地实现高并发的网络编程、多任务计算、并行处理等应用场景。同时，Go语言标准库提供了丰富的Goroutine和Channel相关的API，进一步简化了GMP技术的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(num <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 告知wait group当前goroutine已完成计算</span><br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>        sum += i<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;Goroutine %d: sum(%d) = %d\n&quot;</span>, num, num, sum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用wait group等待所有goroutine完成计算</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 告知wait group有一个新的goroutine正在运行</span><br>        <span class="hljs-keyword">go</span> calculate(i+<span class="hljs-number">1</span>, &amp;wg)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有goroutine完成计算</span><br>    fmt.Println(<span class="hljs-string">&quot;All goroutines completed!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../picture/gmp.png"></p><p>在上面的示例代码中，我们定义了一个<strong>calculate</strong>函数，该函数会计算从0到给定数值之间的所有整数的和，并打印出计算结果。然后，我们在<strong>main</strong>函数中使用循环启动了4个<em>Goroutine</em>，每个<em>Goroutine</em>都会调用<strong>calculate</strong>函数进行计算。为了确保所有<em>Goroutine</em>都完成了计算，我们使用了<strong>sync.WaitGroup</strong>来等待它们的完成。</p><p>总结GMP的思路：</p><p>将任务分配到多个<em>Goroutine</em>上，然后使用<em>WaitGroup</em>等待它们的完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GMP指的是Goroutine Multiprocessing。&lt;/p&gt;
&lt;p&gt;Goroutine是Go语言的一种轻量级线程，可以在单个进程中同时运行多个Goroutine，并且Goroutine之间可以相互通信和同步。GMP则是指在多核CPU上利用Goroutine 实现</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang中Goroutine和Channel的Demo</title>
    <link href="http://precipitation0224.github.io/2023/03/27/grountinechan/"/>
    <id>http://precipitation0224.github.io/2023/03/27/grountinechan/</id>
    <published>2023-03-26T22:08:51.000Z</published>
    <updated>2023-03-28T12:07:22.312Z</updated>
    
    <content type="html"><![CDATA[<p>Golang中Goroutine和Channel的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, results <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> jobs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;worker %d processing job %d\n&quot;</span>, id, j)<br>time.Sleep(time.Second)<br>results &lt;- j * <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> numJobs = <span class="hljs-number">5</span><br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numJobs)<br>results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numJobs)<br><br><span class="hljs-keyword">for</span> w := <span class="hljs-number">1</span>; w &lt;= <span class="hljs-number">3</span>; w++ &#123;<br><span class="hljs-keyword">go</span> worker(w, jobs, results)<br>&#125;<br><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= numJobs; j++ &#123;<br>jobs &lt;- j<br>&#125;<br><span class="hljs-built_in">close</span>(jobs)<br><br><span class="hljs-keyword">for</span> a := <span class="hljs-number">1</span>; a &lt;= numJobs; a++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;result %d\n&quot;</span>, &lt;-results)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>程序结果：</strong></p><p><img src="/../picture/gorountinechan.png#pic_left"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Golang中Goroutine和Channel的实例&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>goroutine和mutex协作</title>
    <link href="http://precipitation0224.github.io/2023/03/23/goroutine/"/>
    <id>http://precipitation0224.github.io/2023/03/23/goroutine/</id>
    <published>2023-03-22T21:35:17.000Z</published>
    <updated>2023-04-22T12:09:57.137Z</updated>
    
    <content type="html"><![CDATA[<p>Goroutine 是 Golang 中的轻量级线程，可以由 Go 语言的运行时（runtime）进行调度。Goroutine 可以在单个线程中实现并发执行，因此可以在一个程序中创建大量的 Goroutine，而不会造成系统资源的浪费。</p><p>在golang中，创建协程的方式很简单，使用<em>go</em>关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 这里是 Goroutine 的代码逻辑</span><br>&#125;()<br></code></pre></td></tr></table></figure><p>Memory由内存分配器管理负责，可以动态地分配和释放内存，使得程序能够更加高效地利用系统资源。而Golang 中的内存分配器采用了类似于 C++ 中的<strong>内存池</strong>技术。在程序启动时，内存分配器会预先分配一些内存，称为堆。当需要分配内存时，内存分配器会从堆中分配一部分内存，并将其标记为已使用。当内存不再需要时，内存分配器会将其释放，并将其标记为未使用。</p><p>前面提到了<em>Gorountine</em>，那么给出<em>Goroutine</em>的<strong>调度逻辑</strong>：</p><p>Golang 中的<em>Goroutine</em>调度是由<em>runtime</em>模块进行管理的。在Golang中，所有的Goroutine都会被分配到一个逻辑处理器上执行。逻辑处理器可以看作是一个虚拟的CPU核心，每个逻辑处理器都可以执行多个 <em>Goroutine</em>。</p><p>当一个<em>Goroutine</em>遇到I&#x2F;O操作或者调用time.Sleep等函数时，它会主动将处理器释放给其他<em>Goroutine</em>执行。在下一次调度时，<em>runtime</em>模块会重新将该<em>Goroutine</em>分配到一个逻辑处理器上执行。</p><p>下一点，就是要考虑并发的安全性，那就要引入锁了，具体到go的sync包下的<em>Mutex</em>。</p><p>一块代码实例展示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> mutex sync.Mutex<br>    count := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            mutex.Lock()<br>            count++<br>            mutex.Unlock()<br><br>            wg.Done()<br>        &#125;()<br>    &#125;<br><br>    wg.Wait()<br>    <span class="hljs-comment">// 最后的结果也是100</span><br>    fmt.Printf(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, count)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的demo中，我们创建了一个包含100个<em>Goroutine</em>的循环，每个<em>Goroutine</em>都会将一个计数器<em>count</em>的值加一。为了保证<em>Goroutine</em>的安全性，我们使用了<em>Mutex</em>锁来保证在同一时间内只有一个<em>Goroutine</em>能够访问count变量。</p><p>在代码中，我们使用了sync包提供的<em>WaitGroup</em>和Mutex。<em>WaitGroup</em>可以帮助我们等待所有的<em>Goroutine</em>执行完毕，而<em>Mutex</em>则用于保护<em>coun</em>t变量的访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Goroutine 是 Golang 中的轻量级线程，可以由 Go 语言的运行时（runtime）进行调度。Goroutine 可以在单个线程中实现并发执行，因此可以在一个程序中创建大量的 Goroutine，而不会造成系统资源的浪费。&lt;/p&gt;
&lt;p&gt;在golang中，创建</summary>
      
    
    
    
    
    <category term="golang" scheme="http://precipitation0224.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>LFU</title>
    <link href="http://precipitation0224.github.io/2023/03/14/LFU/"/>
    <id>http://precipitation0224.github.io/2023/03/14/LFU/</id>
    <published>2023-03-13T22:48:08.000Z</published>
    <updated>2023-03-24T05:26:32.119Z</updated>
    
    <content type="html"><![CDATA[<p>LFU缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity), <span class="hljs-built_in">min_freq</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; &#125;<br>        <span class="hljs-keyword">auto</span> it = key_st[key];<br>        <span class="hljs-type">int</span> freq = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it);<br><br>        <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[freq];<br>        <span class="hljs-keyword">auto</span> &amp;&amp;other = freq_st[freq + <span class="hljs-number">1</span>];<br>        other.<span class="hljs-built_in">splice</span>(other.<span class="hljs-built_in">begin</span>(), lst, it);<br><br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it)++; <span class="hljs-comment">// 更新键值的使用频率</span><br>        <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>            freq_st.<span class="hljs-built_in">erase</span>(freq);<br>            <span class="hljs-keyword">if</span> (min_freq == freq) &#123;<br>                min_freq++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*it);<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 测试用例含 capacity == 0</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果键 key 已存在，则变更其值，并更新该 key 对应的 freq</span><br>            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*key_st[key]) = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果键不存在，请插入键值对</span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            <span class="hljs-comment">// 当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项</span><br>            <span class="hljs-comment">// 当两个或更多个键具有相同使用频率时，应该去除 最近最久未使用 的键。</span><br>            <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[min_freq];<br>            key_st.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(lst.<span class="hljs-built_in">back</span>()));<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>                freq_st.<span class="hljs-built_in">erase</span>(min_freq);<br>            &#125;<br>        &#125;<br>        min_freq = <span class="hljs-number">1</span>; <span class="hljs-comment">// 这是可以肯定的</span><br>        freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(key, value, <span class="hljs-number">1</span>);<br>        key_st[key] = freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> min_freq; <span class="hljs-comment">// 用于跟踪使用最少的频率</span><br>    <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Tuple; <span class="hljs-comment">// &lt;key, value, freq&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;&gt; freq_st; <span class="hljs-comment">// 相同使用频率的键值对放入在同一个链表中</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;::iterator&gt; key_st;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LFU缓存&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="http://precipitation0224.github.io/2023/03/14/LRU/"/>
    <id>http://precipitation0224.github.io/2023/03/14/LRU/</id>
    <published>2023-03-13T22:48:03.000Z</published>
    <updated>2023-03-24T05:22:03.118Z</updated>
    
    <content type="html"><![CDATA[<p>LRU缓存机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 快速查询和删除（哈希表）、快速查询最久未使用、删除元素、移动元素（链表）</span><br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> it = st[key];<br><br>        <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>        lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it);<br>        <span class="hljs-keyword">return</span> it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 已经存在，则变更其数据值 value</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">find</span>(key); it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            it-&gt;second-&gt;second = value;<br>            <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>            lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it-&gt;second);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果插入操作会导致关键字数量超过 capacity，则应该先 逐出 最久未使用的关键字。</span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            st.<span class="hljs-built_in">erase</span>(lst.<span class="hljs-built_in">rbegin</span>()-&gt;first);<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不存在，则向缓存中插入该组 key-value</span><br>        lst.<span class="hljs-built_in">emplace_front</span>(key, value);<br>        st[key] = lst.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Pair;<br>    <span class="hljs-type">int</span> capacity;<br>    list&lt;Pair&gt; lst; <span class="hljs-comment">// &lt;key, value&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Pair&gt;::iterator&gt; st; <span class="hljs-comment">// &lt;key, key_value_pair_iterator&gt;</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LRU缓存机制&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    
    <category term="算法" scheme="http://precipitation0224.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迭代器的随机访问</title>
    <link href="http://precipitation0224.github.io/2023/03/12/iteratoraccess/"/>
    <id>http://precipitation0224.github.io/2023/03/12/iteratoraccess/</id>
    <published>2023-03-11T21:31:49.000Z</published>
    <updated>2023-04-07T13:35:38.421Z</updated>
    
    <content type="html"><![CDATA[<p>STL中的随机访问迭代器是在其他迭代器基础上实现的，其本质是对指针的封装，可以像指针一样进行算数运算和随机访问，需要支持以下的操作</p><ul><li>迭代器加减运算</li><li>迭代器之间的比较运算</li><li>迭代器和指针之间的转换</li><li>通过迭代器访问元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomAccessIterator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> pointer = T*;<br>    <span class="hljs-keyword">using</span> reference = T&amp;;<br>    <span class="hljs-keyword">using</span> iterator_category = std::random_access_iterator_tag;<br><br>    <span class="hljs-built_in">RandomAccessIterator</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">RandomAccessIterator</span>(pointer p) : <span class="hljs-built_in">ptr_</span>(p) &#123;&#125;<br>    <span class="hljs-built_in">RandomAccessIterator</span>(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) : <span class="hljs-built_in">ptr_</span>(other.ptr_) &#123;&#125;<br>    ~<span class="hljs-built_in">RandomAccessIterator</span>() = <span class="hljs-keyword">default</span>;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) &#123;<br>        ptr_ = other.ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> *ptr_;<br>    &#125;<br><br>    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        ++ptr_;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        --ptr_;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>+=(difference_type n) &#123;<br>        ptr_ += n;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>+(difference_type n) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp += n;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>-=(difference_type n) &#123;<br>        ptr_ -= n;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>-(difference_type n) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp -= n;<br>    &#125;<br><br>    difference_type <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ - other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ == other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ != other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &lt; other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &gt; other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &lt;= other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &gt;= other.ptr_;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    pointer ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">it</span><span class="hljs-params">(arr)</span></span>;<br>    <span class="hljs-function">RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">it_end</span><span class="hljs-params">(arr + <span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 随机访问第3个元素</span><br>    <span class="hljs-type">int</span> value1 = *(it + <span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value1 = &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 随机访问第1个元素</span><br>    <span class="hljs-type">int</span> value2 = *(it_end - <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value2 = &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 通过迭代器访问元素</span><br>    <span class="hljs-keyword">for</span> (RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; it_tmp = it; it_tmp != it_end; ++it_tmp) &#123;<br>        std::cout &lt;&lt; *it_tmp &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 比较迭代器大小</span><br><span class="hljs-type">bool</span> result1 = it &lt; it_end;<br><span class="hljs-type">bool</span> result2 = it + <span class="hljs-number">1</span> &gt;= it_end <span class="hljs-number">-3</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;result1 = &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;result2 = &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，我们定义了一个模板类<code>RandomAccessIterator</code>，并且实现了随机访问迭代器所需的各个成员函数。在<code>main()</code>函数中，我们使用了<code>RandomAccessIterator</code>来访问一个数组，并展示了随机访问第3个和第1个元素的方式，以及通过迭代器遍历整个数组，比较迭代器的大小等操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STL中的随机访问迭代器是在其他迭代器基础上实现的，其本质是对指针的封装，可以像指针一样进行算数运算和随机访问，需要支持以下的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代器加减运算&lt;/li&gt;
&lt;li&gt;迭代器之间的比较运算&lt;/li&gt;
&lt;li&gt;迭代器和指针之间的转换&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://precipitation0224.github.io/tags/C/"/>
    
  </entry>
  
</feed>
