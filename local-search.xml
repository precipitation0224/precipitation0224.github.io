<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go语言中的测试及第三方库Ginkgo使用</title>
    <link href="/2023/04/23/gotest/"/>
    <url>/2023/04/23/gotest/</url>
    
    <content type="html"><![CDATA[<p>软件测试的定义：通过模拟实际使用环境，发现并报告软件中的缺陷和错误的过程，软件测试很重要，它可以保证软件的质量和可靠性，同时减少因缺陷而造成的损失和成本。</p><p>软件测试生命周期通常包括计划、分析、设计、执行和评估阶段。分析阶段，分析需求和确定的范围；设计阶段，编写测试用例和测试脚本；执行阶段，执行测试并记录结果；评估阶段，评估测试的效果，生成测试报告。</p><p>软件测试方法包括功能测试、性能测试、安全测试、易用性测试、兼容性测试、可靠性测试等。</p><p>测试用例是一个测试计划的基本单元，用于验证软件是否符合预期行为。测试用例应包括输入、预期输出、实际输出和测试结果。</p><p>黑盒测试是在<strong>不了解内部结构的情况下</strong>对软件进行测试，白盒测试是在<strong>了解软件内部结构</strong>的情况下对软件进行测试，着重于<strong>测试代码的正确性和完整性</strong>。</p><p>单元测试是对软件中最小的可测试单元进行测试，通常是一个函数或一个模块，如go内置的testing。</p><p>这里演示一个简单的testing包测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subtract</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a - b<br>&#125;<br><br><span class="hljs-keyword">package</span> math<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    result := Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-number">5</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Add(2, 3) = %d; want 5&quot;</span>, result)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSubtract</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    result := Subtract(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-number">3</span> &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Subtract(5, 2) = %d; want 3&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行<em>go test</em>有:</p><p><img src="/../picture/mathtest.png"></p><p>自动化测试是使用工具和脚本来代替手动测试过程的测试方法，包括Selenium、Appium、Robot Framework和Cypress等。</p><p>性能测试是测试软件的性能和稳定性，主要是测试系统在各种负载下的响应时间、吞吐量和并发用户数等方面，包括Apache JMeter、Gatling和Locust等。</p><p>Go语言第三方库，对Ginkgo和Gomega进行介绍。</p><p>Ginkgo：Ginkgo是一个BDD风格的测试框架，支持Go语言中的自然语言测试表述。它具有嵌套的Describe和Context块，可以描述程序的各个方面，也可以使用It函数编写具体的测试用例。</p><p>Gomega：Gomega是一个用于Go语言的断言库，可以与Ginkgo和GoConvey等测试框架配合使用。它提供了丰富的匹配器函数和简单易用的API，可以方便地编写测试代码。</p><p>下面给出一个简单的测试demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* mypackage_test.go */</span><br><span class="hljs-keyword">package</span> mypackage_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;mypackage&quot;</span><br>    <br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;MyPackage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    It(<span class="hljs-string">&quot;should return true&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        result := mypackage.MyFunction()<br>        Expect(result).To(Equal(<span class="hljs-literal">true</span>))<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* mypackage_suite_test.go */</span><br><span class="hljs-keyword">package</span> mypackage_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;testing&quot;</span><br><br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMyPackage</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    RegisterFailHandler(Fail)<br>    RunSpecs(t, <span class="hljs-string">&quot;MyPackage Suite&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>后面只需在终端运行ginkgo即可，得到一下的测试输出：</p><p><img src="/../picture/ginkgotest.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang中的GC</title>
    <link href="/2023/03/28/gogc/"/>
    <url>/2023/03/28/gogc/</url>
    
    <content type="html"><![CDATA[<p>Go语言采用了一种基于垃圾回收的内存管理机制，即使用垃圾回收器来<u>自动管理内存分配和释放</u>，以便可以更轻松地编写代码，而不必担心内存分配和释放的问题。</p><p>在Go语言中，内存分配是通过调用new或make函数来完成的。new函数用于分配值类型（如int、struct等）的内存，而make函数用于分配引用类型（如slice、map、channel等）的内存。</p><p>看一个示例，使用new和make来分配内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用 new 函数分配一个 int 类型的内存，并将其初始化为 0</span><br>    p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 使用 * 运算符来访问指针所指向的内存，并修改其值</span><br>    *p = <span class="hljs-number">123</span><br><br>    <span class="hljs-comment">// 输出指针的值和所指向的内存的值</span><br>    fmt.Printf(<span class="hljs-string">&quot;p=%p, *p=%d\n&quot;</span>, p, *p)<br><br>    <span class="hljs-comment">// 使用 make 函数分配一个 int 类型的 slice，并将其初始化为 0</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">// 使用 [] 运算符来访问 slice 中的元素，并修改其值</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    s[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>    s[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br><br>    <span class="hljs-comment">// 输出 slice 的长度和容量，以及其中的元素</span><br>    fmt.Printf(<span class="hljs-string">&quot;len(s)=%d, cap(s)=%d, s=%v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-comment">// p=0xc000018088, *p=123 len(s)=10, cap(s)=10, s=[1 2 3 0 0 0 0 0 0 0]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当Go程序运行时，Go语言的垃圾回收器（Garbage Collector，GC）会自动分配和管理内存，以便程序员可以专注于编写代码，而无需手动进行内存分配和释放。在Go语言中，垃圾回收器采用的是标记-清除（Mark and Sweep）算法，即对于所有已分配的内存进行周期性的垃圾回收。</p><p>下面是<em>Garbage Collector</em>的一些重要特点和行为：</p><p><u><strong>分配内存</strong></u>：Go程序中的内存分配是由垃圾回收器负责的。使用new或make函数分配内存时，垃圾回收器会在堆（Heap）中为该对象分配一块新的内存。在分配内存时，垃圾回收器会跟踪已使用和未使用的内存块，以便在需要时回收未使用的内存。<br><u><strong>标记对象</strong></u>：垃圾回收器需要识别出哪些对象是活动的（即仍然在程序中使用），哪些对象是垃圾（即不再使用并且可以被回收）。垃圾回收器使用“三色标记”算法来标记活动对象和垃圾对象。它会从根对象（如全局变量、栈中的变量等）开始，递归遍历所有对象，并将活动对象标记为“白色”，未标记的对象即为垃圾。<br><u><strong>清除垃圾</strong></u>：在标记过程中，垃圾回收器会在对象上设置标记，以表明该对象已经被标记。标记结束后，垃圾回收器会扫描堆中所有未标记的对象，并将它们的内存释放回堆中。在清除过程中，垃圾回收器会把所有垃圾对象所占用的内存块合并起来，形成更大的内存块，以便将来分配给新对象使用。<br><u><strong>停止-复制GC</strong></u>：除了标记-清除算法之外，Go垃圾回收器还采用了停止-复制（Stop and Copy）算法。这种算法将堆分成两部分：From空间和To空间。在垃圾回收过程中，所有活动对象都被复制到To空间中，而From空间中的所有垃圾都被清除。在清除过程中，垃圾回收器会将From空间中的对象复制到To空间中，并交换From和To的角色。这种算法有助于减少内存碎片，并提高分配效率。</p><p>再对自动回收进行解释，一般是不手动触发的，但如果实在要手动出发也可以，调用的是runtime.gc()来触发垃圾回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 分配一个较大的切片</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000000</span>)<br><br>    <span class="hljs-comment">// 使用切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>        s[i] = i<br>    &#125;<br><br>    <span class="hljs-comment">// 释放切片</span><br>    s = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-comment">// 手动触发垃圾回收</span><br>    runtime.GC()<br><br>    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先分配了一个长度为1000000的切片，然后使用该切片，并将其设置为nil以释放内存。最后，我们手动调用了runtime.GC()函数，强制 Go 语言的垃圾回收器回收未使用的内存。</p><p>手动触发垃圾回收并不是 Go 语言中推荐的做法，因为 Go 语言的垃圾回收器通常会自动回收未使用的内存。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMP-Goroutine的调度器</title>
    <link href="/2023/03/27/gmp/"/>
    <url>/2023/03/27/gmp/</url>
    
    <content type="html"><![CDATA[<p>GMP指的是Goroutine Multiprocessing。</p><p>Goroutine是Go语言的一种轻量级线程，可以在单个进程中同时运行多个Goroutine，并且Goroutine之间可以相互通信和同步。GMP则是指在多核CPU上利用Goroutine 实现多进程并发的技术，也被称为”<strong><u>Go并发编程</u></strong>“。</p><p>GMP技术充分利用了现代多核处理器的特点，通过将任务分配到多个Goroutine上实现并行计算，从而提高了程序的性能和吞吐量。在GMP中，每个Goroutine都是一个轻量级的进程，它们之间可以共享内存，通过Channel进行通信和同步，而无需显式的加锁或解锁。</p><p>在Go语言中，使用GMP技术可以方便地实现高并发的网络编程、多任务计算、并行处理等应用场景。同时，Go语言标准库提供了丰富的Goroutine和Channel相关的API，进一步简化了GMP技术的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(num <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 告知wait group当前goroutine已完成计算</span><br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>        sum += i<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;Goroutine %d: sum(%d) = %d\n&quot;</span>, num, num, sum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用wait group等待所有goroutine完成计算</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 告知wait group有一个新的goroutine正在运行</span><br>        <span class="hljs-keyword">go</span> calculate(i+<span class="hljs-number">1</span>, &amp;wg)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有goroutine完成计算</span><br>    fmt.Println(<span class="hljs-string">&quot;All goroutines completed!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../picture/gmp.png"></p><p>在上面的示例代码中，我们定义了一个<strong>calculate</strong>函数，该函数会计算从0到给定数值之间的所有整数的和，并打印出计算结果。然后，我们在<strong>main</strong>函数中使用循环启动了4个<em>Goroutine</em>，每个<em>Goroutine</em>都会调用<strong>calculate</strong>函数进行计算。为了确保所有<em>Goroutine</em>都完成了计算，我们使用了<strong>sync.WaitGroup</strong>来等待它们的完成。</p><p>总结GMP的思路：</p><p>将任务分配到多个<em>Goroutine</em>上，然后使用<em>WaitGroup</em>等待它们的完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中Goroutine和Channel的Demo</title>
    <link href="/2023/03/27/grountinechan/"/>
    <url>/2023/03/27/grountinechan/</url>
    
    <content type="html"><![CDATA[<p>Golang中Goroutine和Channel的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, results <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> jobs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;worker %d processing job %d\n&quot;</span>, id, j)<br>time.Sleep(time.Second)<br>results &lt;- j * <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> numJobs = <span class="hljs-number">5</span><br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numJobs)<br>results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numJobs)<br><br><span class="hljs-keyword">for</span> w := <span class="hljs-number">1</span>; w &lt;= <span class="hljs-number">3</span>; w++ &#123;<br><span class="hljs-keyword">go</span> worker(w, jobs, results)<br>&#125;<br><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= numJobs; j++ &#123;<br>jobs &lt;- j<br>&#125;<br><span class="hljs-built_in">close</span>(jobs)<br><br><span class="hljs-keyword">for</span> a := <span class="hljs-number">1</span>; a &lt;= numJobs; a++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;result %d\n&quot;</span>, &lt;-results)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>程序结果：</strong></p><p><img src="/../picture/gorountinechan.png#pic_left"></p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goroutine和mutex协作</title>
    <link href="/2023/03/27/goroutine/"/>
    <url>/2023/03/27/goroutine/</url>
    
    <content type="html"><![CDATA[<p>Goroutine 是 Golang 中的轻量级线程，可以由 Go 语言的运行时（runtime）进行调度。Goroutine 可以在单个线程中实现并发执行，因此可以在一个程序中创建大量的 Goroutine，而不会造成系统资源的浪费。</p><p>在golang中，创建协程的方式很简单，使用<em>go</em>关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 这里是 Goroutine 的代码逻辑</span><br>&#125;()<br></code></pre></td></tr></table></figure><p>Memory由内存分配器管理负责，可以动态地分配和释放内存，使得程序能够更加高效地利用系统资源。而Golang 中的内存分配器采用了类似于 C++ 中的<strong>内存池</strong>技术。在程序启动时，内存分配器会预先分配一些内存，称为堆。当需要分配内存时，内存分配器会从堆中分配一部分内存，并将其标记为已使用。当内存不再需要时，内存分配器会将其释放，并将其标记为未使用。</p><p>前面提到了<em>Gorountine</em>，那么给出<em>Goroutine</em>的<strong>调度逻辑</strong>：</p><p>Golang 中的<em>Goroutine</em>调度是由<em>runtime</em>模块进行管理的。在Golang中，所有的Goroutine都会被分配到一个逻辑处理器上执行。逻辑处理器可以看作是一个虚拟的CPU核心，每个逻辑处理器都可以执行多个 <em>Goroutine</em>。</p><p>当一个<em>Goroutine</em>遇到I&#x2F;O操作或者调用time.Sleep等函数时，它会主动将处理器释放给其他<em>Goroutine</em>执行。在下一次调度时，<em>runtime</em>模块会重新将该<em>Goroutine</em>分配到一个逻辑处理器上执行。</p><p>下一点，就是要考虑并发的安全性，那就要引入锁了，具体到go的sync包下的<em>Mutex</em>。</p><p>一块代码实例展示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> mutex sync.Mutex<br>    count := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            mutex.Lock()<br>            count++<br>            mutex.Unlock()<br><br>            wg.Done()<br>        &#125;()<br>    &#125;<br><br>    wg.Wait()<br>    <span class="hljs-comment">// 最后的结果也是100</span><br>    fmt.Printf(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, count)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的demo中，我们创建了一个包含100个<em>Goroutine</em>的循环，每个<em>Goroutine</em>都会将一个计数器<em>count</em>的值加一。为了保证<em>Goroutine</em>的安全性，我们使用了<em>Mutex</em>锁来保证在同一时间内只有一个<em>Goroutine</em>能够访问count变量。</p><p>在代码中，我们使用了sync包提供的<em>WaitGroup</em>和Mutex。<em>WaitGroup</em>可以帮助我们等待所有的<em>Goroutine</em>执行完毕，而<em>Mutex</em>则用于保护<em>coun</em>t变量的访问。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LFU</title>
    <link href="/2023/03/14/LFU/"/>
    <url>/2023/03/14/LFU/</url>
    
    <content type="html"><![CDATA[<p>LFU缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity), <span class="hljs-built_in">min_freq</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; &#125;<br>        <span class="hljs-keyword">auto</span> it = key_st[key];<br>        <span class="hljs-type">int</span> freq = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it);<br><br>        <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[freq];<br>        <span class="hljs-keyword">auto</span> &amp;&amp;other = freq_st[freq + <span class="hljs-number">1</span>];<br>        other.<span class="hljs-built_in">splice</span>(other.<span class="hljs-built_in">begin</span>(), lst, it);<br><br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(*it)++; <span class="hljs-comment">// 更新键值的使用频率</span><br>        <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>            freq_st.<span class="hljs-built_in">erase</span>(freq);<br>            <span class="hljs-keyword">if</span> (min_freq == freq) &#123;<br>                min_freq++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*it);<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 测试用例含 capacity == 0</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果键 key 已存在，则变更其值，并更新该 key 对应的 freq</span><br>            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(*key_st[key]) = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果键不存在，请插入键值对</span><br>        <span class="hljs-keyword">if</span> (key_st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            <span class="hljs-comment">// 当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项</span><br>            <span class="hljs-comment">// 当两个或更多个键具有相同使用频率时，应该去除 最近最久未使用 的键。</span><br>            <span class="hljs-keyword">auto</span> &amp;&amp;lst = freq_st[min_freq];<br>            key_st.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(lst.<span class="hljs-built_in">back</span>()));<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>()) &#123;<br>                freq_st.<span class="hljs-built_in">erase</span>(min_freq);<br>            &#125;<br>        &#125;<br>        min_freq = <span class="hljs-number">1</span>; <span class="hljs-comment">// 这是可以肯定的</span><br>        freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(key, value, <span class="hljs-number">1</span>);<br>        key_st[key] = freq_st[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> min_freq; <span class="hljs-comment">// 用于跟踪使用最少的频率</span><br>    <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Tuple; <span class="hljs-comment">// &lt;key, value, freq&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;&gt; freq_st; <span class="hljs-comment">// 相同使用频率的键值对放入在同一个链表中</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Tuple&gt;::iterator&gt; key_st;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU</title>
    <link href="/2023/03/14/LRU/"/>
    <url>/2023/03/14/LRU/</url>
    
    <content type="html"><![CDATA[<p>LRU缓存机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 快速查询和删除（哈希表）、快速查询最久未使用、删除元素、移动元素（链表）</span><br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity): <span class="hljs-built_in">capacity</span>(capacity) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 </span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> it = st[key];<br><br>        <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>        lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it);<br>        <span class="hljs-keyword">return</span> it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果关键字 key 已经存在，则变更其数据值 value</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = st.<span class="hljs-built_in">find</span>(key); it != st.<span class="hljs-built_in">end</span>()) &#123;<br>            it-&gt;second-&gt;second = value;<br>            <span class="hljs-comment">// 标志该 key 为「最近使用」</span><br>            lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it-&gt;second);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果插入操作会导致关键字数量超过 capacity，则应该先 逐出 最久未使用的关键字。</span><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>            st.<span class="hljs-built_in">erase</span>(lst.<span class="hljs-built_in">rbegin</span>()-&gt;first);<br>            lst.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不存在，则向缓存中插入该组 key-value</span><br>        lst.<span class="hljs-built_in">emplace_front</span>(key, value);<br>        st[key] = lst.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; Pair;<br>    <span class="hljs-type">int</span> capacity;<br>    list&lt;Pair&gt; lst; <span class="hljs-comment">// &lt;key, value&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Pair&gt;::iterator&gt; st; <span class="hljs-comment">// &lt;key, key_value_pair_iterator&gt;</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器的随机访问</title>
    <link href="/2023/03/12/iteratoraccess/"/>
    <url>/2023/03/12/iteratoraccess/</url>
    
    <content type="html"><![CDATA[<p>STL中的随机访问迭代器是在其他迭代器基础上实现的，其本质是对指针的封装，可以像指针一样进行算数运算和随机访问，需要支持以下的操作</p><ul><li>迭代器加减运算</li><li>迭代器之间的比较运算</li><li>迭代器和指针之间的转换</li><li>通过迭代器访问元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomAccessIterator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> pointer = T*;<br>    <span class="hljs-keyword">using</span> reference = T&amp;;<br>    <span class="hljs-keyword">using</span> iterator_category = std::random_access_iterator_tag;<br><br>    <span class="hljs-built_in">RandomAccessIterator</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">RandomAccessIterator</span>(pointer p) : <span class="hljs-built_in">ptr_</span>(p) &#123;&#125;<br>    <span class="hljs-built_in">RandomAccessIterator</span>(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) : <span class="hljs-built_in">ptr_</span>(other.ptr_) &#123;&#125;<br>    ~<span class="hljs-built_in">RandomAccessIterator</span>() = <span class="hljs-keyword">default</span>;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) &#123;<br>        ptr_ = other.ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> *ptr_;<br>    &#125;<br><br>    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        ++ptr_;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --ptr_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        --ptr_;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>+=(difference_type n) &#123;<br>        ptr_ += n;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>+(difference_type n) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp += n;<br>    &#125;<br><br>    RandomAccessIterator&amp; <span class="hljs-keyword">operator</span>-=(difference_type n) &#123;<br>        ptr_ -= n;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    RandomAccessIterator <span class="hljs-keyword">operator</span>-(difference_type n) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">RandomAccessIterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp -= n;<br>    &#125;<br><br>    difference_type <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ - other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ == other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ != other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &lt; other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &gt; other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &lt;= other.ptr_;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> RandomAccessIterator&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr_ &gt;= other.ptr_;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    pointer ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">it</span><span class="hljs-params">(arr)</span></span>;<br>    <span class="hljs-function">RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">it_end</span><span class="hljs-params">(arr + <span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 随机访问第3个元素</span><br>    <span class="hljs-type">int</span> value1 = *(it + <span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value1 = &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 随机访问第1个元素</span><br>    <span class="hljs-type">int</span> value2 = *(it_end - <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value2 = &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 通过迭代器访问元素</span><br>    <span class="hljs-keyword">for</span> (RandomAccessIterator&lt;<span class="hljs-type">int</span>&gt; it_tmp = it; it_tmp != it_end; ++it_tmp) &#123;<br>        std::cout &lt;&lt; *it_tmp &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 比较迭代器大小</span><br><span class="hljs-type">bool</span> result1 = it &lt; it_end;<br><span class="hljs-type">bool</span> result2 = it + <span class="hljs-number">1</span> &gt;= it_end <span class="hljs-number">-3</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;result1 = &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;result2 = &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，我们定义了一个模板类<code>RandomAccessIterator</code>，并且实现了随机访问迭代器所需的各个成员函数。在<code>main()</code>函数中，我们使用了<code>RandomAccessIterator</code>来访问一个数组，并展示了随机访问第3个和第1个元素的方式，以及通过迭代器遍历整个数组，比较迭代器的大小等操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮点数和MD5,Base64</title>
    <link href="/2023/03/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/"/>
    <url>/2023/03/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%92%8CMD5-Bae64/</url>
    
    <content type="html"><![CDATA[<p>4、浮点数的存储方式</p><ol><li><p>符号位：‘+’存储为0，‘-’存储为1</p></li><li><p>将数字转化成二进制数</p></li><li><p>将二进制数规范化为 1.xxxxxxxx*2^n</p></li><li><p>将n转化为指数（+127） 尾数xxxx后面补零</p></li></ol><p>5、介绍MD5、Base64</p><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。md5运算结果是一个固定长度为128位的二进制数，经过一系列的运算得到32个16进制数。</p><p>Base64是一种使用64基的位置计数法。它使用2的最大次方来代表仅可打印的ASCII字符。这使它可用来作为电子邮件的传输编码。在Base64中的变量使用字符A-Z、a-z和0-9，这样共有62个字符，用来作为开始的64个数字，最后两个用来作为数字的符号在不同的系统中而不同。一些如unencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。</p><p>MD5加密算法是不可逆的，base64加密算法是可逆的；MD5加密算法是不可逆的，base64加密算法是可逆的</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector动态扩容机制</title>
    <link href="/2023/03/10/vectorexpand/"/>
    <url>/2023/03/10/vectorexpand/</url>
    
    <content type="html"><![CDATA[<p>vector中的动态扩容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* push_back() */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alloc</span>&gt;<br><span class="hljs-type">void</span> vector&lt;T, Alloc&gt;::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">const</span> value_type&amp; val)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123; <span class="hljs-comment">// 如果还有剩余空间，直接插入元素</span><br>        _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish, val);<br>        ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则需要重新分配空间</span><br>        _M_insert_aux(<span class="hljs-built_in">end</span>(), val);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alloc</span>&gt;<br><span class="hljs-type">void</span> vector&lt;T, Alloc&gt;::_M_insert_aux(iterator position, <span class="hljs-type">const</span> T&amp; x)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish != <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage) &#123; <span class="hljs-comment">// 如果还有剩余空间，直接插入元素</span><br>        _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish, *(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">1</span>));<br>        ++<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<br>        T x_copy = x;<br>        std::<span class="hljs-built_in">copy_backward</span>(position, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-number">1</span>);<br>        *position = x_copy;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则需要扩容</span><br>        <span class="hljs-type">const</span> size_type old_size = <span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">const</span> size_type new_size = old_size != <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> * old_size : <span class="hljs-number">1</span>;<br>        iterator new_start = _M_allocate(new_size);<br>        iterator new_finish = new_start;<br>        <span class="hljs-keyword">try</span> &#123;<br>            new_finish = std::__uninitialized_copy_a(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, position, new_start, _M_get_Tp_allocator());<br>            _Alloc_traits::<span class="hljs-built_in">construct</span>(_M_get_Tp_allocator(), new_finish, x);<br>            ++new_finish;<br>            new_finish = std::__uninitialized_copy_a(position, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish, new_finish, _M_get_Tp_allocator());<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (...) &#123;<br>            _M_destroy(new_start, new_finish);<br>            _M_deallocate(new_start, new_size);<br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>        _M_destroy(<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">end</span>());<br>        _M_deallocate(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage - <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start);<br>        <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start = new_start;<br>        <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish = new_finish;<br>        <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage = new_start + new_size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>vector的底层实现使用了动态数组，即在内存中分配一段连续的空间来存储元素。</li><li>当vector的元素数量达到其容量时，需要进行扩容。vector的扩容是通过重新分配一段更大的内存空间，并将原有的元素拷贝到新空间来实现的。</li><li>为了避免频繁的扩容操作，vector采用了倍增策略来确定新的容量大小。即在扩容时，将原有容量乘以一个系数，通常为2，来计算新的容量大小。</li><li>在实现中，vector使用了allocator来管理内存分配，以保证分配的内存块是对齐的并遵循C++的类型安全规则。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* reverse() */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alloc</span>&gt;<br><span class="hljs-type">void</span> vector&lt;T, Alloc&gt;::<span class="hljs-built_in">reverse</span>() <span class="hljs-keyword">noexcept</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;_M_ipml._M_finish-<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start&gt;<span class="hljs-number">1</span>) &#123;<br>        std::_reverse(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在源代码中，可以看到当vector内部存储的元素数量大于1时，才会调用std::__reverse()函数对其进行反转。下面是std::__reverse()函数的源代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* std::_reverse() */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _BidirectionalIterator&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)<br>&#123;<br>    <span class="hljs-comment">// 反转区间[first, last)中的元素</span><br>    <span class="hljs-comment">// 首尾两个迭代器分别指向区间的首尾</span><br>    <span class="hljs-keyword">while</span> (__first != __last &amp;&amp; __first != --__last) &#123;<br>        <span class="hljs-comment">// 将首尾两个元素进行交换</span><br>        std::<span class="hljs-built_in">iter_swap</span>(__first, __last);<br>        <span class="hljs-comment">// 将迭代器向前和向后移动</span><br>        ++__first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在std::__reverse()函数中，使用了双向迭代器，并利用std::iter_swap()函数将首尾两个元素进行交换，然后将迭代器向前和向后移动，直到迭代器相遇或者前一个迭代器等于后一个迭代器减1。通过分析以上源代码，我们可以看到STL中reverse()函数的实现采用了双向迭代器，并利用std::iter_swap()函数交换元素，这个函数是标准库中定义的交换元素的函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚函数动态绑定</title>
    <link href="/2023/03/08/virtualpointer/"/>
    <url>/2023/03/08/virtualpointer/</url>
    
    <content type="html"><![CDATA[<p>14、虚函数如何实现动态转发，每个类都有虚函数表吗</p><p>虚函数是在某基类中声明为<em><strong>virtual</strong></em>并在一个或多个派生类中被重新定义的成员函数。是实现动态多态的一种方法。</p><p>函数是通过<strong>虚函数表</strong>来实现的。每一个含有虚函数的类，都会有一个虚函数表用来存放虚函数的地址，同时类会有一个<strong>虚表指针</strong>去指向虚函数表的首地址,<strong>对象的首地址就存放着虚表指针</strong>。</p><p><strong>虚函数表：</strong>要讲清楚动态绑定的流程，首先需要了解清楚类里面虚函数表的定义，虚函数表是记录虚函数入口地址的一串数组（实际是一个函数指针数组），它只存在于定义了虚函数的类里面，这里给出一个例子来展示类中虚函数表的存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//空类的大小为1</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//大小为4，成员变量会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为4，非虚函数不会占用类空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//大小为16，定义虚函数会增加类的大小，但是这个增加不是虚函数带来了的，而是指向虚函数表的指针所占的空间</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//大小为16，从这儿可以看到，类里面的多个虚函数都维护在一个虚函数表里面，只有一个指向虚函数表的指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(C)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(D)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(E)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//实际上，虚函数不占用类对象的存储空间，</span><br><span class="hljs-comment">//所以含有一个以上的虚函数的类对象大小与仅含一个虚函数大小相同</span><br><span class="hljs-comment">//同时，针对每个类，只维护一个【虚函数表（函数指针数组数组）】</span><br><span class="hljs-comment">//用于存放该类中虚函数的地址，每个【含一个及以上虚函数的对象都会含有一个指向该类虚函数表的指针】。</span><br></code></pre></td></tr></table></figure><p><strong>动态绑定虚函数工作原理：</strong> 前面提到，每一个类会为所有虚函数数维护一个虚函数表，并且有一个指针指向这个表的首地址，这个虚函数表记录着所有的虚函数的入口地址。那么在动态绑定时，编译器是如何给基类指针返回一个正确的函数入口地址，这里给出一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> a1;<br>        <span class="hljs-type">int</span> a2;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::display()&quot;</span>&lt;&lt;endl;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;A::clone()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;B::init()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> B&#123;<br>        <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::display()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">override</span></span><br><span class="hljs-function">        <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;C::execute()&quot;</span>&lt;&lt;endl;&#125; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;C::init()&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-keyword">override</span><br></code></pre></td></tr></table></figure><p>这里给出A,B,C三个类的内存情况，如下图。可以得出这么几个结论：</p><ol><li>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的</li><li>同名虚函数在基类和派生类中的虚函数表中，索引是一致的，如下图，A,B,C的display的索引都是0</li><li>派生类中，一旦对基类中的虚函数进行了覆盖，那么派生类的虚函数表中响应函数的入口地址会被替换成覆盖后的函数的地址。</li><li>一旦有新的虚函数定义，会加入到当前虚函数表的末端。</li></ol><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><em><strong>reference link</strong></em>: <a href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http缺陷，tls和QUIC</title>
    <link href="/2023/03/07/tls/"/>
    <url>/2023/03/07/tls/</url>
    
    <content type="html"><![CDATA[<p>10、http安全保证，tls，如何握手</p><p>HTTP协议没有任何的加密以及身份验证的机制，非常容易遭到窃听、劫持、篡改等。不安全的原因主要包含以下方面：</p><ol><li>通信使用明文，内容可能被窃听。</li><li>不验证通信方的身份，因此有可能遭到伪装。</li><li>无法验证报文的完整性，所以有可能被篡改。</li><li>传统的HTTP请求过程都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求和响应被黑客拦截，并且里面含有密码等敏感数据的话，会非常危险。</li></ol><p><em><strong>QUIC</strong></em> 协议 (RFC 9000) 旨在提高 Web 性能并减少访问延迟，同时保持通信机密。 一种基本方法是通过将 QUIC 握手与 TLS 1.3 握手集成并将多个 QUIC 数据包合并到一个 UDP 数据报中来减少初始往返时间 (RTT)。</p><p>总的来说，QUIC 相比于 HTTP&#x2F;2.0 来说，具有下面这些优势：</p><ul><li>使用 UDP 协议，不需要三次连接进行握手，而且也会缩短 TLS 建立连接的时间。</li><li>解决了队头阻塞问题</li><li>实现动态可插拔，在应用层实现了拥塞控制算法，可以随时切换。</li><li>报文头和报文体分别进行认证和加密处理，保障安全性。</li><li>连接能够平滑迁移</li></ul><p>连接平滑迁移指的是，你的手机或者移动设备在 4G 信号下和 WiFi 等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string的缺陷和指针选择</title>
    <link href="/2023/03/05/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/"/>
    <url>/2023/03/05/string%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E6%8C%87%E9%92%88%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>2、std::string的缺陷</p><p>最大的缺点是 std::string 是「字节串」而非「字符串」</p><ol><li>它是可变对象，任何对 string 对象的操作都会改变原对象的值而不是重新生成一个 string 对象，线程不安全；</li><li>不能很好的处理宽字节的字符；</li><li>没有足够多的好用的函数，没有format格式输出，要借助要用stdio.h头文件里的 sprintf 函数。</li></ol><p>3、智能指针和原生指针的开销</p><p><strong>泛型指针：</strong></p><p>泛型指针有多种含义。1) 指void*指针，可以指向任意数据类型，因此具有“泛型”含义。2) 指具有指针特性的泛型数据结构，包含泛型的迭代器、智能指针等。 广义的迭代器是一种不透明指针，能够实现遍历访问操作。通常所说的迭代器是指狭义的迭代器，即基于C++的STL中基于泛型的iterator_traits实现的类的实例。总体来说，泛型指针和迭代器是两个不同的概念，其中的交集则是通常提到的迭代器类。</p><p><strong>原生指针：</strong></p><p>原生指针就是普通指针， 定义类似：类型 <em>变量名（int <em>p）;相反的若是一个类重载了‘</em>’和‘-&gt;’的运算符，能够像指针同样用‘</em>’和‘-&gt;’操做，就不是原生的，如iterator等。说“原生”是指“最简朴最基本的那一种”。因为现在很多东西都抽象化理论化了，所以“以前的那种最简朴最基本的指针”只是一个抽象概念（比如iterator）的表现形式之一。</p><p>c++的原生指针又可以分为普通指针，成员指针，函数指针。</p><p><strong>智能指针：</strong></p><p>智能指针是c++2.0的新特性之一，其最大的特点在于其结合了指针和对象构造析构的优点RAII，使得其在其生存期结束时可以及时释放其所管理的资源（动态内存分配得到的资源）。由于 C++ 语言没有自动内存回收机制，程序员每次得自己处理内存相关问题，但用智能指针便可以有效缓解这类问题。 一般是把指针封装到一个称之为智能指针类中，这个类中另外还封装了一个使用计数器，对指针的复制等操作将导致该计数器的值加1，对指针的delete操作则会减1，值为0时，指针为NULL。下面是智能指针的选择。</p><p>（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括三种：</p><ol><li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li><li>两个对象包含都指向第三个对象的指针；</li><li>STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</li></ol><p>（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态库和动态库</title>
    <link href="/2023/03/04/staticlib/"/>
    <url>/2023/03/04/staticlib/</url>
    
    <content type="html"><![CDATA[<p>静态库需要有库文件和头文件，编译程序要通过”-l libname”参数编译；</p><p>linux是.a文件，windows是.lib文件</p><p>制作流程，先通过gcc生成.o文件，再通过ar(<strong>参数选项rcs</strong>)将.o文件打包生成.a文件。</p><p>动态库在运行程序之前还需要配置动态库的加载路径</p><p>linux是.so文件，windows是.dll文件</p><p>通过gcc生成.o文件(<strong>参数选项fpic</strong>)，再通过gcc生成.so文件(<strong>参数选项shared</strong>)。</p><p>静态库和动态库的区别，静态库链接时，静态库中的代码会打包到可执行程序中，编译时加载，发布程序无需提供静态库，移植方便，消耗内存，更新部署复杂；动态库链接时，动态库代码不会打包到可执行程序中，运行时加载，发布程序时要提供动态库，内存占用小，更新部署发布简单。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预防sql注入</title>
    <link href="/2023/03/02/sql/"/>
    <url>/2023/03/02/sql/</url>
    
    <content type="html"><![CDATA[<p>11、避免sql注入</p><p><em><strong>SQL 注入（SQL Injection）</strong></em>，是 Web 开发中最常见的一种安全漏洞。</p><p>可以用它来从数据库获取敏感信息、利用数据库的特性执行添加用户、导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p><ol><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li><li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li><li>对进入数据库的特殊字符进行转义处理，或编码转换</li><li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li><li>发布前，利用工具进行 SQL 注入检测</li><li>报错信息不要包含 SQL 信息输出到 Web 页面</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>select原理和缺点</title>
    <link href="/2023/03/02/slio/"/>
    <url>/2023/03/02/slio/</url>
    
    <content type="html"><![CDATA[<p>select是一种IO多路复用计数，思想如下：</p><ol><li>要构造关于文件描述符的列表，将要监听的文件描述符添加到表中，列表的数据类型是fd_set，是一个整型数组，总共是1024bits，每一个bit表示一个文件描述符的事件，1代表检测，0代表不检测；</li><li>系统调用select()，监听列表中的文件描述符的事件，函数本身是阻塞的，直到文件描述符的一个或多个进行IO时，函数才返回，修改文件描述符的值，0为未检测到事件，1为检测到事件；</li><li>select()返回时，会告诉进程有多少描述符要进行IO操作，遍历列表IO。</li></ol><p>select同时也有缺点</p><ol><li>调用select就要要fd集合从用户态拷贝到内核态，开销很大；</li><li>内核要遍历所有fd；</li><li>支持的文件描述符数量太小，1024bits；</li><li>文件描述符集合不能重用，内核检测到事件就要修改，每次都要重置；</li><li>select只知道有几个fd发生事件，具体哪几个还要遍历集合才知道。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>联邦学习下的多视图聚类</title>
    <link href="/2023/02/27/fedmvc/"/>
    <url>/2023/02/27/fedmvc/</url>
    
    <content type="html"><![CDATA[<p>多视图聚类是指利用多个视图或特征描述同一组样本，在不同视图或特征空间中聚类样本。联邦学习是一种分布式机器学习框架，可以实现在数据分散的情况下进行模型训练。</p><p>在联邦学习中，多个设备或数据源共同训练模型，每个设备或数据源负责一部分数据，并通过模型的迭代来学习全局模型，从而避免了数据集中的隐私泄露问题。</p><p>在以联邦学习为背景的多视图聚类中，可以采用以下几种思路：</p><ol><li>基于<strong>模型</strong>的方法：在联邦学习框架下，利用各设备或数据源训练出的模型，对不同视图的数据进行预测，将预测结果作为新的特征，然后进行聚类。这种方法需要每个设备或数据源都具有相同的模型架构和参数设置。</li><li>基于<strong>特征</strong>的方法：在联邦学习框架下，将各设备或数据源的特征向量作为不同视图，在不同视图之间进行特征选择和特征融合，得到新的特征向量，然后进行聚类。</li><li>基于<strong>信息传递</strong>的方法：在联邦学习框架下，将各设备或数据源的聚类结果进行信息传递，利用传递的聚类结果得到新的特征向量，然后进行聚类。这种方法可以利用不同设备或数据源之间的信息交流和知识共享，提高聚类效果。</li><li>基于<strong>深度学习</strong>的方法：在联邦学习框架下，利用深度学习模型对不同视图的数据进行特征提取和特征融合，得到新的特征向量，然后进行聚类。这种方法需要在联邦学习框架下训练深度学习模型，并利用模型进行特征提取和融合。</li></ol><p>总之，基于联邦学习的多视图聚类需要充分利用各设备或数据源之间的信息交流和知识共享，结合不同视图之间的特征和模型，实现更精确和高效的聚类。</p>]]></content>
    
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库三个关键性能指标</title>
    <link href="/2023/02/23/mysqleff/"/>
    <url>/2023/02/23/mysqleff/</url>
    
    <content type="html"><![CDATA[<p>MySQL数据库三个关键性能指标</p><p><em><strong>TPS</strong></em></p><p>Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的事务数。</p><p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问。(业务TPS &#x3D; CAPS × 每个呼叫平均TPS)</p><p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p><p><em><strong>QPS</strong></em></p><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><p>对应fetches&#x2F;sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p><em><strong>IOPS</strong></em></p><p>IOPS (Input&#x2F;Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I&#x2F;O请求数量，一般以每秒处理的I&#x2F;O请求数量为单位，I&#x2F;O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(Online Transaction Processing)，IOPS是关键衡量指标。另一个重要指标是数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tcpip卷一协议知识总结</title>
    <link href="/2023/02/19/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/19/Tcpip%E5%8D%B7%E4%B8%80%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>第一章：概述</strong></p><p>1、制定协议来进行终端交流，IP、ICMP、TCP，自上向下：应用层、传输层、网络层、数据链路层、硬件层</p><p>2、域名系统，分布式数据库，host name转ip addr，学会rfc10几个协议即可，port用于tcp和udp的逻辑号码</p><p><strong>第二章：数据链路层</strong></p><p>1、ARP：ip地址转mac地址，以太网（网卡）协议，最大传输单元MTU，IP数据报过大则分片，环回接口（loopback）即本地</p><p><strong>第三章：IP协议、ARP协议</strong></p><p>1、IP协议作为核心，但其不可靠，可靠交托于上层协议，IP协议头包含，版本、首部长度、服务类型、字节数、标识、标志、片偏移、生存时间（tracerounter工作原理）、协议、首部校验和、源IP地址、目的IP地址、其他选项</p><p>2、子网寻址，IP地址等价于网络号+（子网号+）主机号，通过高速缓存表自查再广播，有则响应</p><p><strong>第四章：ICMP协议、ping和Traceroute</strong></p><p>1、IP不保证可靠，ICMP保证送达；some errors：主机不可达，路由不可达，给主机一个改错的机会，ICMP数据包由8bit错误类型，8bit代码和16bit校验和组成</p><p>2、ping声纳定位，类型码为0发出请求，收到请求的主机用类型码8回复，traceroute，解决ping的ip头限制问题，问udp是否到达主机，目的主机说端口不可达（port num&gt;30000）</p><p><strong>第五章：IP选路、动态选路</strong></p><p>1、5种flags，路由可用U，路由到网关G，路由到主机H，创建重定向报文D，路由被重定向报文修改M</p><p>2、动态选路协议，核心路由表（合适的网络），选择路由的协议，内部网关协议（IGP），OSPF取代RIP，两者都为代表</p><p>3、unix系统上通常有路由守护程序routed，另一个叫gate，RIP定义域RFC1058中，作为UDP的上层协议，以hop为计数器，即走过多少路由</p><p>4、对已知路由器发送rip请求报文，其他路由完整表；收到请求交表；接受回应并更新自己的路由表，使用小hop数；30s更新路由表，其弊端是无子网的概念，环路危险，hop限制网络大小</p><p><strong>第六章：UDP协议</strong></p><p>1、UDP协议头，包含了端口号、检验和、UDP长度</p><p>2、UDP和TCP设计伪首部来计算检验和，两次检查是否到达目的地，IP分片是根据MTU来，UDP发送前先要发送ARP以获得目的主机的MAC地址，UDP第一个分片发出ARP，分片等待</p><p>3、接受主机会给授予主机发ICMP处理不下报文，服务器泛化广播能力，服务器根据客户IP地址和端口号判断数据包合法不，并且服务器应该限制本地IP地址，依次绑定自己到网络接口的某一个端口上</p><p><strong>第七章：广播和多播、IGMP协议</strong></p><p>1、数据链路层数据头里具体的目的地址，以太网是MAC地址，路由即可定向单播，多播组是D类</p><p>2、广播和多播性质类似，路由器将数据放到局域网里，网卡对这些数据进行过滤，主机运行IP进程时，给网卡绑定虚拟多播IP地址，网卡让其进来从而实现通信，主机内核轻松，网卡忙点</p><p>3、IGMP让其他需要知道自己处于哪个多播组的主机和路由器知道自己的状态，多播组主机，多播组路由器，接受主机通过网卡过滤，路由器决定几个多播组</p><p><strong>第八章：DNS域名系统</strong></p><p>1、一个独立管理的DNS子树叫做zone，如二级域名，本身作为一个分布式数据库，转发至根服务器，自上而下转发查询，自带高速缓存，方便下次查询</p><p>2、DNS采取域名对应表查询，in-addr.arpa，大多数查询时UDP查询，TCP查询仅当查询数据产生了数据阶段，运用TCP的分片能力进行数据传输，辅服务器要拿主服务器的zone信息的时候</p><p><strong>第九章：TCP协议概述</strong></p><p>1、TCP面向连接，有ICMP差错检测报文，应用数据被分割成TCP满意的块，数据报长度保持不变，TCP发出段，启动一个定时器，超时重传</p><p>2、TCP保持首部和数据的校验和，记端到端的校验和，检测数据在传输过程的变化，IP数据报，TCP数据报都可能失序，TCP需要重排后交付应用层</p><p>3、TCP流量控制，防止接收端缓冲区溢出，可靠不得到不停止发送，TCP首部含更多信息</p><p><strong>第十章：TCP连接的建立与中止</strong></p><p>1、客户端向服务器申请开启某一端口，用于SYN段等于1的TCP报文，服务器端发回一个ACK报文，TCP全双工可以同时发送和接收，三次握手四次挥手的解释</p><p>2、建立连接确认对方的最大报文长度（MSS）以便于通信，SYN的长度是MTU减去固定IP首部和TCP首部的长度</p><p>3、客户端状态流程：CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</p><p>4、服务器状态流程：CLOSED-&gt;LISTEN-&gt;SYN-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED</p><p>5、MSL平静时间概念，应用程序无法使用插口，半关闭状态，应用程序有接受数据的能力，但无法发送数据，等应用层来决定关闭这个状态</p><p>6、UDP仅需输入队列，TCP对于每一个连接都要建立独立的进程，以保证对话的独立性，呼入连接请求队列，解释了各种TCP服务器都有一个最大连接数的原因，根据主机IP和端口号进行区分</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676452143517-845e2589-f3cb-427f-93d4-c36417850a25.png" alt="img"><a href="http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png">http://www.52im.net/data/attachment/forum/201607/12/110924s3zzfzfff8y1ht6x.png</a></p><p><strong>第十一章：TCP交互数据流、成块数据流</strong></p><p>1、以TCP协议为基础，建立在之上的协议有telnet、ssh、ftp、http等，根据数据的吞吐量又分为两大类：第一是交互数据类型，如telnet、ssh，做小流量的交换，敲击键盘回显文字，第二是数据成块类型，如ttp，要求TCP尽量运输数据，把数据吞吐量做大，提高效率</p><p>2、TCP交互数据流，就要想办法去降低网络负担，lo接口进行telnet通信，如按键过程，发送按键数据-服务器发送按键数据的ack-服务器端发送回显数据-客户端发送回显数据的ack，流量是40bit+41bit+41bit+40bit</p><p>3、两种策略，捎带ACK的发送方式，数据报不立刻处理，等待主机还有发送给远程主机的TCP数据报，时间一般设为200ms，另一种策略是Nagle算法，如BBS论坛帖子，数据稍等片刻一下就传过来了，TCP缓冲区只有一个TCP数据报，不断收集后来的数据，整合成一个大的数据报，等待响应主机的ACK报文，TCP_NODELAY来关闭此算法</p><p>4、TCP成块数据流，ftp接受延迟，因为其数据多，TCP协议中有16bit表示窗口的大小。发送端连续发送数据尽可能地填满接收端的缓冲区，接收端只需要发送一个ACK就好了，累积特性，减少了发送端和接受端的负担</p><p>5、滑动窗口本质是描述接收端TCP数据报缓冲区大小的数据，发送端以此发送数据，滑动窗口协议的三个术语，窗口合拢，窗口张开，窗口收缩，发送窗口范围里面的数据，窗口的大小通过socket来制定，4096非理想，16384可以使得吞吐量大大增加</p><p>6、数据拥塞，前面的策略用于局域网中，但在广域网中有问题，产生在slip低速链路的数据拥塞问题，TCP的解决方案是发送方确认连接双方的线路的数据最大吞吐量是多少，即拥塞窗口，其原理是TCP发送方发送一个数据报，等待对方的回应，得到回应后将窗口大小加倍，连续发送两个数据报，等到对方回应，再加倍，发送更多的数据报，知道超时报错，发送端就能知道通信双方线路的承载能力，即拥塞窗口的大小，传数据速度慢慢起来的</p>]]></content>
    
    
    
    <tags>
      
      <tag>my notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>more-effective-c++知识总结</title>
    <link href="/2023/02/16/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/16/more-effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/102990753">https://blog.csdn.net/fengbingchun/article/details/102990753</a></p><ol><li>指针和引用的区别，任何情况下都不能使用指向空值的引用，引用必须初始化</li><li>尽量使用C++风格的类型转换，static_cast、const_cast、dynamic_cast、reinterpret_cast，注意的是dynamic_cast是继承关系向下的类型转换</li><li>不要对数组使用多态，只要不从一个具体类派生出另一个具体类就好</li><li>避免无用的构造缺省函数，数组的raw memory分配可以避免内存的浪费，构造函数初始化对象，行为特性或数字相仿的对象被初始化为空值或不确定的值也是合理的，也有空容器，需要空间来容纳指针，实例化模板，模板的类型参数应该提供一个缺省构造函数</li><li>谨慎定义类型转换函数，有两种函数允许编译器进行隐式类型的转换，单参数构造函数和隐式类型转换运算符，构造函数使用explicit声明，编译器会拒绝为了隐式类型转换而调用构造函数</li><li>自增自减的前缀和后缀形式，处理用户定义的类型时，尽可能地使用前缀increment，只因效率高</li><li>不要重载&amp;&amp;，||和，操作符，解释是C++使用布尔表达式短路求值法，前部分判定后半部分不判了，分为全局重载和类内重载，函数参数地计算顺序不能被控制</li><li>理解不同含义的new和delete，即new operator和operator new的区别，作为内置的操作符，含义不能改变，功能分两部分，第一是分配足够的内存以容纳所需类型的对象，第二是调用构造函数初始化内存中的对象，operator new函数的返回值是void*，返回一个未初始化的指针，未初始化的内存，new用于堆上建立一个对象，分配内存然后定制operator new，再获得指针的内存里建立一个对象使用的是placement new，避免在内存中使用delete操作符</li><li>使用析构函数防止资源泄漏，不只是用于指针上，还可以用在其他资源的分配和释放上，资源应该被封装在一个对象里，智能指针就是基于此</li><li>在构造函数中防止资源泄漏，只有一个对象的构造函数完全运行完毕，对象才会被构造，构造函数try catch捕获所有的异常，用unique_ptr对象替代指针成员变量，就可以防止构造函数在异常时发生资源泄漏</li><li>禁止异常信息传递到析构函数外，第一是在异常传递的堆栈stack-unwinding过程，被terminate调用，第二是确保析构函数能完成任务</li><li>理解一个抛出一个异常与传递一个参数或调用一个虚函数之间的差异，程序的控制权最终还会返回到函数的调用处，异常的抛出不会返回到出现异常的地方，抛出的对象应该被复制，catch进行异常匹配有两种类型转换，第一是继承类和基类之间的转换，第二是允许类型指针转变成无类型指针，const void*捕获任意指针异常</li><li>通过引用捕获异常，有四个标准的额异常都不是指向对象的指针，bad_alloc，bad_cast，bad_typeid和bad_exception，分别对应的是不可分配，不可引用，不可操作空指针，unexception异常</li><li>审慎使用异常规格，函数抛出不在异常考虑的范围这样的异常，std::unexcepted调用std::terminate，然后再调用abort，从而避免了std::terminate</li><li>了解异常处理的系统开销，避免使用无用的try块</li><li>牢记80-20准则，即2成代码使用了8成的程序资源，2成代码耗用了8成的运行时间，2成代码使用了8成的内存，2成代码执行8成的磁盘访问，8成维护投入到2成代码上</li><li>考虑使用过lazy evaluation</li><li>分期摊还期望的计算，设计一个数据结构解决频繁运行的计算块，前面的lazy evaluation就是以此提高程序效率</li><li>理解临时对象的来源，未命名的临时对象在两种条件下产生，进行隐式类型转换和函数返回对象时使得函数调用成功</li><li>协助完成返回值优化，有些函数必须返回对象，这是它们的运行方法，C++允许编译器优化不出现的临时对象</li><li>通过重载避免隐式类型转换，重载运算符必须带有一个用户定义类型的参数，没有必要大量重载，除非效率上有相应的提升</li><li>考虑用运算符的赋值形式op&#x3D;来代替其单独形式op，确保operator的赋值形式与一个operator的单独形式存在正常的关系，后者+根据前者+&#x3D;来实现</li><li>考虑变更程序库，不同程序库在效率、可扩展性、移植性、类型安全和其它一些领域上蕴含着不同的设计理念</li><li>理解虚函数、多继承、虚基类和RTTI所需的代码，虚拟函数必须与调用函数的对象的动态类型一致，编译器使用vtbl和vptr，必须为包含虚函数的类留出vtbl空间，看不见的数据称为vptr，被编译器加在对象里，只有编译器知道，虚函数不能内联，内联的含义是指在编译期间用被调用的函数体来代替函数调用的指令，虚函数的虚体现在在运行时才知道调用的是哪一个函数，RTTI(运行时类型识别)能够帮助找到对象和类的有关信息，存储在type_info这个对象里，通过typeid操作符访问一个类的type_info对象</li><li>将构造函数和非成员函数虚拟化，虚拟构造函数返回一个指针，指向调用函数的对象的新拷贝，被派生类重定义的虚拟函数不用必须与基类的虚函数具有一样的返回类型</li><li>限制某个类所能产生的对象数量，阻止建立某个类的对象，方法是将该类的构造函数声明在类的private域中</li><li>要求或禁止在堆中产生对象，禁止用于调用new，利用new操作符总是调用operator new函数这点来达到目的，可声明为private</li><li>灵巧smart指针，使用到模板，应用领域有资源管理和重复代码任务的自动化，auto_ptr已在C++11抛弃，改用unique_ptr替代</li><li>引用计数，即允许多个有相同值的对象共享这个值的实现，两个动机，第一是简化跟踪堆中的对象的过程，一旦对象被new，就要记录对象的拥有者，所有者负责对对象进行delete，通过传递指针型参数将一个对象的所有权传递到另一个对象中，引用计数免除跟踪对象的所有权，第二是基于对象有相同的值，存储多次是无聊的，所以考虑让所有对象共享这个值的实现，节省内存</li><li>代理类，可以通过代理类实现二维数组，区分operator[]进行的操作是读还是写，proxy类可以完成三个行为，第一是多维数组，第二是左值右值的区分，第三是隐式类型转换的限制，缺点是proxy本身作为一个临时对象，必须被构造和析构</li><li>让函数根据一个以上的对象来决定怎么虚拟</li><li>在未来时态下开发程序，需要考虑到代码的可复用性、可维护性、健壮性以及环境移植性</li><li>将非尾端类设计为抽象类</li><li>如何在同一程序中混合使用C++和C，函数重载是C++的特性，extern C看作是声明这个函数是C写的一样进行调用，静态初始化，静态类对象和定义在全局的、命名空间中的文件体中的类对象构造函数通常在main被执行前被调用，动态内存分配建立在堆上，在同一程序下混合两者，有以下的指导原则：一是确保C++和C编译器产生兼容的obj文件，二是函数声明为extern C，三是只要可能就C++写main，四是勇敢delete释放new分配的内存，用free释放malloc分配的内存，五是将语言传递的东西限制在C编译的数据结构范围内</li><li>让自己习惯使用标准C++语言</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>my notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三握四挥</title>
    <link href="/2023/02/16/tcp34/"/>
    <url>/2023/02/16/tcp34/</url>
    
    <content type="html"><![CDATA[<p>TCP 是一种面向连接的可靠传输协议，使用三次握手建立连接可以保证连接的可靠性和安全性。</p><p>具体来说，三次握手的流程如下：</p><ol><li>客户端向服务器发送一个 SYN 报文，其中包含一个随机的初始序号。</li><li>服务器收到 SYN 报文后，向客户端回复一个 SYN+ACK 报文，其中确认客户端的初始序号，并发送一个随机的初始序号。</li><li>客户端收到 SYN+ACK 报文后，向服务器回复一个 ACK 报文，其中确认服务器的初始序号。</li></ol><p>通过三次握手，可以确保双方都已经认可对方的身份，并且双方都已经准备好发送和接收数据。如果使用两次握手，由于没有第三次确认，可能会存在一些潜在的安全问题，例如可能会被攻击者伪造的 SYN 报文欺骗，从而导致连接建立失败或者连接被攻击者劫持。</p><p>至于为什么不是四次握手，是因为建立连接和关闭连接的过程是不一样的。建立连接时需要客户端和服务器都进行确认，因此需要三次握手；而关闭连接时只需要一方发送 FIN 报文，另一方回复 ACK 报文即可，因此只需要四次握手。</p><p>CP 的四次挥手是用来关闭一个 TCP 连接的过程，具体流程如下：</p><ol><li>客户端发送一个 FIN 报文，请求关闭连接。</li><li>服务器收到 FIN 报文后，向客户端回复一个 ACK 报文，确认收到关闭请求。</li><li>服务器发送一个 FIN 报文，请求关闭连接。</li><li>客户端收到 FIN 报文后，向服务器回复一个 ACK 报文，确认收到关闭请求。</li></ol><p>通过四次挥手，双方都可以安全地关闭连接并释放相应的资源。需要注意的是，关闭连接的过程是一个异步的过程，可能会出现一些延迟，因此需要双方都进行确认才能确保连接被彻底关闭。</p><p>需要注意的是，四次挥手中，客户端和服务器各发送了一次 FIN 报文，因此总共需要四次握手才能完成连接的关闭。这也是为什么四次挥手比三次握手复杂的原因。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入地址后到渲染出数据的流程</title>
    <link href="/2023/02/14/xuanran/"/>
    <url>/2023/02/14/xuanran/</url>
    
    <content type="html"><![CDATA[<p>在浏览器输入地址后，通常经过以下流程来渲染出数据：</p><ol><li>DNS 解析：浏览器首先会将输入的域名解析为对应的 IP 地址，以便与服务器建立连接。如果 DNS 缓存中已经存在对应的 IP 地址，则可以直接跳过此步骤。</li><li>建立连接：浏览器通过 TCP&#x2F;IP 协议与服务器建立连接，建立连接过程中包括 TCP 的三次握手。</li><li>发送请求：浏览器向服务器发送 HTTP 请求，请求包括请求方法、请求头、请求体等信息。如果请求的资源需要认证，则会在请求头中加入相应的认证信息。</li><li>接收响应：服务器收到请求后会返回 HTTP 响应，响应包括响应头、响应体等信息。</li><li>解析 HTML：浏览器根据响应头中的 content-type 判断响应体的类型，如果是 HTML 页面，则浏览器会解析 HTML，构建 DOM 树和 CSSOM 树，形成渲染树。</li><li>布局和绘制：浏览器根据渲染树中的节点信息，计算节点在页面中的位置和大小等信息，进行布局，然后将节点绘制到屏幕上。</li><li>执行 JavaScript：如果页面中包含 JavaScript 代码，则浏览器会执行相应的 JavaScript 代码，可能会对 DOM 树和 CSSOM 树进行修改，从而触发页面的重新布局和绘制。</li><li>渲染完成：页面的渲染完成后，用户就可以在浏览器中看到相应的页面内容。</li></ol><p>需要注意的是，以上流程是一个简化的描述，实际上在浏览器的渲染过程中，还包括了很多细节和优化，例如缓存、预加载、资源压缩等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http 1.0/2/3优化</title>
    <link href="/2023/02/14/1-0-2-3%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/14/1-0-2-3%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>6、http1.0&#x2F;1 2 3优化</p><p><em><strong>HTTP1.0</strong></em></p><p>1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。</p><p>浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪也每个客户单，也不记录过去的请求（无状态）。</p><p>这种无状态性可以借助<strong>cookie&#x2F;session</strong>机制来做身份认证和状态记录。</p><p>无法复用连接</p><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p><p>队头阻塞（head of line blocking）</p><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p><p><em><strong>HTTP 1.1</strong></em></p><ul><li>长连接，流水线，使用connection:keep-alive使用长连接</li><li>请求管道化</li><li>增加缓存处理（新的字段如cache-control）</li><li>增加Host字段，支持断点传输等</li><li>由于长连接会给服务器造成压力</li></ul><p><em><strong>HTTP 2.0</strong></em></p><ul><li>二进制分帧</li><li>头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小</li><li>多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求</li><li>服务器推送（Sever push）</li></ul><p><em><strong>HTTP 3.0</strong></em></p><ul><li>基于google的QUIC协议，而quic协议是使用udp实现的</li><li>减少了tcp三次握手时间，以及tls握手时间</li><li>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题</li><li>优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗</li><li>连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接</li><li>更合适的流量控制</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步写入和同步写入</title>
    <link href="/2023/02/12/tongbuyibu/"/>
    <url>/2023/02/12/tongbuyibu/</url>
    
    <content type="html"><![CDATA[<p>同步写入是指当写入操作发生时，程序会一直等待直到写入完成，并且只有在写入完成后才会继续执行后续的代码。</p><p>异步写入是指当写入操作发生时，程序会立即返回并继续执行后续的代码，而不需要等待写入操作完成。这种方式可以提高程序的响应速度和吞吐量，但是也存在一定的风险，例如可能会导致数据丢失等问题。</p><p>当数据库在写入数据时宕机了，需要采取一些措施来处理这种情况。具体的解决方案可能因具体情况而异，但以下是一些常见的处理方式：</p><p><strong>数据备份</strong>：在宕机之前，定期备份数据库中的数据，以便在宕机后可以通过备份来恢复数据。</p><p><strong>事务处理</strong>：使用事务处理可以确保在执行多个操作时，如果其中一个操作失败，整个操作都会回滚，从而保证数据的一致性和完整性。</p><p><strong>写入缓存</strong>：使用写入缓存可以将数据先缓存到内存中，等到宕机之后再将数据写入磁盘中，从而减少数据丢失的风险。</p><p><strong>冗余备份</strong>：在多个服务器上备份相同的数据，当其中一个服务器宕机时，其他服务器可以继续提供服务，从而避免数据丢失。</p><p>无论采用何种处理方式，都需要对宕机的原因进行分析，并采取措施来防止类似的宕机事件再次发生。</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互斥锁和自旋锁</title>
    <link href="/2023/02/11/mutex/"/>
    <url>/2023/02/11/mutex/</url>
    
    <content type="html"><![CDATA[<p>互斥锁也是互斥量(Mutex)，作为保护临界区的特殊变量，两种状态locked和unlocked；</p><p>每个互斥锁内部有一个线程等待队列，用来保存互斥锁的线程，unlocked线程可得到锁，locked就阻塞到等待mutex的队列中。</p><p>自旋锁类似于互斥锁，不通过休眠阻塞进程，而是在获取锁之前一直处于忙则等待的状态，可以用于锁被持有时间短，线程无需额外调度的情况；自旋锁最多被一个进程所持有，若第二个线程申请，则会处于忙循环-旋转-等待锁重新可用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie总结</title>
    <link href="/2023/02/11/cookie%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/11/cookie%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>8、cookie</p><p><strong>cookie</strong>是当前识别用户，实现持久化会话的最好方式。简单点说就是服务器知道正在和哪个客户端通信，以及保持与已识别出的客户端通信。Cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它。同时可以对连接另一端的用户有更多的了解，并且能在用户浏览页面时对其进行跟踪。</p><p><strong>cookie</strong>可以分为以下两类：</p><p>（1）会话cookie。临时cookie，记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除了。</p><p>（2）持久cookie。持久cookie的生存时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。</p><p>唯一区别就是它们的过期时间。如果设置了Discard参数或没有设置Expires或没有设置Max-Age参数则说明这个cookie就是一个会话cookie。</p><p><strong>存储</strong>——浏览器负责存储cookie信息。不同的浏览器会以不同的方式来存储cookie。有的浏览器用cookis.txt存储。有的浏览器存储在高速缓存目录下独立的文本文件中。</p><p><strong>cookie</strong>存在安全隐患。第三方Web站点使用持久cookie来跟踪用户就是对cookie一种最大的滥用。将这种做法与IP地址和Referer首部信息结合在一起，这些营销公司就可以构建起相当精确的用户档案和浏览模式信息。</p><p><strong>cookie工作原理</strong></p><p>（1）用户首次访问Web站点时，Web服务器对用户一无所知。</p><p>（2）Web服务器通过Set-Cookie首部将cookie存放到浏览器中的cookie数据库中。cookie中包含了N个键值对，例如Cookie: id&#x3D;“1234”。cookie中可以包含任意信息，但它们通常都只包含一个服务器为了进行跟踪而产生的独特的识别码。</p><p>（3）将来用户再次访问同一站点时，浏览器会从cookie数据库中挑中那个服务器设置的cookie，并在cookie请求首部中（Cookie: id&#x3D;“1234”）将其传回给服务器。</p><p>（4）服务器可以通过id&#x3D;”1234”这个键值对来查找服务器为其访问积累的信息（购物历史、地址信息等）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接雨水两侧动规问题</title>
    <link href="/2023/02/09/jieyushui/"/>
    <url>/2023/02/09/jieyushui/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/jieyushui.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i)<br>            left[i] = <span class="hljs-built_in">max</span>(left[i<span class="hljs-number">-1</span>], height[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; --i)<br>            right[i] = <span class="hljs-built_in">max</span>(right[i+<span class="hljs-number">1</span>], height[i+<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> water = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br>            <span class="hljs-type">int</span> level = <span class="hljs-built_in">min</span>(left[i], right[i]);<br>            water += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, level-height[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> water;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键在于表示从左和从右的高度，以及用最小的高度乘上间距即是容积.</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reator网络编程模型</title>
    <link href="/2023/02/08/reactor/"/>
    <url>/2023/02/08/reactor/</url>
    
    <content type="html"><![CDATA[<p>Reator网络编程模型</p><p>首先介绍下Reactor这一网络编程模型，I&#x2F;O多路复用可以用作并发事件驱动(<strong>event-driven</strong>)程序的基础，即整个事件驱动模型是一个状态机，包含了状态(state), 输入事件(input-event), 状态转移(transition), 状态转移即状态到输入事件的一组映射。通过I&#x2F;O多路复用的技术检测事件的发生，并根据具体的事件(通常为读写)，进行不同的操作，即<strong>状态转移</strong>。</p><p>Reactor模式是一种典型的事件驱动的编程模型，Reactor逆置了程序处理的流程，其基本的思想即为Hollywood Principle— ‘Don’t call us, we’ll call you’.</p><p>Reactor事件处理机制为：主程序将事件以及对应事件处理的方法在Reactor上进行注册, 如果相应的事件发生，Reactor将会主动调用事件注册的接口，即 <strong>回调函数</strong>. libevent即为封装了epoll并注册相应的事件(I&#x2F;O读写，时间事件，信号事件)以及回调函数，实现的事件驱动的框架。</p><p>Reactor事件处理机制的编程模型，在Redis中也得到了很好的运用，Redis中基于I&#x2F;O多路复用(mutiplexing) 开发Reactor事件处理机制，监听多个套接字的AE_READABLE读，AE_WRITABLE写事件。读事件绑定读操作和具体执行命令的操作函数，写事件绑定命令回复的操作函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">register_handler</span><span class="hljs-params">(EventHandler *pHandler, <span class="hljs-type">int</span> event)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">remove_handler</span><span class="hljs-params">(EventHandler *pHandler, <span class="hljs-type">int</span> event)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_events</span><span class="hljs-params">(timeval *ptv)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件管理的接口，内部使用event demultiplexer注册，注销事件；并运行事件循环，当有事件进入”就绪”状态时，调用注册事件的回调函数处理事件。event demultiplexer通常是由操作系统提供的I&#x2F;O多路复用的机制，例如select, epoll. 程序首先将handler（事件源）以及对应的事件注册到event demultiplexer上；当有事件到达时，event demultiplexer就会发出通知，通知Reactor调用事件处理程序进行处理。event handler事件处理程序提供了一组接口，在Reactor相应的事件发生时调用，执行相应的事件处理，通常会绑定一个有效的handler。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event_Handler</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// events maybe read/write/timeout/close .etc</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle_events</span><span class="hljs-params">(<span class="hljs-type">int</span> events)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> HANDLE <span class="hljs-title">get_handle</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件驱动的一般模型，利用linux select epoll模型，注册相应的回调函数对应不同的事件，根据I&#x2F;O多路复用的机制，实现高并发，高可扩展性。</p><p><em><strong>flow：</strong></em></p><ol><li>registerhandler() </li><li>handle_events()</li><li>select()</li><li>connect()</li><li>handleevent()</li><li>accept()</li><li>create()</li><li>registerhandler()</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EventType;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Epoll</span> &#123;<br>    <span class="hljs-comment">// 封装了epoll I/O 多路复用的机制, Event demultiplexer</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NO_FLAGS = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_INDEFINITELY = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EVENTS = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-built_in">Epoll</span>() &#123;<br>        fileDescriptor = <span class="hljs-built_in">epoll_create1</span>(NO_FLAGS);<br>        event.data.fd = STDIN_FILENO;<br>        <span class="hljs-comment">// 设置epoll event 为EPOLLIN(对应文件描述符可读)， EPOLLPRI(对应文件描述符有紧急事件可读)</span><br>        event.events = EPOLLIN | EPOLLPRI;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">epoll_wait</span>(fileDescriptor, events.<span class="hljs-built_in">data</span>(), MAX_EVENTS, BLOCK_INDEFINITELY);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">control</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">epoll_ctl</span>(fileDescriptor, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Epoll</span>() &#123;<br>        <span class="hljs-built_in">close</span>(fileDescriptor);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> fileDescriptor;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span><br>            event;<br>    std::array&lt;epoll_event, MAX_EVENTS&gt; events&#123;&#125;;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHandler</span> &#123;<br>    <span class="hljs-comment">// Event Handler</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handle_event</span><span class="hljs-params">(EventType et)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Event Handler: &quot;</span> &lt;&lt; et &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> &#123;<br>    <span class="hljs-comment">// Dispatcher</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Reactor</span>() &#123;<br>        epoll.<span class="hljs-built_in">control</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//注册对应的回调函数到handlers中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addHandler</span><span class="hljs-params">(std::string event, EventHandler callback)</span> </span>&#123;<br>        handlers.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(event), std::<span class="hljs-built_in">move</span>(callback));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> numberOfEvents = <span class="hljs-built_in">wait</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numberOfEvents; ++i) &#123;<br>                std::string input;<br>                std::<span class="hljs-built_in">getline</span>(std::cin, input);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 根据的具体的事件去找对应的handler，并执行相应的操作</span><br>                    handlers.<span class="hljs-built_in">at</span>(input).<span class="hljs-built_in">handle_event</span>(<span class="hljs-built_in">EventType</span>(i));<br>                &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::out_of_range &amp;e) &#123;<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;no  handler for &quot;</span> &lt;&lt; input &lt;&lt; std::endl;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// handlers Table, 存储事件以及其对应的handlers</span><br>    std::unordered_map&lt;std::string, EventHandler&gt; handlers&#123;&#125;;<br>    Epoll epoll;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> numberOfEvents = epoll.<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-keyword">return</span> numberOfEvents;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Reactor reactor;<br><br>    reactor.<span class="hljs-built_in">addHandler</span>(<span class="hljs-string">&quot;a&quot;</span>, EventHandler&#123;&#125;);<br>    reactor.<span class="hljs-built_in">addHandler</span>(<span class="hljs-string">&quot;b&quot;</span>, EventHandler&#123;&#125;);<br>    reactor.<span class="hljs-built_in">run</span>();<br>&#125; <br></code></pre></td></tr></table></figure><p>总结：reactor本质上就是在linux线程等待IO时，CPU切换到其他线程执行</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库关键代码及思想</title>
    <link href="/2023/02/07/muduo/"/>
    <url>/2023/02/07/muduo/</url>
    
    <content type="html"><![CDATA[<p>Muduo库关键代码及思想</p><p>Muduo库是基于Reactor模式实现的TCP网络编程库。Muduo库有三个核心组件支撑一个reactor实现 [<strong>持续</strong>] 的 [<strong>监听</strong>] 一组fd，并根据每个fd上发生的事件 [<strong>调用</strong>] 相应的处理函数。这三个组件分别是Channel类、Poller&#x2F;EpollPoller类以及EventLoop类。</p><p><strong>Channel类其实相当于一个文件描述符的保姆</strong></p><p>在TCP网络编程中，想要IO多路复用监听某个文件描述符，就要把这个fd和该fd感兴趣的事件通过epoll_ctl<strong>注册</strong>到IO多路复用模块上。当事件监听器监听到该fd发生了某个事件。事件监听器返回 [发生事件的fd集合]以及[每个fd都发生了什么事件]。</p><p>Channel类则封装了一个 [fd] 和这个 [fd感兴趣事件] 以及事件监听器监听到 [该fd实际发生的事件]。同时Channel类还提供了<strong>设置</strong>该fd的感兴趣事件，以及将该fd及其感兴趣事件<strong>注册</strong>到事件监听器或从事件监听器上<strong>移除</strong>，以及<strong>保存</strong>了该fd的每种事件对应的处理函数。</p><p><strong>负责监听文件描述符事件是否触发</strong>以及<strong>返回发生事件的文件描述符以及具体事件</strong>的模块就是Poller。所以<strong>一个Poller对象对应一个事件监听器</strong>（这里我不确定要不要把Poller就当作事件监听器）。在multi-reactor模型中，有多少reactor就有多少Poller。</p><p>muduo提供了epoll和poll两种IO多路复用方法来实现事件监听。不过默认是使用epoll来实现，也可以通过选项选择poll。但是我自己重构的muduo库只支持epoll。</p><p>这个Poller是个抽象虚类，由EpollPoller和PollPoller继承实现，与监听文件描述符和返回监听结果的具体方法也基本上是在这两个派生类中实现。EpollPoller就是封装了用epoll方法实现的与事件监听有关的各种方法，PollPoller就是封装了poll方法实现的与事件监听有关的各种方法。</p><p>Poller封装了和事件监听有关的方法和成员，调用一次Poller::poll方法它就能给你返回事件监听器的监听结果（发生事件的fd 及其 发生的事件）。作为一个网络服务器，需要有持续监听、持续获取监听结果、持续处理监听结果对应的事件的能力，也就是我们需要<strong>循环</strong>的去 【调用Poller:poll方法获取实际发生事件的Channel集合，然后调用这些Channel里面保管的不同类型事件的处理函数（调用Channel::HandlerEvent方法）。】</p><p>EventLoop就是负责实现<strong>“循环”</strong>，负责驱动<strong>“循环”</strong>的重要模块！！Channel和Poller其实相当于EventLoop的手下，EventLoop整合封装了二者并向上提供了更方便的接口来使用。</p><p>TCP网络编程的本质其实是处理下面这几个事件：</p><ul><li>连接的建立。</li><li>连接的断开：包括主动断开和被动断开。</li><li>消息到达，客户端连接文件描述符可读。</li><li>消息发送，向客户端连接文件描述符写数据。</li></ul><p>Echo服务器的搭建代码逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EventLoop loop;<br>    <span class="hljs-comment">//这个EventLoop就是main EventLoop，即负责循环事件监听处理新用户连接事件的事件循环器。第一章概述篇的图2里面的EventLoop1就是我们的main EventLoop。</span><br>    <br>    <span class="hljs-function">InetAddress <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-number">4567</span>)</span></span>;<br>    <span class="hljs-comment">//InetAddress其实是对socket编程中的sockaddr_in进行封装，使其变为更友好简单的接口而已。</span><br>    <br>    <span class="hljs-function">EchoServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;loop, addr, <span class="hljs-string">&quot;EchoServer-01&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//EchoServer类，自己等一下往下翻一下。</span><br>    <br>    server.<span class="hljs-built_in">start</span>(); <br>    <span class="hljs-comment">//启动TcpServer服务器</span><br>    <br>    loop.<span class="hljs-built_in">loop</span>(); <span class="hljs-comment">//执行EventLoop::loop()函数，这个函数在概述篇的EventLoop小节有提及，自己去看一下！！</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EchoServer</span>(EventLoop *loop,<br>            <span class="hljs-type">const</span> InetAddress &amp;addr, <br>            <span class="hljs-type">const</span> std::string &amp;name)<br>        : <span class="hljs-built_in">server_</span>(loop, addr, name)<br>        , <span class="hljs-built_in">loop_</span>(loop)<br>    &#123;<br>        server_.<span class="hljs-built_in">setConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1)<br>        );<br>        <span class="hljs-comment">// 将用户定义的连接事件处理函数注册进TcpServer中，TcpServer发生连接事件时会执行onConnection函数。</span><br>            <br>        server_.<span class="hljs-built_in">setMessageCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onMessage, <span class="hljs-keyword">this</span>,<br>                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)<br>        );<br>        <span class="hljs-comment">//将用户定义的可读事件处理函数注册进TcpServer中，TcpServer发生可读事件时会执行onMessage函数。</span><br><br>        <br>        server_.<span class="hljs-built_in">setThreadNum</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置sub reactor数量，你这里设置为3，就和概述篇图2中的EventLoop2 EventLoop3 EventLoop4对应，有三个sub EventLoop。</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        server_.<span class="hljs-built_in">start</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//用户定义的连接事件处理函数：当服务端接收到新连接建立请求，则打印Connection UP，如果是关闭连接请求，则打印Connection Down</span><br>        <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">connected</span>())<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn,</span></span><br><span class="hljs-params"><span class="hljs-function">                   Buffer *buf,</span></span><br><span class="hljs-params"><span class="hljs-function">                   Timestamp time)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//用户定义的可读事件处理函数：当一个Tcp连接发生了可读事件就把它这个接收到的消息原封不动的还回去</span><br>        std::string msg = buf-&gt;<span class="hljs-built_in">retrieveAllAsString</span>();<br>        conn-&gt;<span class="hljs-built_in">send</span>(msg);<br>        conn-&gt;<span class="hljs-built_in">shutdown</span>(); <br>    &#125;<br>    EventLoop *loop_;<br>    TcpServer server_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简单总结为以下几步：</p><ol><li>建立事件循环器EventLoop: EventLoop loop;</li><li>建立服务器对象，即TcpServer类对象 : TcpServer server_;</li><li>向TcpServer注册各类事件的用户自定义的处理函数: setMessageCallback()、setConnectionCallback();</li><li>启动server：server.start();</li><li>开启事件循环: loop.loop()。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++14和C++17新特性</title>
    <link href="/2023/02/07/cpp147/"/>
    <url>/2023/02/07/cpp147/</url>
    
    <content type="html"><![CDATA[<p><strong>相关代码操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* auto */</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器自动推导 i 的类型为 int</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 编译器自动推导 d 的类型为 double</span><br><span class="hljs-comment">/* lambda */</span><br><span class="hljs-keyword">auto</span> add = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;; <span class="hljs-comment">// 使用泛型 lambda</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// sum = 3</span><br><span class="hljs-type">double</span> product = <span class="hljs-built_in">add</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.0</span>); <span class="hljs-comment">// product = 5.5</span><br><span class="hljs-comment">/* std::male_unique */</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-comment">/* std::exchange */</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> b = std::<span class="hljs-built_in">exchange</span>(a, <span class="hljs-number">1</span>); <span class="hljs-comment">// 将 a 的值原子地设为 1，并返回 a 原来的值</span><br><span class="hljs-comment">/* std::quoted */</span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">quoted</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>); <span class="hljs-comment">// 输出 &quot;Hello, world!\n&quot;</span><br><span class="hljs-comment">/* if constexpr */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The integer is &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The non-integer is &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 输出 &quot;The integer is 42&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 输出 &quot;The non-integer is hello&quot;</span><br><span class="hljs-comment">/* 结构化绑定 */</span><br>std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p&#123;<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>&#125;;<br><span class="hljs-keyword">auto</span> [i, d] = p; <span class="hljs-comment">// 将 p 的两个成员变量分别绑定到 i 和 d</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; d &lt;&lt; std::endl; <span class="hljs-comment">// 输出 &quot;42, 3.14&quot;</span><br><span class="hljs-comment">/* std::variant */</span><br>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; v; <span class="hljs-comment">// 定义一个可以存储 int、double、std::string 类型的 std::variant</span><br>v = <span class="hljs-number">42</span>; <span class="hljs-comment">// 存储一个 int 类型的值</span><br><span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(v); <span class="hljs-comment">// 从 std::variant 中获取 int 类型的值</span><br><span class="hljs-comment">/* std::optional */</span><br>std::optional&lt;<span class="hljs-type">int</span>&gt; opt; <span class="hljs-comment">// 定义一个可能不存在的 int 类型的值</span><br><span class="hljs-keyword">if</span> (opt) &#123; <span class="hljs-comment">// 判断是否存在值</span><br>    <span class="hljs-type">int</span> i = *opt; <span class="hljs-comment">// 获取值</span><br>&#125;<br><span class="hljs-comment">/* std::filesystem */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><span class="hljs-keyword">namespace</span> fs = std::filesystem;<br><br>fs::<span class="hljs-built_in">create_directory</span>(<span class="hljs-string">&quot;mydir&quot;</span>); <span class="hljs-comment">// 创建一个名为 &quot;mydir&quot; 的目录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : fs::<span class="hljs-built_in">directory_iterator</span>(<span class="hljs-string">&quot;mydir&quot;</span>)) &#123; <span class="hljs-comment">// 遍历目录中的文件和目录</span><br>    <span class="hljs-keyword">if</span> (fs::<span class="hljs-built_in">is_directory</span>(p)) &#123;<br>        std::cout &lt;&lt; p.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">&quot; is a directory&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; p.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">&quot; is a file&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道基础算法</title>
    <link href="/2023/02/06/%E4%B8%A4%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/06/%E4%B8%A4%E9%81%93%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>16、Q1：整数与ip地址的转换；Q2：小q第一天挖11币，第二天比前一天少一个币，以此类推，但休息一天又可以挖到11币,问第n天能挖多少币</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* ip转无符号数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">ipToInt</span><span class="hljs-params">(string ip)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = ip.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; ipList;<br>    <span class="hljs-comment">//split</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; l &amp;&amp; ip[j] != <span class="hljs-string">&#x27;.&#x27;</span>) j++;<br>        ipList.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(ip.<span class="hljs-built_in">substr</span>(i, j - i)));<br>        i = j;<br>    &#125;<br>    <span class="hljs-type">int</span> n = ipList.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">unsigned</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res = res &lt;&lt; <span class="hljs-number">8</span> | ipList[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 无符号数转ip</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">intToIp</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> num)</span> </span>&#123;<br>    vector&lt;string&gt; ipList;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>        string seg = <span class="hljs-built_in">to_string</span>(num &amp; <span class="hljs-number">255</span>);<br>        ipList.<span class="hljs-built_in">push_back</span>(seg);<br>        num = num &gt;&gt; <span class="hljs-number">8</span>;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ipList.<span class="hljs-built_in">begin</span>(), ipList.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>) res += ipList[i];<br>        <span class="hljs-keyword">else</span> res += ipList[i] + <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 递减累和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addArr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        res += n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*小q挖币</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qCoin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">1</span>);<br>    dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">2</span>);<br>    dp[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">3</span>);<br>    dp[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">4</span>);<br>    dp[<span class="hljs-number">6</span>] = <span class="hljs-number">6</span>*dp[<span class="hljs-number">1</span>]-<span class="hljs-built_in">addArr</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> dp[n];<br>    <span class="hljs-comment">// 周期循环的思想</span><br>    <span class="hljs-type">int</span> times = n / <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> tail = n % <span class="hljs-number">6</span>;<br>dp[times*<span class="hljs-number">6</span>] = times*dp[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">if</span>(tail==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[times*<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tail;++i) &#123;<br>        dp[times*<span class="hljs-number">6</span>+i] = dp[times*<span class="hljs-number">6</span>] + dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的unicode</title>
    <link href="/2023/02/06/C-%E4%B8%AD%E7%9A%84unicode/"/>
    <url>/2023/02/06/C-%E4%B8%AD%E7%9A%84unicode/</url>
    
    <content type="html"><![CDATA[<p>7、utf8，utf16区别，c++用哪个</p><p><strong>UTF-8(8-bit Unicode Transformation Format)</strong></p><p>UTF-8是一种变长编码，对于一个Unicode的字符被编码成1至4个字节</p><p>优点:<br>1.向后兼容ASCII编码；<br>2.没有字节序(大小端)的问题适合网络传输；<br>3.存储英文和拉丁文等字符非常节省存储空间。<br>缺点:<br>1.变长编码不利于文本处理；<br>2.对于CJK等文字比较浪费存储空间。</p><p><strong>UTF-16(16-bit Unicode Transformation Format)</strong></p><p>UTF-16也是一种变长编码，对于一个Unicode字符被编码成1至2个码元，每个码元为16位</p><p>优点:<br>1.绝大部分的文字都可以用两个字节编码，对于CJK文字是比较节省空间的；<br>2.文本处理比UTF-8方便得多。<br>缺点:<br>1.存储和传输需要考虑字节序的问题；<br>2.不兼容ASCII。</p><p><strong>USL（Unicode String Literals）</strong>是C++11对Unicode提供的语言级别的支持。在C++11之前C++中有个<strong>wchar_t</strong>的类型用于存储宽字符（Wide-Character）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UTFCONVERT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UTFCONVERT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br> <br><span class="hljs-comment">// 从UTF16编码字符串构建，需要带BOM标记</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 从UTF16 LE编码的字符串创建</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16le_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 从UTF16BE编码字符串创建</span><br><span class="hljs-function">std::string <span class="hljs-title">utf16be_to_utf8</span><span class="hljs-params">(<span class="hljs-type">const</span> std::u16string&amp; u16str)</span></span>;<br> <br><span class="hljs-comment">// 获取转换为UTF-16 LE编码的字符串</span><br><span class="hljs-function">std::u16string <span class="hljs-title">utf8_to_utf16le</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; u8str, <span class="hljs-type">bool</span> addbom = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span>* ok = <span class="hljs-literal">NULL</span>)</span></span>;<br> <br><span class="hljs-comment">// 获取转换为UTF-16 BE的字符串</span><br><span class="hljs-function">std::u16string <span class="hljs-title">utf8_to_utf16be</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; u8str, <span class="hljs-type">bool</span> addbom = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span>* ok = <span class="hljs-literal">NULL</span>)</span></span>;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//! __UTFCONVERT_H__</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL设计知识总结</title>
    <link href="/2023/02/04/STL%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/04/STL%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/fengbingchun/article/details/103223914">https://blog.csdn.net/fengbingchun/article/details/103223914</a></p><ol><li>慎重选择容器类型，序列容器，关联容器，非STL容器，对STL进行分类，连续内存容器(vector、string、deque)和基于节点的容器(list、forward_list)，容器内部的引用计数技术，rope基于引用计数，本身是用可持久化平衡树实现的重型string<img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1677981449440-89bff10a-e505-4057-bc6d-49ae3aad5afa.png" alt="img"></li><li>STL本身是泛化，不写独立于容器类型的代码，数组泛化为以其包含对象类型为参数的容器，函数泛化为以其使用的迭代器类型为参数的算法，将容器隐藏到一个类中，以减少通过类接口与容器相关的信息</li><li>确保容器中的对象拷贝正确高效，对象是其拷贝在容器中，取出对象也是对象的拷贝，存在继承关系时，拷贝会导致剥离，防止子对象特有信息丢失就是使容器包含指针</li><li>调用empty检测size()是否为0</li><li>区间成员函数优先于与之对应的单元素成员函数，用两个迭代器确定成员操作所执行的区间，推荐assign和insert，清楚表达意图，表现更高效率</li><li>视情况使用命名迭代器对象</li><li>容器中包含new指针，在析构前delete掉指针，为避免资源泄漏，必须用引用计数计数形式的智能指针对象代替指针</li><li>切勿创建包含auto_ptr的容器对象，创建后即转移对象的所有权，包含智能指针没问题</li><li>慎用选择删除元素的方法，对于vector、string或deque这样的容器，erase-remove是删除特定值元素的最好办法，list对应list::remove，关联map这样的容器使用erase，判别式加if，遍历容器元素，返回值更新迭代器，关联容器则后缀递增</li><li>分配子的约定和限制</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>my notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>thoughts</title>
    <link href="/2023/02/04/thoughts/"/>
    <url>/2023/02/04/thoughts/</url>
    
    <content type="html"><![CDATA[<p>修bug真的是好烦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>my os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebServer压力测试</title>
    <link href="/2023/02/04/webbench/"/>
    <url>/2023/02/04/webbench/</url>
    
    <content type="html"><![CDATA[<p>短连接测试结果</p><p><img src="/../picture/duanlianjie.png"></p><p>长连接测试结果</p><p><img src="/../picture/changlianjie.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebServer项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebServer连接维护</title>
    <link href="/2023/02/03/webserver-conn/"/>
    <url>/2023/02/03/webserver-conn/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>建立连接的过程</strong><br>连接的建立比较简单，server端通过socket()，bind()，listen()，并使用epoll ET模式监听listenfd的读请求，当TCP连接完成3次握手后，会触发listenfd的读事件，应用程序调用accept()，会检查已完成的连接队列，如果队列里有连接，就返回这个连接，出错或连接为空时返回-1。此时，已经可以进行正常的读写操作了。 当然，因为是ET模式，accept()要一直循环到就绪连接为空。</li><li><strong>分析</strong><br>之所以说建立连接的过程比较简单，是因为数据的通信已经由操作系统帮我们完成了，这里的通信是指3次握手的过程，这个过程不需要应用程序参与，当应用程序感知到连接时，此时该连接已经完成了3次握手的过程，accept就好了。另一个原因是一般情况下，连接的建立都是client发起的，server端被动建立连接就好了，也不会出现同时建立的情况。</li><li><strong>限制</strong><br>假设server只监听一个端口，一个连接就是一个四元组(原ip，原port，对端ip, 对端port)，那么理论上可以建立2^48个连接，可是，fd可没有这么多(操作系统限制、用户进程限制)。当连接满了，如果空等而不连接，那么就绪队列也满了后，会导致新连接无法建立。这里的做法我参考了muduo，准备一个空的文件描述符，accept()后直接close()，这样对端不会收到RST，至少可以知道服务器正在运行。</li></ul><p>通常server和client都可以主动发Fin来关闭连接</p><ul><li>对于client(非Keep-Alive)，发送完请求后就可以shutdown()写端，然后收到server发来的应答，最后close掉连接。也可以不shutdown()写，等读完直接close。对于Keep-Alive的情况，就要看client的心情了，收到消息后可以断，也可以不断，server应该保证不主动断开。</li><li>对于server端，毫无疑问应该谨慎处理以上所有情况。具体说来:</li><li>出现各种关于连接的错误时，可以直接close()掉</li><li>短连接超时的请求，可以close()，也可以不关</li><li>长连接对方长时间没有请求(如果没有保活机制)，可以close()，也可以不关</li><li>client发出Fin，server会收到0字节，通常不能判断client是close了还是shutdown，这时server应当把消息发完，然后才可以close()，如果对方调用的是close，会收到RST，server能感知到，就可以立即close了</li><li>短连接正常结束，server可以close，也可以不close，大多数的实现是不close的(对HTTP1.1而言)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// server端的socket,bind和listen</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Server.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Util.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;base/Logging.h&quot;</span></span><br><br>Server::<span class="hljs-built_in">Server</span>(EventLoop *loop, <span class="hljs-type">int</span> threadNum, <span class="hljs-type">int</span> port)<br>    : <span class="hljs-built_in">loop_</span>(loop),<br>      <span class="hljs-built_in">threadNum_</span>(threadNum),<br>      <span class="hljs-built_in">eventLoopThreadPool_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThreadPool</span>(loop_, threadNum)),<br>      <span class="hljs-built_in">started_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">acceptChannel_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Channel</span>(loop_)),<br>      <span class="hljs-built_in">port_</span>(port),<br>      <span class="hljs-built_in">listenFd_</span>(<span class="hljs-built_in">socket_bind_listen</span>(port_)) &#123;<br>  acceptChannel_-&gt;<span class="hljs-built_in">setFd</span>(listenFd_);<br>  <span class="hljs-built_in">handle_for_sigpipe</span>();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setSocketNonBlocking</span>(listenFd_) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;set socket non block failed&quot;</span>);<br>    <span class="hljs-built_in">abort</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::start</span><span class="hljs-params">()</span> </span>&#123;<br>  eventLoopThreadPool_-&gt;<span class="hljs-built_in">start</span>();<br>  <span class="hljs-comment">// acceptChannel_-&gt;setEvents(EPOLLIN | EPOLLET | EPOLLONESHOT);</span><br>  acceptChannel_-&gt;<span class="hljs-built_in">setEvents</span>(EPOLLIN | EPOLLET);<br>  acceptChannel_-&gt;<span class="hljs-built_in">setReadHandler</span>(<span class="hljs-built_in">bind</span>(&amp;Server::handNewConn, <span class="hljs-keyword">this</span>));<br>  acceptChannel_-&gt;<span class="hljs-built_in">setConnHandler</span>(<span class="hljs-built_in">bind</span>(&amp;Server::handThisConn, <span class="hljs-keyword">this</span>));<br>  loop_-&gt;<span class="hljs-built_in">addToPoller</span>(acceptChannel_, <span class="hljs-number">0</span>);<br>  started_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handNewConn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_addr;<br>  <span class="hljs-built_in">memset</span>(&amp;client_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br>  <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>  <span class="hljs-type">int</span> accept_fd = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ((accept_fd = <span class="hljs-built_in">accept</span>(listenFd_, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr,<br>                             &amp;client_addr_len)) &gt; <span class="hljs-number">0</span>) &#123;<br>    EventLoop *loop = eventLoopThreadPool_-&gt;<span class="hljs-built_in">getNextLoop</span>();<br>    LOG &lt;&lt; <span class="hljs-string">&quot;New connection from &quot;</span> &lt;&lt; <span class="hljs-built_in">inet_ntoa</span>(client_addr.sin_addr) &lt;&lt; <span class="hljs-string">&quot;:&quot;</span><br>        &lt;&lt; <span class="hljs-built_in">ntohs</span>(client_addr.sin_port);<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;new connection&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">// cout &lt;&lt; inet_ntoa(client_addr.sin_addr) &lt;&lt; endl;</span><br>    <span class="hljs-comment">// cout &lt;&lt; ntohs(client_addr.sin_port) &lt;&lt; endl;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    // TCP的保活机制默认是关闭的</span><br><span class="hljs-comment">    int optval = 0;</span><br><span class="hljs-comment">    socklen_t len_optval = 4;</span><br><span class="hljs-comment">    getsockopt(accept_fd, SOL_SOCKET,  SO_KEEPALIVE, &amp;optval, &amp;len_optval);</span><br><span class="hljs-comment">    cout &lt;&lt; &quot;optval ==&quot; &lt;&lt; optval &lt;&lt; endl;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 限制服务器的最大并发连接数</span><br>    <span class="hljs-keyword">if</span> (accept_fd &gt;= MAXFDS) &#123;<br>      <span class="hljs-built_in">close</span>(accept_fd);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设为非阻塞模式</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setSocketNonBlocking</span>(accept_fd) &lt; <span class="hljs-number">0</span>) &#123;<br>      LOG &lt;&lt; <span class="hljs-string">&quot;Set non block failed!&quot;</span>;<br>      <span class="hljs-comment">// perror(&quot;Set non block failed!&quot;);</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">setSocketNodelay</span>(accept_fd);<br>    <span class="hljs-comment">// setSocketNoLinger(accept_fd);</span><br><br>    <span class="hljs-function">shared_ptr&lt;HttpData&gt; <span class="hljs-title">req_info</span><span class="hljs-params">(<span class="hljs-keyword">new</span> HttpData(loop, accept_fd))</span></span>;<br>    req_info-&gt;<span class="hljs-built_in">getChannel</span>()-&gt;<span class="hljs-built_in">setHolder</span>(req_info);<br>    loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;HttpData::newEvent, req_info));<br>  &#125;<br>  acceptChannel_-&gt;<span class="hljs-built_in">setEvents</span>(EPOLLIN | EPOLLET);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>WebServer项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP知识总结</title>
    <link href="/2023/02/01/CSAPP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/01/CSAPP%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>第一章：计算机系统漫游</strong></p><p>1、从源程序到目标程序的四个阶段：预处理器，编译器，汇编器，链接器，系统硬件组成的四个部分：处理器，主存，I&#x2F;O，总线，逻辑主存即线性数组，物理主存即动态随机存储内存（DRAM），处理器核心是程序计数器，本身是一个字，来存储下一条指令的地址，指令操作围绕主存、寄存器和ALU进行，CPU执行一个目标文件的流程，首先把文件从磁盘读取到寄存器，再放到主存中，然后从主存读取指令开始执行，对数字来说，把数字读到寄存器中，再输出到显示器</p><p>2、L1cache位于CPU上，有几十Mb，比L2快5倍，L2比主存快5<del>10倍，存储器层次结构有7层（寄存器、L1SRAM、L2SRAM、L3SRAM、DRAM、本地磁盘、分布式服务器），把上一层作为下一层的高速缓存，操作系统的三个基本抽象概念，进程、虚拟内存和文件，进程是系统正在执行的程序，某一时刻只执行一个进程，操作系统内核是操作系统常驻主存的部分，负责管理进程的切换，方式是上下文切换，虚拟地址空间从低到高依次是，程序代码和数据、运行时堆、共享库、用户栈、内核虚拟内存，并发交错，并行同时，超线程一个核两个线程，等待执行另一个线程，硬件的交错执行，一个指令需要20多个时钟周期，并行后一秒可以执行2</del>4个指令</p><p>3、ASICⅡ标准表示文本字符，用一个字节的整数值来表示一种字符，所有信息都是由一串比特位表示的，源程序到目标程序的四个步骤，源程序被预处理器处理得到修改了的源程序、再由编译器处理得到汇编程序、汇编程序由汇编器处理得到可重定位的目标程序、最后由链接器链接得到可执行目标程序</p><p>4、编译系统作用，优化程序性能、理解链接时出现的错误、避免安全漏洞，64位系统即总线一次可以传输64位，I&#x2F;O通过一个控制器或适配器与I&#x2F;O总线相连，处理器解释存储在主存中指令的引擎，核心是程序计数器，存储CPU即将执行的下一条指令的地址，也是不断执行PC指向的指令，更新又执行，简单指令操作，加载、存储、操作、跳转</p><p>5、操作系统根据上下文切换来实现并发运行，上下文是跟踪进程运行所需的所有状态信息，存在于PC、寄存器文件、主存等地方，内核不是一个独立的进程，是一系列代码和数据的集合，应用程序如遇操作系统的操作时，将控制权交给内核，用完返回</p><p>6、虚拟内存，机器级别程序将内存视为数组，内存的每个字节由地址来标识，集合作为虚拟地址空间，由程序代码和数据、运行时堆、共享库、用户栈和内核虚拟内存组成，地址由低到高，文件是字节序列</p><p>7、每条指令从开始到结束需要20多个时钟周期，通过指令级别并行，实现每个周期2~4条指令的执行效率，指令集架构是对CPU硬件的抽象，CPU看似一次只执行机器代码程序的一条指令，实则底层硬件并行地执行多条指令</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676597496015-1620e055-baad-4b4e-9ad6-e8bf30da256c.png" alt="img"></p><p><strong>第二章：信息的表示和处理</strong></p><p>1、有确定字长的整数，定义在头文件&lt;stdint.h&gt;中，字长决定了虚拟空间的大小，小端低位低字节、大端高位低字节，浮点运算不可结合，字节作为最小的可寻址的内存单位，数据类型不在机器级程序中，指针的值是某个存储块的第一个字节的虚拟地址，每个程序对象可以视为一个字节块</p><p>2、虚拟地址用一个字来编码，字长决定了虚拟地址空间的大小，32位对应4GB虚拟地址空间，64位对应16EB虚拟地址空间，对于跨越多字节的对象，它的地址是它所用字节中的最小地址，Unicode即UTF-8使用的是4字节表示字符，二进制代码不兼容，一般不移植，程序就是一个字节序列，逻辑右移左端补0，算术右移左端补有效值</p><p>3、IEEE浮点表示，分为三部分，符号S，阶码E，尾数M，根据范围精度做摄入，类型转换可能发生的舍入或溢出</p><p><strong>第三章：程序的机器级表示</strong></p><p>1、编译器基于编程语言的规则、操作系统的惯例、目标机器的指令集生成机器代码，汇编代码是机器代码的文本表示，高级代码的可移植性好，机器级程序的两种抽象，指令集架构、虚拟地址，汇编代码不区分有符号数和无符号数，不区分指针的不同类型，不区分指针和整数</p><p>2、链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置，16个低寄存器的低位部分都可以作为字节、字、双字、四字来单独访问，即al、ax、eax、rax，指令的三种操作数，立即数、寄存器、内存引用，算数和逻辑操作共有四组，加载有效地址、一元操作、二元操作、移位，</p><p>3、根据条件语句、循环语句、分支语句控制执行，测试数据值，使用jump指令跳转，条件码描述了最近的算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，跳转分PC相对跳转、绝对地址编码</p><p><strong>第四章：处理器体系架构</strong></p><p>1、程序中每条指令都会读取或修改处理器状态的某些部分，即程序员可见状态，RF、CC、Stat、DMEM、PC，每条指令需要1~10个字节不等，每条指令的第一个字节表明指示的类型，高4位是code部分，低4位是function部分，指令长度和指令功能相关，有些需要操作数的指令编码就更长一点，SEQ分为取指阶段、译码和写回阶段、执行阶段、访存阶段和更新PC阶段</p><p>2、流水线引入反馈系统，指令间可能产生的问题，数据相关和控制相关，也叫控制冒险和数据冒险，避免冒险的方式有暂停和转发，暂停技术阻塞一组指令在它们所处的阶段，而允许其他指令继续通过流水线，具体来说在译码阶段阻塞，以插入气泡的方式，类似nop指令，即状态不可修改，转发技术是将结果值直接从一个流水阶段传到较早阶段的技术，也叫旁路，总之要尽可能避免流水线冒险</p><p><strong>第五章：优化程序性能</strong></p><p>1、选择适当的算法和数据结构，理解优化编译器的能力和局限性，编写容易优化的代码，任务并行化，多核并行计算，消除不必要的内存引用</p><p>2、循环展开，增加每次迭代计算的元素数量，减少循环的迭代次数，将一组合并运算拆分成两个或更多的部分，最后结合提高性能</p><p><strong>第六章：存储器层次结构</strong></p><p>1、程序本身具有良好的局部性，程序倾向于引用临近于其他最近引用过的数据项对的数据项，分为时间局部性和空间局部性，时间体现在连贯还会出现在未来，空间体现在内存位置上</p><p>2、高速缓存存储器，有SRAM组成，直接制作在CPU芯片内，速度如CPU，程序运行时，CPU部分数据指令会预先成批拷贝在Cache中，当CPU从内存读写数据或指令时，先检查Cache</p><p>3、每个组只有一行的高速缓存称为直接映射高速缓存，包括了组选择、行匹配、字选择、行替换，时间小，但缺失率高，全相联高速缓存是由一个包含所有高速缓存行的组组成的，只适合做小的高速缓存，如虚拟内存系统中的翻译备用缓冲器，该部件用于缓存页表项，组相联高速缓存是上述两种高速缓存的结合体，当数据不命中时，替换组的某一行有以下方法，随机替换算法、先进先出算法、最近最少用LRU、最不经常用LFU，合理运用了栈的结构</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676611912029-19b33bc5-0b2b-495a-b655-c97877ba1b67.png" alt="img"></p><p><strong>第七章：链接</strong></p><p>1、存在于编译、加载和运行三个阶段，链接是由链接器自动执行的，静态链接，重定位目标文件组合形成一个可执行目标文件和命令行参数作为输入，生成完全链接的、可以加载运行的可执行目标文件作为输出，链接器的两个任务，符号解析和重定位</p><p>2、三种目标文件的形式，可重定位目标文件、可执行目标文件、共享目标文件（动态链接库），静态库需要定期维护和更新，调用的静态库中的函数在运行时会被复制到每个运行进程的文本段中，.so文件中包含所有引用该库的可执行目标文件共享里面的代码和数据</p><p>3、链接器可以解析引用，维护可重定位目标文件的集合E，未解析的符号集合U，已定义的符号集合D，库一般放在命令行的结尾，如果双向引用，可以在命令行上重复库</p><p>4、动态链接的应用，分发软件，构建高性能web服务器，linux中dlopen函数允许应用程序在运行时加载和链接共享库，disym函数用来调用共享库的函数</p><p><strong>第八章：异常控制流</strong></p><p>1、通过控制流发生突变来应对各种系统状态，各个上下文切换，发送与程序通过使用陷阱trap或系统调用的ECF形式，向操作系统请求服务，CPU检测事件发生时，通过一张异常表的跳转表，跳至处理特定异常的异常处理程序进行处理</p><p>2、异常处理完成后，会发生以下三种情况中的一种，控制流返回当前指令，控制流返回下一条指令，中止当前被中断的程序，进程上下文由程序运行所需状态组成，包括内存中的代码与数据、栈、寄存器内容、环境变量、文件描述符等</p><p>3、一个逻辑流的执行时间在时间上与另一个流重叠，称为并发流，进程总是出于运行、停止、终止这三种状态，运行在内核模式对的进程可以执行指令集中的任何指令，并且可以访问内存中的任何位置，linux信号提供一种机制，以此通知用户进程发生了这些异常</p><p>4、内核通过更新目的进程上下文的某个状态，发送一个信号给目标进程，进程可以忽略信号，终止或者通过执行信号处理程序来捕获这个信号，每个信号类型都有一个预定义的默认行为，信号不排队，存在条件竞争</p><p><strong>第九章：虚拟内存</strong></p><p>1、虚拟内存的三大能力，第一是将内存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，第二是每个进程提供了一致的地址空间，简化了内存管理，第三是保护进程的地址空间不被其他进程破坏，虚拟内存遍及计算机系统的所有层面，同时虚拟内存赋予程序创建和销毁内存片的能力，内存片映射到磁盘文件的某个部分，应用程序引用指针或动态分配时，都会虚拟内存交互</p><p>2、现代CPU使用虚拟寻址，CPU通过虚拟地址访问主存，实质还是要翻译成物理地址，这个翻译是建立在CPU硬件和操作系统之上的，主存中的每个字节都有一个虚拟地址和一个物理地址</p><p>3、DRAM缓存的组织结构与高速缓存有很大不同，DRAM缓存全相联，任何虚拟页都可以放在任何的物理页中，延时写，页表存放在DRAM中，将虚拟页映射到物理页，翻译时读页表，操作系统负责维护页表的内容</p><p>4、虚拟内存同样也用到了局部性，要比较工作集的大小和DRAM的大小，产生抖动的情况，页面会不断换进换出，不同进程的虚拟页面可能映射到同一个物理页面上，PTE上增加的额外许可位来控制虚拟页面内容的访问，如SUB、READ、WRITE，页表基址指向当前页表，内存管理单元MMU利用虚拟页号来选择适当的PTE，将PTE中的物理页号和虚拟地址中的虚拟页偏移量串连起来得到了对应的物理地址</p><p>5、利用翻译后备缓冲器TLB加速地址翻译，TLB采用了具有较高相联度的组相联方式，多级页表从两个方面降低了内存需求，一级存在PTE才看二级，最常用才在主存中</p><p>6、linux将虚拟内存组织成段的集合，一个区域是已分配的虚拟内存的连续片，不同区域有间隙，linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，初始化这个虚拟内存区域的内容，即内存映射，有两种类型的对象，linux文件系统中的普通文件和匿名文件，交换空间的大小限制了当前运行着的进程了唔够分配的虚拟页面的总数</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1676648301084-7eac08a5-2fbf-4e5a-9fa1-6a0a242adca0.png" alt="img"></p><p><strong>第十章：系统级IO</strong></p><p>1、输入&#x2F;输出是在主存和外部设备之间复制数据的过程，作为处理文件的接口，步骤有打开文件，即标准输入，标准输出，标准错误、关闭文件、读文件、写文件和改变当前的文件位置</p><p>2、设计缓冲区避免字节陷入内核，使用rio家族函数，描述符缓冲区的联系，文件元数据的读入，是通过stat和fstat函数完成，通过readdir系列函数读取目录的内容，流是对有序列表的抽象，内核使用三个相关的数据结构来表示打开的文件，第一是描述符表，第二是文件表，第三是v-node表，文件中的不同表项可能表示同一文件，多个描述符家具有相同的文件位置意味着它们读取文件的进度会相互影响</p><p>3、linux shell有I&#x2F;O重定向操作符，允许用户将磁盘文件和标准输入联系起来，套接字由文件描述符引用，进程他用过读写套接字描述符来与其他计算机进程通信</p><p>4、输入函数要在fflush清空缓冲区之后再及逆行输出函数，同样输出函数要到了文件描述符之后才能接输入函数</p><p><strong>第十一章：网络编程</strong></p><p>1、网络本身由各种局域网和广域网组成，主机跨过不兼容网络向另一主机发送数据，主机和路由器上的协议，这样的协议就必须有两种基本能力，命名机制和传送机制，封装是互联网思想精髓，客户端服务端基本操作是事务</p><p>2、一个套接字连接一个端点，每个套接字有响应的套接字地址，客户端套接字端口由内核分配，记为临时端口，服务端记为知名端口，套接字对，使用这样的元组(cliaddr:cliport, servaddr:servport)来表示，socket interface本身作为一组函数，与Unix I&#x2F;O结合，以创建网络应用，socket函数创建的描述符对应于主动套接字，listen将sockfd从一个主动套接字转化为一个监听套接字，accept返回一个已连接的描述符，监听描述符作为客户端连接请求的一个端点，被创建一次，并存在于服务器的整个生命周期，已连接描述符是客户端和服务器端之间已经建立起连接的一个端点，存在于服务器为一个客户端服务的过程</p><p>3、阻塞可以发生在accept，等待监听描述符listenfd上的连接请求，同样阻塞也可发生在客户端调用和connect，数据在主机上通过系统调用在进程的虚拟地址空间与内核间传送，数据在网络间传送</p><p><strong>第十二章：并发编程</strong></p><p>1、OS提供了三种基本的构造并发程序的方法，第一是进程，每个逻辑控制流都是一个进程，由内核调度并维护，控制流使用显示的进程间通信机制来实现与其他流的通信，第二是I&#x2F;O多路复用，应用程序在一个进程的上下文显示地调用自己的逻辑流，这种逻辑流会转换为状态机，数据到达文件描述符后，主程序状态转换，第三是线程，是运行在单一进程上下文中的逻辑流，由内核调度</p><p>2、基于进程的并发编程，使用到fork、exec、waitpid等函数，服务器监听监听描述符的连接请求，接受请求后返回给客户端一个已连接的描述符，子进程可获得服务器的描述表的副本，父进程可以关闭已连接的副本，文件描述符指向同一个文件表表项，父进程必须关闭，否则会内存泄漏</p>]]></content>
    
    
    
    <tags>
      
      <tag>my notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boost网络编程</title>
    <link href="/2023/01/31/boostnet/"/>
    <url>/2023/01/31/boostnet/</url>
    
    <content type="html"><![CDATA[<p>Boost 库是一个开源的 C++ 库，其中包含了许多有用的组件和工具，包括网络编程组件。下面列出 Boost 库中的几个核心的网络编程组件：</p><ol><li>Boost.Asio：Boost.Asio 是 Boost 库中最重要的网络编程组件，它是一个跨平台的异步 I&#x2F;O 库，提供了网络编程所需的各种功能，如 TCP 和 UDP 协议、异步 I&#x2F;O 操作、定时器、信号等等。Boost.Asio 的接口设计精简，使用起来相对简单，支持各种操作系统和编译器。</li><li>Boost.Beast：Boost.Beast 是一个基于 Boost.Asio 的 HTTP 和 WebSocket 库，提供了 HTTP 和 WebSocket 协议的解析和序列化、数据帧的处理等等，可以用来编写高性能的 HTTP 或 WebSocket 服务器和客户端。</li><li>Boost.Asio SSL：Boost.Asio SSL 是 Boost.Asio 的 SSL&#x2F;TLS 扩展，提供了 SSL&#x2F;TLS 安全协议的支持，可以用来编写安全的网络应用程序。</li><li>Boost.Process：Boost.Process 是一个跨平台的进程管理库，可以用来创建和管理子进程，可以用来编写网络应用程序的管理程序。</li><li>Boost.Iostreams：Boost.Iostreams 是一个输入输出流库，提供了丰富的输入输出操作，包括压缩、加密、解密、转换等等，可以用来编写高效的网络数据流处理程序。</li></ol><p>总之，Boost 库提供了丰富的网络编程组件，可以帮助 C++ 开发者编写高效、安全、跨平台的网络应用程序。</p><p>TCP server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;iostream&gt;<br>#include &lt;boost/asio.hpp&gt;<br><br>using namespace boost::asio;<br><br><span class="hljs-type">int</span> main() &#123;<br>    io_service io;<br>    ip::tcp::acceptor acceptor(io, ip::tcp::endpoint(ip::tcp::v4(), <span class="hljs-number">8080</span>));<br><br>    while (<span class="hljs-literal">true</span>) &#123;<br>        ip::tcp::socket socket(io);<br>        acceptor.accept(socket);<br><br>        std::<span class="hljs-type">string</span> message = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>        boost::system::error_code <span class="hljs-type">error</span>;<br>        write(socket, buffer(message), <span class="hljs-type">error</span>);<br><br>        socket.shutdown(ip::tcp::socket::shutdown_both, <span class="hljs-type">error</span>);<br>        socket.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TCP client</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;iostream&gt;<br>#include &lt;boost/asio.hpp&gt;<br><br>using namespace boost::asio;<br><br><span class="hljs-type">int</span> main() &#123;<br>    io_service io;<br>    ip::tcp::socket socket(io);<br><br>    socket.connect(ip::tcp::endpoint(ip::address::from_string(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">8080</span>));<br><br>    char buffer[<span class="hljs-number">1024</span>];<br>    boost::system::error_code <span class="hljs-type">error</span>;<br>    size_t read_size = read(socket, buffer, sizeof(buffer), <span class="hljs-type">error</span>);<br><br>    std::cout &lt;&lt; std::<span class="hljs-type">string</span>(buffer, read_size) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    socket.shutdown(ip::tcp::socket::shutdown_both, <span class="hljs-type">error</span>);<br>    socket.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上示例中，TCP 服务器创建了一个 <strong>ip::tcp::acceptor</strong> 对象，并在端口号 <strong>8080</strong> 上监听客户端连接。当有客户端连接时，服务器创建一个 <strong>ip::tcp::socket</strong> 对象，并向客户端发送 “Hello, World!” 的消息，然后关闭连接。</p><p>TCP 客户端创建了一个 <strong>ip::tcp::socket</strong> 对象，并连接到服务器的 IP 地址和端口号。然后，客户端从服务器接收消息，并打印在控制台上。最后，客户端关闭连接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WebServer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLite和小程序交互</title>
    <link href="/2023/01/30/sqlitexcx/"/>
    <url>/2023/01/30/sqlitexcx/</url>
    
    <content type="html"><![CDATA[<p>SQLite是一种轻量级的关系型数据库管理系统，支持在本地存储和管理数据。通过在微信小程序中使用小程序提供的wx.request() API与后台服务器进行交互，可以将数据存储到SQLite数据库中。小程序提供了wx.openDatabase() API，可以在小程序中创建和操作SQLite数据库。可以使用小程序提供的API来获取用户输入的文本信息，将其存储到SQLite数据库中，并在需要时从数据库中检索和显示数据。同时，小程序还提供了wx.getStorage()和wx.setStorage() API，可以在本地存储和读取数据，也可以使用这些API来实现记事本的功能。需要注意的是，SQLite是一种本地存储的数据库系统，因此在微信小程序中使用SQLite，只能存储在小程序用户的本地设备上，而不是在远程服务器上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化数据库</span><br><span class="hljs-type">const</span> db = wx.<span class="hljs-built_in">openDatabase</span>(&#123;<br>  name: <span class="hljs-string">&#x27;notes&#x27;</span>,<br>  version: <span class="hljs-string">&#x27;1.0&#x27;</span>,<br>  description: <span class="hljs-string">&#x27;notes database&#x27;</span>,<br>  size: <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>,<br>&#125;);<br><br><span class="hljs-comment">// 创建数据表</span><br>db.<span class="hljs-built_in">transaction</span>(<span class="hljs-built_in">function</span> (tx) &#123;<br>  tx.<span class="hljs-built_in">executeSql</span>(<span class="hljs-string">&#x27;CREATE TABLE IF NOT EXISTS notes (id INTEGER PRIMARY KEY, content TEXT)&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 添加笔记</span><br><span class="hljs-function">function <span class="hljs-title">addNote</span><span class="hljs-params">(content, callback)</span> </span>&#123;<br>  db.<span class="hljs-built_in">transaction</span>(<span class="hljs-built_in">function</span> (tx) &#123;<br>    tx.<span class="hljs-built_in">executeSql</span>(<span class="hljs-string">&#x27;INSERT INTO notes (content) VALUES (?)&#x27;</span>, [content], <span class="hljs-built_in">function</span> (tx, res) &#123;<br>      callback &amp;&amp; <span class="hljs-built_in">callback</span>(res.insertId);<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 获取笔记列表</span><br><span class="hljs-function">function <span class="hljs-title">getNotes</span><span class="hljs-params">(callback)</span> </span>&#123;<br>  db.<span class="hljs-built_in">transaction</span>(<span class="hljs-built_in">function</span> (tx) &#123;<br>    tx.<span class="hljs-built_in">executeSql</span>(<span class="hljs-string">&#x27;SELECT * FROM notes&#x27;</span>, [], <span class="hljs-built_in">function</span> (tx, res) &#123;<br>      callback &amp;&amp; <span class="hljs-built_in">callback</span>(res.rows);<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 根据 ID 获取笔记</span><br><span class="hljs-function">function <span class="hljs-title">getNoteById</span><span class="hljs-params">(id, callback)</span> </span>&#123;<br>  db.<span class="hljs-built_in">transaction</span>(<span class="hljs-built_in">function</span> (tx) &#123;<br>    tx.<span class="hljs-built_in">executeSql</span>(<span class="hljs-string">&#x27;SELECT * FROM notes WHERE id = ?&#x27;</span>, [id], <span class="hljs-built_in">function</span> (tx, res) &#123;<br>      callback &amp;&amp; <span class="hljs-built_in">callback</span>(res.rows.<span class="hljs-built_in">item</span>(<span class="hljs-number">0</span>));<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 更新笔记</span><br><span class="hljs-function">function <span class="hljs-title">updateNoteById</span><span class="hljs-params">(id, content, callback)</span> </span>&#123;<br>  db.<span class="hljs-built_in">transaction</span>(<span class="hljs-built_in">function</span> (tx) &#123;<br>    tx.<span class="hljs-built_in">executeSql</span>(<span class="hljs-string">&#x27;UPDATE notes SET content = ? WHERE id = ?&#x27;</span>, [content, id], <span class="hljs-built_in">function</span> (tx, res) &#123;<br>      callback &amp;&amp; <span class="hljs-built_in">callback</span>(res.rowsAffected);<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 删除笔记</span><br><span class="hljs-function">function <span class="hljs-title">deleteNoteById</span><span class="hljs-params">(id, callback)</span> </span>&#123;<br>  db.<span class="hljs-built_in">transaction</span>(<span class="hljs-built_in">function</span> (tx) &#123;<br>    tx.<span class="hljs-built_in">executeSql</span>(<span class="hljs-string">&#x27;DELETE FROM notes WHERE id = ?&#x27;</span>, [id], <span class="hljs-built_in">function</span> (tx, res) &#123;<br>      callback &amp;&amp; <span class="hljs-built_in">callback</span>(res.rowsAffected);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先使用 <strong>wx.openDatabase()</strong> 函数打开了一个名为 <strong>notes</strong> 的 SQLite 数据库，并创建了一个名为 <strong>notes</strong> 的数据表。我们还定义了一些函数来操作这个数据库，例如 <strong>addNote()</strong> 用于添加一条笔记，<strong>getNotes()</strong> 用于获取所有笔记，<strong>getNoteById()</strong> 用于根据 ID 获取一条笔记，<strong>updateNoteById()</strong> 用于更新一条笔记，<strong>deleteNoteById()</strong> 用于删除一条笔记。</p><p>这些函数通过调用 <strong>wx.request()</strong> 来与后台服务器进行交互，并使用 SQLite 数据库来存储和管理数据。在微信小程序中，我们可以使用小程序提供的 <strong>wx.request()</strong> API 来与后台服务器进行交互，并使用小程序提供的 <strong>wx.openDatabase()</strong> API 来创建和操作 SQLite 数据库。同时，我们还可以使用小程序提供的 <strong>wx.getStorage()</strong> 和 <strong>wx.setStorage()</strong> API 来在本地存储和读取数据。</p><p>SQLite是一种轻量级的关系型数据库管理系统，支持在本地存储和管理数据。通过在微信小程序中使用小程序提供的wx.request() API与后台服务器进行交互，可以将数据存储到SQLite数据库中。</p><p>小程序还提供了wx.getStorage()和wx.setStorage() API，可以在本地存储和读取数据，也可以使用这些API来实现记事本的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQLite项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HttpServer</title>
    <link href="/2023/01/29/httpserver/"/>
    <url>/2023/01/29/httpserver/</url>
    
    <content type="html"><![CDATA[<p>设计一个C++ web服务器，一般需要以下步骤：</p><ol><li>选择合适的网络库：可以选择传统的socket编程，也可以使用一些网络库，如Boost.Asio、libuv等，它们能够方便地处理网络通信和并发请求。</li><li>实现HTTP协议解析：C++ Web服务器需要能够处理HTTP请求和响应，因此需要解析HTTP协议。一种比较流行的实现方法是使用正则表达式或有限状态机。</li><li>实现路由：路由是将请求与相应的处理程序相匹配的过程。可以使用正则表达式或其他路由库来实现路由。</li><li>实现业务逻辑处理：Web服务器需要处理客户端的请求并返回响应。这通常包括查询数据库、读取文件、计算等操作。</li><li>处理并发请求：Web服务器需要能够处理并发请求，这意味着可以同时处理多个请求。可以使用多线程、多进程或者异步I&#x2F;O模型来处理并发请求。</li><li>实现静态资源服务：除了动态页面，Web服务器还需要能够提供静态资源，如HTML、CSS、JavaScript文件等。</li><li>实现HTTPS支持：如果需要支持HTTPS，需要使用TLS&#x2F;SSL协议来保护客户端与服务器之间的通信。</li><li>日志记录：Web服务器需要记录请求日志，以便后续调试和分析。</li></ol><p>如果是 HTTP 服务器的话，相比于 C++ Web 服务器，可以简化一些步骤，具体步骤如下：</p><ol><li>选择合适的网络库：同样可以选择传统的 socket 编程或者网络库来处理网络通信和并发请求。</li><li>实现 HTTP 协议解析：和 C++ Web 服务器一样，需要能够解析 HTTP 协议，以便正确地处理客户端的请求和响应。</li><li>处理请求并返回响应：HTTP 服务器需要根据客户端的请求处理并返回响应。对于 HTTP 服务器来说，这通常是处理静态资源，如 HTML、CSS、JavaScript 等文件。</li><li>处理并发请求：同样需要考虑并发请求的情况，可以使用多线程、多进程或者异步 I&#x2F;O 模型来处理并发请求。</li><li>日志记录：HTTP 服务器也需要记录请求日志，以便后续调试和分析。</li></ol><p>总的来说，相比于 C++ Web 服务器，HTTP 服务器的设计思路相对简单一些，因为它通常只需要处理静态资源，而不需要涉及到业务逻辑和路由等复杂问题。但是，HTTP 服务器同样需要考虑性能和安全问题，如并发请求和防止恶意请求等问题。</p><p>Http Server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;iostream&gt;<br>#include &lt;<span class="hljs-type">string</span>&gt;<br>#include &lt;thread&gt;<br>#include &lt;sys/socket.h&gt;<br>#include &lt;netinet/in.h&gt;<br>#include &lt;arpa/inet.h&gt;<br>#include &lt;unistd.h&gt;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> PORT = <span class="hljs-number">8080</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> BUFFER_SIZE = <span class="hljs-number">1024</span>;<br><br>void handle_request(<span class="hljs-type">int</span> client_fd) &#123;<br>    char buffer[BUFFER_SIZE];<br>    ssize_t read_size = read(client_fd, buffer, BUFFER_SIZE);<br><br>    std::<span class="hljs-type">string</span> response = <span class="hljs-string">&quot;HTTP/1.1 200 OK\nContent-Type: text/html\n\nHello, World!&quot;</span>;<br><br>    write(client_fd, response.c_str(), response.size());<br>    <span class="hljs-built_in">close</span>(client_fd);<br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> server_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (server_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to create server socket\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">struct</span> sockaddr_in server_addr;<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    server_addr.sin_port = htons(PORT);<br><br>    <span class="hljs-keyword">if</span> (bind(server_fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to bind to port &quot;</span> &lt;&lt; PORT &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (listen(server_fd, <span class="hljs-number">128</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to listen on port &quot;</span> &lt;&lt; PORT &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Listening on port &quot;</span> &lt;&lt; PORT &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    while (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">struct</span> sockaddr_in client_addr;<br>        socklen_t client_len = sizeof(client_addr);<br>        <span class="hljs-type">int</span> client_fd = accept(server_fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);<br>        <span class="hljs-keyword">if</span> (client_fd &lt; <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to accept client connection\n&quot;</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        std::thread t(handle_request, client_fd);<br>        t.detach();<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(server_fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个简单的 HTTP 服务器使用了传统的 socket 编程，通过 <strong>socket()</strong> 创建服务器 socket，使用 <strong>bind()</strong> 绑定端口号，使用 <strong>listen()</strong> 开始监听客户端连接。在 <strong>while</strong> 循环中，使用 <strong>accept()</strong> 接受客户端连接，使用 <strong>std::thread</strong> 开启一个新线程处理客户端请求。处理请求的方法 <strong>handle_request()</strong> 读取客户端请求，然后返回一个简单的字符串响应。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WebServer项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11知识总结</title>
    <link href="/2023/01/28/cpp11%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/28/cpp11%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>1、c++11的一些特性</p><p><em><strong>类型推导</strong></em>——C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p><p>其中有两个关键字：</p><ul><li><strong>auto</strong>：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">auto a = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> boost::typeindex::type_id_with_cur&lt;decltype(a)&gt;().pretty_name() = int<br></code></pre></td></tr></table></figure><ul><li><strong>decltype</strong>：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;i = <span class="hljs-number">1</span>;<span class="hljs-keyword">decltype</span>(i) b = <span class="hljs-number">2</span>; <span class="hljs-comment">// boost::typeindex::type_id_with_cur&lt;decltype(b)&gt;().pretty_name() = const int&amp;</span><br></code></pre></td></tr></table></figure><p><em><strong>左值右值</strong></em>——复制构造和移动构造，空间占用堆内存是否拷贝，如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。</p><p>std::move函数可以将左值转换为右值引用，减少了不必要的拷贝操作。</p><p><code>std::string str = &quot;Hello&quot;;std::vector&lt;string&gt; vec;vec.push_back(std::move(str)); // str==&quot;&quot;;</code><br>尽可能地<em><strong>列表初始化</strong></em></p><p><em><strong>std::function和lambda表达式</strong></em></p><p>可调用对象满足一点即可：</p><ul><li><p>是一个函数指针</p></li><li><p>是一个具有operator()成员函数的类对象(传说中的仿函数)，lambda表达式</p></li><li><p>是一个可被转换为函数指针的类对象</p></li><li><p>是一个类成员(函数)指针</p></li><li><p>bind表达式或其它函数对象</p></li></ul><p>function是上面这种可调用对象的封装器，可以把std::function看做一个函数对象，用于表示函数这个抽象概念。std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空，调用空的std::function的目标会抛出std::bad_function_call异常。</p><p>lambda表达式可以说是c++11引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> f1 = [=]()&#123; <span class="hljs-keyword">return</span> a; &#125;; <span class="hljs-comment">// 值捕获a</span><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">auto</span> f2 = [=]() &#123; <span class="hljs-keyword">return</span> a++; &#125;; <span class="hljs-comment">// 修改按值捕获的外部变量，error</span><br><span class="hljs-keyword">auto</span> f3 = [=]() <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> a++; &#125;;<br></code></pre></td></tr></table></figure><p><em><strong>default</strong></em>默认构造函数，这就不会让编译器隐式生成默认构造函数</p><p><em><strong>nullptr</strong></em>是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。</p><p><em><strong>final和override</strong></em>，其中final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><p><em><strong>enum class</strong></em>带作用域的枚举代码，使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AColor</span> &#123;<br>    kRed,<br>    kGreen,<br>    kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BColor</span> &#123;<br>    kWhite,<br>    kBlack,<br>    kYellow<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">AColorc</span> &#123;<br>    kRed,<br>    kGreen,<br>    kBlue<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">BColorc</span> &#123;<br>    kWhite,<br>    kBlack,<br>    kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (kRed == kWhite) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (AColorc::kRed == BColorc::kWhite) &#123; <span class="hljs-comment">// 编译失败</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>constexpr</strong></em>用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：</p><p>两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程调度方法</title>
    <link href="/2023/01/26/call/"/>
    <url>/2023/01/26/call/</url>
    
    <content type="html"><![CDATA[<p>操作系统常用的进程调度方法包括以下几种：</p><ol><li>先来先服务（FCFS）：按照进程提交的顺序进行调度，先提交的进程先执行，无法适应多种进程的优先级和时间要求。</li><li>短作业优先（SJF）：按照进程的执行时间进行调度，短作业优先，有利于短作业快速完成，但是可能导致长作业长时间得不到执行。</li><li>优先级调度（Priority Scheduling）：按照进程的优先级进行调度，优先级高的进程先执行，适用于多种进程优先级不同的情况，但可能会导致低优先级的进程长时间得不到执行。</li><li>时间片轮转（Round Robin）：将 CPU 时间分成一段一段的时间片，按照时间片轮流调度各个进程，适用于多个进程的时间要求不同的情况，但可能会导致进程切换开销较大。</li><li>多级反馈队列调度（Multilevel Feedback Queue Scheduling）：将进程按照优先级分成多个队列，并在队列之间进行调度，适用于多种进程的时间要求和优先级不同的情况，但需要调整好不同队列之间的时间片和优先级的设置。</li></ol><p>不同的进程调度算法各有优缺点，需要根据具体的场景和需求进行选择和调整。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++使用Boost库实现WebServer程序</title>
    <link href="/2023/01/25/wbsboost/"/>
    <url>/2023/01/25/wbsboost/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio::ip;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HttpServer</span>(io_service&amp; io_service, <span class="hljs-type">int</span> port)<br>    : <span class="hljs-built_in">acceptor_</span>(io_service, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port))<br>  &#123;<br>    <span class="hljs-built_in">DoAccept</span>();<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoAccept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> socket = std::<span class="hljs-built_in">make_shared</span>&lt;tcp::socket&gt;(acceptor_.<span class="hljs-built_in">get_io_service</span>());<br>    acceptor_.<span class="hljs-built_in">async_accept</span>(*socket, [<span class="hljs-keyword">this</span>, socket](<span class="hljs-type">const</span> boost::system::error_code&amp; ec) &#123;<br>      <span class="hljs-keyword">if</span> (!ec) &#123;<br>        <span class="hljs-keyword">auto</span> request = std::<span class="hljs-built_in">make_shared</span>&lt;HttpRequest&gt;(socket);<br>        <span class="hljs-keyword">auto</span> response = std::<span class="hljs-built_in">make_shared</span>&lt;HttpResponse&gt;(socket);<br>        <span class="hljs-built_in">ProcessRequest</span>(request, response);<br>      &#125;<br>      <span class="hljs-built_in">DoAccept</span>();<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessRequest</span><span class="hljs-params">(std::shared_ptr&lt;HttpRequest&gt; request, std::shared_ptr&lt;HttpResponse&gt; response)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (request-&gt;<span class="hljs-built_in">Method</span>() == <span class="hljs-string">&quot;GET&quot;</span> &amp;&amp; request-&gt;<span class="hljs-built_in">Url</span>() == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>      response-&gt;<span class="hljs-built_in">SetStatus</span>(<span class="hljs-number">200</span>);<br>      response-&gt;<span class="hljs-built_in">SetBody</span>(<span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      response-&gt;<span class="hljs-built_in">SetStatus</span>(<span class="hljs-number">404</span>);<br>      response-&gt;<span class="hljs-built_in">SetBody</span>(<span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br>    response-&gt;<span class="hljs-built_in">Send</span>();<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  tcp::acceptor acceptor_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    io_service io_service;<br>    <span class="hljs-function">HttpServer <span class="hljs-title">server</span><span class="hljs-params">(io_service, <span class="hljs-number">8080</span>)</span></span>;<br>    io_service.<span class="hljs-built_in">run</span>();<br>  &#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>    std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个简单的WebServer监听8080端口，并对根路径”&#x2F;“的GET请求返回一个包含”Hello, World!”的HTML页面，对其它请求返回404错误页面。其中HttpRequest和HttpResponse是封装了HTTP请求和响应的类。</p><p>使用的是Boost.Asio库来实现异步网络编程，提高WebServer的并发性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WebServer项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>析构函数</title>
    <link href="/2023/01/22/dtor/"/>
    <url>/2023/01/22/dtor/</url>
    
    <content type="html"><![CDATA[<p>C++中的析构函数通常被设计为虚函数，主要是为了解决基类指针指向派生类对象时可能会发生的内存泄漏问题。</p><ol><li>当基类指针指向一个派生类对象并调用 delete 操作符来释放内存时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这样就会导致派生类对象的资源没有被释放，从而产生内存泄漏。</li><li>如果基类的析构函数是虚函数，那么在调用 delete 操作符释放内存时，会先调用派生类的析构函数，然后再调用基类的析构函数，从而确保所有资源都被正确释放。<br>将析构函数声明为虚函数是一个良好的编程习惯，可以避免潜在的内存泄漏问题。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda</title>
    <link href="/2023/01/21/lambda/"/>
    <url>/2023/01/21/lambda/</url>
    
    <content type="html"><![CDATA[<p>C++11的Lambda特性</p><p><strong>lambda 匿名函数</strong>很简单，可以套用如下的<strong>语法格式</strong>：[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型         {           函数体;         };</p><p>其中各部分的含义分别为：</p><p>a. <strong>[外部变量方位方式说明符]</strong>     [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p><p>b. <strong>(参数)</strong>     和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p><p>c. <strong>mutable</strong>     此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。**注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p><p>d. <strong>noexcept&#x2F;throw()</strong>     可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p><p>e. <strong>-&gt; 返回值类型</strong>     指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”。</p><p>f. <strong>函数体</strong>     和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">//对 a 数组中的元素进行排序</span><br>    <span class="hljs-built_in">sort</span>(num, num+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">bool</span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; );<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : num)&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*    </span><br><span class="hljs-comment">    程序运行结果：</span><br><span class="hljs-comment">          1 2 3 4</span><br><span class="hljs-comment">*/</span>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>effective-c++知识总结</title>
    <link href="/2023/01/18/effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/18/effective-c-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>reference link: <a href="https://blog.csdn.net/qq_43763344/article/details/95447843">https://blog.csdn.net/qq_43763344/article/details/95447843</a></p><p><a href="https://blog.csdn.net/qq_43763344/article/details/107182731?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_43763344/article/details/107182731?spm=1001.2014.3001.5502</a></p><ol><li>将C++视为包含四个部分的语言联邦，第一是C，即区块、语句、预处理器、内置数据类型、数组和指针都来自于C，第二是Object-Oriented C++，即包含类、封装、继承、多态和动态绑定等，第三是Template C++，即C++泛型编程的部分，第四是STL，即包含容器、迭代器、算法和函数对象等</li><li>尽量以const, enum, inline替换#define，即以编译器替代预处理器（宏），define无作用域，inline函数代替define定义的函数式的宏，const成员声明为static成员，以保证const成员只有一份实体，对于形式函数的宏定义，使用inline函数替换#define</li><li>const可以被施加于任何作用域内的对象、函数对象、函数返回类型、成员函数本体，non-const版本调用const版本可以避免代码重复</li><li>对象在被使用前已被初始化，初始化列表，且成员变量的顺序应和类内声明顺序一致，用local static对象替换non-local static对象以避免跨编译单元初始化次序带来的问题</li><li>编译器默认为类创建default ctor，copy ctor，copy assignment、dtor</li><li>为了避免编译器自动生成函数，可以将相应的成员函数声明为private并且不予实现，表示拒绝</li><li>具有多态性的基类应该声明一个virtual dtor，如若类的设计目的不是作为基类使用，也不是多态，则不声明为virtual dtor</li><li>析构函数不可抛出异常，只能catch异常，以此结束程序，如若客户端对抛出的异常做出反应，这个类应该提供一个普通函数执行操作，而非系统狗函数中</li><li>绝不再ctor和dtor中调用virtual函数，子类先构造基类的ctor，此时类型式基类，当基类构造完成时，构造子类时，对象的类型才会变成子类，析构先子类后基类，类似栈模型，因此再构造和析构期间不调用virtual函数，因为这类调用的虚函数不会下降到派生类中的版本，永远是基类版本</li><li>用operator&#x3D;返回一个*this的引用，重载赋值运算符应该返回一个指向自身所属类的引用</li><li>重载赋值运算符保证对象自我赋值时operator&#x3D;有良好行为，确定任何函数操作以上一个对象，多个对象是同一对象时，也是正确的</li><li>copying函数确保复制对象内的所有成员变量和所有的基类成分，不要用copying函数实现另一个copying函数，应该放在第三个函数中，由两个copying函数共同调用，资源一旦用完就要归还</li><li>为防止资源泄漏，用RAII对象，在构造函数中获得资源，析构函数中释放资源，shared_ptr和auto_ptr作为两个常被使用的RAII智能指针</li><li>复制对象，复制资源，复制RAII对象必须一并复制它管理的资源，资源的copying行为决定RAII对象的copying行为，普遍常见的RAII类的copying行为是，阻止拷贝、使用引用计数法</li><li>API往往访问原始资源，每个RAII类都应该提供一个取得资源管理的方法，对原始资源的访问可能通过显示转换或隐式转换，显示转换比较安全，隐式转换对客户比较方便</li><li>new中使用到[]，相应的delete也应使用到[]，若没有使用，则相应也不使用</li><li>以独立的语句将newd对象置入智能指针，原始指针送进shared_ptr，也可能产生内存泄漏的问题，参数压栈的顺序不一样</li><li>接口正确使用，不被误用，factory函数可以返回一个指针指向Investment继承体系动态分配的对象，即Investment *createInvestment()，强迫客户返回值存在shared_ptr上，这样就不会释放资源</li><li>设计class考虑的问题，新type创建也要想如何销毁，初始化和赋值，值传递和引用传递，如何继承，隐式显示的转换，操作符以及member函数，type的未声明接口，对效率，异常安全，资源的影响</li><li>构造拷贝的时候，参数用const类型的引用，避免构造带来的开销，对象切割问题存在于基类对象或引用中</li><li>虽然引用效率高，但不要传递一些指向其实并不存在的对象，引用必须知道它引用的是谁，对象被释放，实体失效，栈中创建，函数结束即销毁失效，堆中创建，之心delete后失效，就算用static绑定对象也不行，无锁保护，两次函数改变的是调用值，返回的是reference，调用端看到的永远是现值</li><li>成员变量封装为private</li><li>非成员函数替代成员函数，提高封装性，跨文件扩展，如STL组件</li><li>成员函数第一个指针都是this指针，无法进行类型转换，非成员函数就不存在这个问题，传递参数发现类型不同，则隐式转换</li><li>不抛出异常的swap函数，使用指向对象的指针，通过交换指针来实现数据的交换，即不使用拷贝</li><li>尽可能延后变量定义的时间，如变量带构造函数和析构函数，本身受构造函数和析构函数的成本</li><li>尽量少做转型动作，常量性移除const_cast，向下安全转型dynamic_cast，低级转型reinterpret_cast，隐式转换static_cast，存在非对象调用类函数，而是对象基类的副本去调用</li><li>类返回对象成员的引用，客户端可以随意修改，这个问题的解决办法是在成员函数前面加const限制修改就行，但依然返回的是内部对象，即空悬、虚吊的情况</li><li>异常安全是一个函数内抛出异常，要做到不泄露资源、不破坏数据，对于互斥器使用对象去管理资源，对象释放的时候自动调用析构函数，可以使用智能指针去管理资源，就不用手动delete</li><li>内联函数可以避免函数调用的开销，在函数编译期间对函数调用进行替换为函数本体，以空间换取时间的策略，提供一种策略给编译器，看代码的复杂程度和编译器环境等，指针调用要知道函数地址，虚函数和构造函数不可设置为内联</li><li>文件间编译依赖关系降到最低，即声明和定义分开实现，尽可能让头文件自己满足，实在不行就与其他文件相关联</li><li>使用public继承出is-a的关系，继承者功能的丢失，需要单独写一个类</li><li>派生类的函数与基类同名会被覆盖，域名作用符来界定</li><li>区分接口继承和实现继承，非虚函数本质是不想在子类实现不同行为，状态保持不变</li><li>策略模式值得是定义一系列的算法，在运行的时候，根据对象不同，互相替换调用，这样的变化依赖稳定，稳定依赖于抽象，对扩展开放，对修改封闭</li><li>non-virtual都是静态绑定，函数编译时就应知道调用哪个函数了，根据指针类型来决定，而不是对象化类型决定调用哪个函数</li><li>不重新定义继承而来的缺省参数值，继承参数需要给出指指定</li><li>通过复合模型构造出has -a，复合有很多含义，如内嵌、分层、聚合，即运用于泛型编程中</li><li>private继承关系表明基类和子类没有任何观念上的表示，子类只想用基类良好的特性，private在软件层面上没有实际意义</li><li>多继承关系复杂，菱形继承的歧义性和数据冗余性，指定类来调用哪个函数，数据冗余用虚继承的方法，让子类继承它的虚方法，但会增加大小，速度初始化以及复杂度的成本</li><li>显示接口，实例和所属type，隐式接口用于泛型编程，在编译期间进行推导，接口本身具有多态性，代码复用性高，class和template都支持接口和多态，class接口是显示的，多态是通过虚函数发生在运行期，template接口是隐式的，多态是通过template具现化和函数重载解析发生在编译期</li><li>class和typename本质没区别，但typename定义一个类型的别名，标识嵌套从属类型，避免编译器识别为静态变量，但typename不可以出现在基类列或者成员初值列中内作为基类修饰符</li><li>模板特化，指定typename的类型，编译器可以识别，如果是全特化，那么无参数变化，即typename所有参数都被指定，模板中定义的函数，在模板派生类中是访问不到的，需要加this-&gt;指向基类成员</li><li>避免template的膨胀，建立一个带数值参数的函数，基类只对矩阵元素类型参数化，不对矩阵尺寸参数化，通过定义一个指针指向内存地址来解决基类查看派生类数据的问题</li><li>用成员函数模板接受所有兼容类型，指针继承关系下的隐式转换，引进模板就带来新的问题，类内部声明一个泛化的拷贝构造或者赋值操作符，同时声明正常的拷贝构造和赋值操作符，即内部有个返回智能指针对象原始指针的副本</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21906909/1677154916388-a84a97b9-25c5-43d8-8cbb-ac3a2ebf9c7e.png" alt="img"></p><ol><li>做类型转换时，为模板定义非成员函数，编译器要对T做类型推导，对基类构造函数做友元解释，对象被声明则具现化，作为过程一部分，下一步就是有元的声明</li><li>模板萃取技术，对不同的类型有不同的操作，针对一部分类型进行特化，特化的类型和没有特化的类型执行不同的逻辑程序、</li><li>元编程可以将工作由运行期迁移到编译期，以此更早侦测错误和获得更高的执行效率</li><li>new-handler一种程序，即当new出的内存不够需求或无法分配足够内存时，一个错误处理的程序，默认的处理方式是抛出异常</li><li>替换编译器默认的new operator和delete operator，差别对待不同需求，在分配内存之前搞懂软件如何使用内存</li><li>new-handler同样也应能处理0byte的申请</li><li>构造器要由指针指向之前申请的资源，避免内存泄漏</li><li>把warning当作error处理 </li><li>C++标准库，STL、lostreams、locales组成，TRI中添加了智能指针，hash-based容器，正则表达式</li><li>Boost社群，同时提供了TRI组件实现</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>my notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个基于 SQLite 的记事本项目的示例</title>
    <link href="/2023/01/17/jishiben/"/>
    <url>/2023/01/17/jishiben/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*  conn.cpp</span><br><span class="hljs-comment">*  用于连接选定的database</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sqlite3.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    sqlite3* db;<br>    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">sqlite3_open</span>(<span class="hljs-string">&quot;notes.db&quot;</span>, &amp;db);<br><br>    <span class="hljs-keyword">if</span> (rc != SQLITE_OK) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error opening SQLite database: &quot;</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;<br>        <span class="hljs-built_in">sqlite3_close</span>(db);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Opened database successfully&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-built_in">sqlite3_close</span>(db);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*  jishiben.cpp</span><br><span class="hljs-comment">*  记事本的CURD操作</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sqlite3.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 回调函数，用于打印查询结果</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv, <span class="hljs-type">char</span>** azColName)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i++) &#123;<br>        cout &lt;&lt; azColName[i] &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; (argv[i] ? argv[i] : <span class="hljs-string">&quot;NULL&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    sqlite3* db;<br>    <span class="hljs-type">char</span>* zErrMsg = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rc;<br><br>    <span class="hljs-comment">// 打开或创建数据库文件</span><br>    rc = <span class="hljs-built_in">sqlite3_open</span>(<span class="hljs-string">&quot;notes.db&quot;</span>, &amp;db);<br>    <span class="hljs-keyword">if</span> (rc) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t open database: &quot;</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; endl;<br>        <span class="hljs-built_in">sqlite3_close</span>(db);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建表格</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sql = <span class="hljs-string">&quot;CREATE TABLE IF NOT EXISTS Notes (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, content TEXT);&quot;</span>;<br>    rc = <span class="hljs-built_in">sqlite3_exec</span>(db, sql, callback, <span class="hljs-number">0</span>, &amp;zErrMsg);<br>    <span class="hljs-keyword">if</span> (rc != SQLITE_OK) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;SQL error: &quot;</span> &lt;&lt; zErrMsg &lt;&lt; endl;<br>        <span class="hljs-built_in">sqlite3_free</span>(zErrMsg);<br>    &#125;<br><br>    <span class="hljs-comment">// 插入数据</span><br>    sql = <span class="hljs-string">&quot;INSERT INTO Notes (title, content) VALUES (&#x27;Test Note&#x27;, &#x27;This is a test note.&#x27;);&quot;</span>;<br>    rc = <span class="hljs-built_in">sqlite3_exec</span>(db, sql, callback, <span class="hljs-number">0</span>, &amp;zErrMsg);<br>    <span class="hljs-keyword">if</span> (rc != SQLITE_OK) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;SQL error: &quot;</span> &lt;&lt; zErrMsg &lt;&lt; endl;<br>        <span class="hljs-built_in">sqlite3_free</span>(zErrMsg);<br>    &#125;<br><br>    <span class="hljs-comment">// 查询数据</span><br>    sql = <span class="hljs-string">&quot;SELECT * FROM Notes;&quot;</span>;<br>    rc = <span class="hljs-built_in">sqlite3_exec</span>(db, sql, callback, <span class="hljs-number">0</span>, &amp;zErrMsg);<br>    <span class="hljs-keyword">if</span> (rc != SQLITE_OK) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;SQL error: &quot;</span> &lt;&lt; zErrMsg &lt;&lt; endl;<br>        <span class="hljs-built_in">sqlite3_free</span>(zErrMsg);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭数据库</span><br>    <span class="hljs-built_in">sqlite3_close</span>(db);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质是：</p><ol><li>打开数据库 notes.db；</li><li>创建一个名为 NOTES 的表，该表有两列：ID 和 CONTENT；</li><li>向表中插入三条记录；</li><li>查询表中所有记录；</li><li>关闭数据库。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SQLite项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中四种类型转换</title>
    <link href="/2023/01/13/cppcast/"/>
    <url>/2023/01/13/cppcast/</url>
    
    <content type="html"><![CDATA[<p>C++中四种类型转换分别为<strong>const_cast、static_cast、dynamic_cast、reinterpret_cast</strong>，四种转换功能分别如下：</p><ol><li>const_cast 将const变量转为非const</li><li>static_cast最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。</li><li>dynamic_cast只能用于含有虚函数的类转换，用于类向上和向下转换<strong>向上转换：</strong>指子类向基类转换。    <strong>向下转换：</strong>指基类向子类转换。这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</li><li>reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。</li></ol><p><strong>注意：</strong>为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
